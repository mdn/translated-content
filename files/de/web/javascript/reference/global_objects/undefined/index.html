---
title: undefined
slug: Web/JavaScript/Reference/Global_Objects/undefined
tags:
  - JavaScript
translation_of: Web/JavaScript/Reference/Global_Objects/undefined
---
<div>{{jsSidebar("Objects")}}</div>

<p>Die globale Eigenschaft <code><strong>undefined</strong></code> repräsentiert den Wert <code>{{Glossary("Undefined", "undefined")}}</code> . Dieser Wert ist einer der {{Glossary("Primitive", "primitiven Typen")}} in JavaScript.</p>

<p>{{js_property_attributes(0,0,0)}}</p>

<div>{{EmbedInteractiveExample("pages/js/globalprops-undefined.html")}}</div>



<h2 id="Syntax" name="Syntax">Syntax</h2>

<pre class="syntaxbox"><code>undefined</code></pre>

<h2 id="Description" name="Description">Beschreibung</h2>

<p><code>undefined</code> ist eine Eigenschaft des <em>globalen Objektes</em>, was bedeutet, dass es eine Variable im globalen Gültigkeitsbereich ist. Der initiale Wert von <code>undefined</code> ist der primitive Wert <code>{{Glossary("Undefined", "undefined")}}</code>.</p>

<p>In modernen Browsern (JavaScript 1.8.5 / Firefox 4+) ist <code>undefined</code>  eine nicht konfigurierbare und nicht beschreibbare Eigenschaft. Dieses ist in der ECMAScript 5 Spezifikation definiert. Immer wenn das nicht der Fall ist, sollte das Überschreiben von <code>undefined</code>  unterlassen werden.</p>

<p>Eine Variable, die nicht mit einem Wert beschrieben wurde, ist vom Typ <code>undefined</code>. Methoden oder Anweisungen geben ebenfalls <code>undefined</code> zurück, wenn eine Variable, die ausgewertet wird, mit keinem Wert beschrieben ist. Eine Funktion hat <code>undefined</code> als Rückgabewert, wenn kein Wert {{jsxref("Statements/return", "zurückgegeben")}} wird.</p>

<div class="warning">
<p>Weil es möglich ist {{Glossary("Identifier", "Bezeichner")}} (Variablennamen) in jedem anderen Scope anders zu definieren, ist es auch möglich <code>undefined</code> neu zu defnieren (weil <code>undefined</code> kein {{jsxref("Reserved_Words", "reserviertes Schlüsselwort")}}) ist). Dieses einzusetzen ist jedoch keine gute Idee, weil der Quelltext dadurch schwer zu verstehen ist.</p>

<pre class="brush: js">// NICHT NACHMACHEN

// gibt "foo string" aus
(function(){ var undefined = 'foo'; console.log(undefined, typeof undefined); })();

// gibt "foo string" aus
(function(undefined){ console.log(undefined, typeof undefined); })('foo');
</pre>
</div>

<h2 id="Beispiele">Beispiele</h2>

<h3 id="Identität_und_undefined">Identität und <code>undefined</code></h3>

<p>Man kann <code>undefined</code> in Verbindung mit dem strikten Gleichheitsoperator nutzen, um den Wert von Variablen auf <code>undefined</code> zu prüfen. Im folgenden Beispiel ist die Variable <code>x</code> nicht definiert und die if-Anweisung wird zu <code>true</code> ausgewertet.</p>

<pre class="brush: js">var x;
if (x === undefined) {
   // Diese Anweisung wird ausgeführt
}
else {
   // Diese Anweisung wird nicht ausgeführt
}
</pre>

<div class="note">Hinweis: Der strikte Gleichheitsoperator muss statt dem Standard-Gleichheitsoperator benutzt werden, weil <code>x == undefined</code> auch prüft, ob <code>x</code> <code>null</code> ist, was bei strikter Gleichheit nicht so ist. <code>null</code> ist nicht äquivalent zu <code>undefined</code> Für Details siehe {{jsxref("Operators/Comparison_Operators", "Vergleichsoperatoren")}}</div>

<h3 id="Typeof_Operator_und_undefined"><code>Typeof</code> Operator und <code>undefined</code></h3>

<p>Alternativ kann {{jsxref("Operators/typeof", "typeof")}} eingesetzt werden:</p>

<pre class="brush: js">var x;
if (typeof x === 'undefined') {
   // Diese Anweisung wird ausgeführt
}
</pre>

<p>Ein Grund {{jsxref("Operators/typeof", "typeof")}} zu nutzen, ist, dass diese Variante keinen Fehler erzeugt, wenn eine Variable nicht definiert ist.</p>

<pre class="brush: js">// x wurde nicht definiert
if (typeof x === 'undefined') { // wird ohne Fehler zu true ausgewertet
   // Diese Anweisung wird ausgeführt
}

if(x === undefined){ // erzeugt einen ReferenceError

}
</pre>

<p>Diese Technik sollte so oft es geht vermieden werden. JavaScript ist eine Sprache mit statischen Gültigkeitsbereichen, was bedeutet, dass eine Variable immer in seinem geschlossenen Kontext gelesen werden kann, egal ob sie <span>existiert </span> oder nicht. Die einzige Ausnahme ist der globale Gültigkeitsbereich, jedoch ist dieser an das <em>globale Objekt</em> gebunden, weshalb die Existenz einer Variablen auf dem <em>globalen Objekt</em> geprüft werden kann. Dafür kann der {{jsxref("Operators/in", "in")}}-Operator genutzt werden.</p>

<h3 id="Void_Operator_und_undefined"><code>Void</code> Operator und <code>undefined</code></h3>

<p>Der {{jsxref("Operators/void", "void")}}-Operator ist die dritte Alternative.</p>

<pre class="brush: js">var x;
if (x === void 0) {
   // Diese Anweisung wird ausgeführt
}

// y wurde nicht definiert
if (y === void 0) {
   // erzeugt einen ReferenceError (im gegensatz zu `typeof`)
}
</pre>

<h2 id="Spezifikationen">Spezifikationen</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Spezifikation</th>
   <th scope="col">Status</th>
   <th scope="col">Kommentar</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1', '#sec-4.3.9', 'undefined')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Initiale Definition. Implementiert in JavaScript 1.3</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-15.1.1.3', 'undefined')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td> </td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-undefined', 'undefined')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td> </td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-undefined', 'undefined')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td> </td>
  </tr>
 </tbody>
</table>

<h2 id="Browserkompatibilität">Browserkompatibilität</h2>



<p>{{Compat("javascript.builtins.undefined")}}</p>
