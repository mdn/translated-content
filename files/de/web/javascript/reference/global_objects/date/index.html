---
title: Date
slug: Web/JavaScript/Reference/Global_Objects/Date
tags:
  - Date
  - JavaScript
translation_of: Web/JavaScript/Reference/Global_Objects/Date
---
<p>{{JSRef}}</p>

<p>Erstellt eine JavaScript Date Instanz, die einen einzelnen Moment der Zeit repräsentiert. Date Objekte basieren auf dem Zeitwert, der der Anzahl der Millisekunden seit dem 1. Januar 1970 (UTC) entspricht.</p>

<p>{{EmbedInteractiveExample("pages/js/date-constructor.html")}}</p>

<p>The source for this interactive example is stored in a GitHub repository. If you'd like to contribute to the interactive examples project, please clone <a href="https://github.com/mdn/interactive-examples">https://github.com/mdn/interactive-examples</a> and send us a pull request.</p>

<h2 id="Syntax">Syntax</h2>

<pre>new Date();
new Date(<var>value</var>);
new Date(<var>dateString</var>);
new Date(<var>year</var>, <var>monthIndex</var> [, <var>day</var> [, <var>hour </var>[, <var>minutes </var>[, <var>seconds</var> [, <var>milliseconds</var>]]]]]);
</pre>

<p><strong>Anmerkung:</strong> Ein JavaScript <code>Date</code> Objekt kann nur instanziiert werden, wenn JavaScript Date als ein Konstruktor aufgerufen wird: Beim Aufrufen als reguläre Funktion (z. B. ohne den {{jsxref("Operators/new", "new")}} Operator) gibt die Funktion einen String zurück und kein <code>Date</code> Objekt. Anders als andere JavaScript-Datentypen hat das <code>Date</code> Objekt keine Literalsyntax.</p>

<h3 id="Parameter">Parameter</h3>

<p><strong>Anmerkung:</strong> Das Argument <code>monthIndex</code> ist 0-basiert. Das bedeutet, dass <code>0 = Januar</code> und <code>11 = Dezember</code> ist.</p>

<p><strong>Anmerkung: </strong>Wenn <code>Date</code> als Konstruktor mit mehr als einem Argument aufgerufen wird und die übergebenen Werte größer als ihr logischer Bereich sind (z. B. 13 wird als Monat genutzt oder 70 wird als Minutenwert eingesetzt) wird der angrenzende Wert angepasst. Z. B. ist <code>new Date(2013, 13, 1)</code> äquivalent zu <code>new Date(2014, 1, 1</code>. Beide Ausdrücke erstellen das Datum <code>2014-02-01</code> (Monate fangen bei 0 an). Das gleiche gilt für folgende Werte: <code>new Date(2013, 2, 1, 0, 70)</code> ist äquivalent zu <code>new Date(2013, 2, 1, 1, 10)</code>, was beides den Zeitpunkt <code>2013-03-01T01:10:00</code> erzeugt.</p>

<p><strong>Anmerkung:</strong> Wenn <code>Date</code> als Konstruktor mit mehr als einem Argumenten aufgerufen wird, werden die Argumente als Ortszeiten interpretiert. Wenn die Weltzeit genutzt werden soll, muss <code>new Date({{jsxref("Date.UTC()", "Date.UTC(...)")}})</code> mit den gleichen Argumenten genutzt werden.</p>

<dl>
 <dt><code>value</code></dt>
 <dd>Ganze Zahl, die die Anzahl der Millisekunden seit dem 1. Januar 1970 00:00:00 UTC (Unixzeit) repräsentiert.</dd>
</dl>

<dl>
 <dt><code>dateString</code></dt>
 <dd>String der ein Datum repräsentiert. Der String muss in einem Format vorliegen, der von der {{jsxref("Date.parse()")}} Methode eingelesen werden kann (<a class="external" href="http://tools.ietf.org/html/rfc2822#page-14">IETF-compliant RFC 2822 Zeitstempel</a> und auch eine <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15">Version von ISO8601</a>).
 <p><strong>Anmerkung:</strong> Von dem Einlesen eines Zeitstempel-Strings durch den <code>Date</code> Konstruktor (und <code>Date.parse</code>, denn diese Funktion ist äquivalent) wird stark abgeraten, wegen der Unterschiede in den Browsern und Inkonsistenzen. Die Unterstützung für RFC 2822 formatierte Strings ist nur eine Konvention. Unterstützung für ISO 8601 formatierte Strings unterscheidet sich in den Strings mit nur einem Datum (z. B. "1970-01-01") werden nur als UTC behandelt und nicht als lokales Daten.</p>
 </dd>
</dl>

<dl>
 <dt><code>year</code></dt>
 <dd>Ganze Zahl, die die Jahre repräsentiert. Werte von 0 bis 99 werden zu den Jahren 1900 bis 1999 umgewandelt. Siehe das  <a href="#zwei_ziffrige_zahlen_für_die_jahre_1900_-_1999">Beispiel unten</a>.</dd>
</dl>

<dl>
 <dt><code>monthIndex</code></dt>
 <dd>Ganze Zahl, die den Monat repräsentiert. Die Zahl beginnt bei 0 für Januar und endet bei 11 für Dezember.</dd>
</dl>

<dl>
 <dt><code>day</code></dt>
 <dd>Ganze Zahl, die den Tag des Monats repräsentiert.</dd>
</dl>

<dl>
 <dt><code>hour</code></dt>
 <dd>Ganze Zahl, die die Stunde des Tages repräsentiert.</dd>
</dl>

<dl>
 <dt><code>minute</code></dt>
 <dd>Ganze Zahl, die die Minuten einer Stunde repräsentiert.</dd>
</dl>

<dl>
 <dt><code>second</code></dt>
 <dd>Ganze Zahl, die die Sekunden einer Minute repräsentiert.</dd>
</dl>

<dl>
 <dt><code>millisecond</code></dt>
 <dd>Ganze Zahl, die die Millisekunden einer Sekunde repräsentiert.</dd>
</dl>

<h2 id="Beschreibung">Beschreibung</h2>

<ul>
 <li>Wenn keine Argumente übergeben werden, erstellt der Konstruktor ein <code>Date</code> Objekt mit dem aktuellen Datum und der aktuellen Zeit der Systemzeitzone.</li>
 <li>Wenn mindestens zwei Argumente übergeben werden, werden fehlende Argumente auf 1 gesetzt (wenn day fehlt) oder auf 0 gesetzt (für alle anderen Fälle).</li>
 <li>Das JavaScript Datum basiert auf einem Zeitwert, der die Millisekunden seit Mitternacht am 1. Januar 1970 UTC beinhaltet. Ein Tag hat 86.400.000 Millisekunden. Der Bereich des JavaScript Datums-Objektes  ist von -100.000.000 Tagen bis 100.000.000 Tagen relativ zum 1. Januar 1970 UTC.</li>
 <li>Das JavaScript <code>Date</code> Objekt unterstützt ein einheitliches plattformübergreifendes Format. Der Zeitwert kann zwischen Systemen ausgetauscht werden, um den gleichen Moment der Zeit zu repräsentieren. Wenn es zum Erstellen eines lokalen <code>date</code> Objektes genutzt wird, wird es die lokale äquivalente Zeit benutzen.</li>
 <li>Das JavaScript <code>Date</code> Objekt unterstützt eine Nummer der UTC (universal) Methode genauso wie eine lokale Zeit Methode. UTC ist auch bekannt als Greenwich-Zeit (GTM), welches die Standardweltzeit ist. Die lokale Zeit ist die Zeit des Computers, auf dem JavaScript ausgeführt wird.</li>
 <li>Das Aufrufen der JavaScript <code>Date</code> Funktion (z. B. ohne den {{jsxref("Operators/new", "new")}} Operator) gibt einen String, der das aktuelle Datum und die aktuelle Zeit repräsentiert, zurück.</li>
</ul>

<h2 id="Eigenschaften">Eigenschaften</h2>

<dl>
 <dt>{{jsxref("Date.prototype")}}</dt>
 <dd>Erlaubt das Hinzufügen von Eigenschaften zum JavaScript <code>Date</code> Objekt.</dd>
 <dt>Date.length</dt>
 <dd>Der Wert von <code>Date.length</code> ist 7. Dieser ist die Anzahl der Argumente, die vom Konstruktor gehändelt werden.</dd>
</dl>

<h2 id="Methoden">Methoden</h2>

<dl>
 <dt>{{jsxref("Date.now()")}}</dt>
 <dd>Gibt den nummerischen Wert der aktuellen Zeit an - die Anzahl der Millisekunden die seit dem 1. Januar 1970 00:00:00 UTC vergangen sind.</dd>
 <dt>{{jsxref("Date.parse()")}}</dt>
 <dd>Analysiert eine String-Repräsentation eines Datums und gibt die Anzahl der Millisekunden seit dem 1. Januar 1970 00:00:00 UTC zurück.
 <p><strong>Anmerkung:</strong> Von der Nutzung der <code>Date.parse</code> Methode wird stark abgeraten wegen der Unterschiede und Widersprüche in verschiedenen Browsern.</p>
 </dd>
 <dt>{{jsxref("Date.UTC()")}}</dt>
 <dd>Akzeptiert die gleichen Parameter wie die längste Form des Konstruktors (z. B. 2 bis 7) und gibt die Anzahl der Millisekunden seit dem 1. Januar 1970 00:00:00 UTC zurück.</dd>
</dl>

<h2 id="JavaScript_Date_Instanzen">JavaScript <code>Date</code> Instanzen</h2>

<p>Alle <code>Date</code> Instanzen erben von {{jsxref("Date.prototype")}}. Das Prototype Objekt des <code>Date</code> Konstruktors kann modifiziert werden, um alle <code>Date</code> Instanzen zu ändern.</p>

<h3 id="Methoden_2">Methoden</h3>

<p>{{ page("/de/docs/Web/JavaScript/Reference/Global_Objects/Date/prototype", "Methoden") }}</p>

<h2 id="Beispiele">Beispiele</h2>

<h3 id="Verschiedene_Wege_ein_Date_Objekt_zu_erstellen">Verschiedene Wege ein Date Objekt zu erstellen</h3>

<p>Das folgende Beispiel zeigt verschiedene Wege, um JavaScript {{jsxref("Date")}} Objekte zu erstellen:</p>

<p><strong>Anmerkung:</strong> Von der Nutzung des <code>Date</code> Konstruktors mit einem String-Argument (und der <code>Date.parse</code> Methode) wird wegen der Unterschiede und Widersprüche in verschiedenen Browsern abgeraten.</p>

<pre>var today = new Date();
var birthday = new Date("December 17, 1995 03:24:00");
var birthday = new Date("1995-12-17T03:24:00");
var birthday = new Date(1995,11,17);
var birthday = new Date(1995,11,17,3,24,0);
</pre>

<h3 id="Zwei_ziffrige_Zahlen_für_die_Jahre_1900_-_1999">Zwei ziffrige Zahlen für die Jahre 1900 - 1999</h3>

<p>Um Daten in den Jahren 0 bis 99 zu erzeugen und abzufragen, müssen die Methoden {{jsxref("Date.prototype.setFullYear()")}} und {{jsxref("Date.prototype.getFullYear()")}} eingesetzt werden.</p>

<pre>var date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)

// Deprecated Methode, 98 wird hier zu 1998
date.setYear(98);           // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)

date.setFullYear(98);       // Sat Feb 01 0098 00:00:00 GMT+0000 (BST)</pre>

<h3 id="Berechnen_von_vergangener_Zeit">Berechnen von vergangener Zeit</h3>

<p>Die folgenden Beispiele zeigen, wie man die vergangene Zeit zwischen zwei JavaScript <code>date</code>s in Millisekunden berechnet.</p>

<p>Durch die unterschiedlichen Längen von Tagen (wegen der Sommer/Winter Zeitumstellung), Monaten und Jahren gibt es bei Zeiteinheiten größer als Stunden, Minuten und Sekunden eine Reihe von Problemen, die vorher recherchiert und abgeprüft werden sollten.</p>

<pre>// Einsatz Date Objekts
var start = Date.now();

// Event was einige Zeit braucht:
doSomethingForALongTime();
var end = Date.now();
var elapsed = end - start; // elapsed time in milliseconds
</pre>

<pre>// Einsatz Eingebauter Methoden
var start = new Date();

// Event was einige Zeit braucht:
doSomethingForALongTime();
var end = new Date();
var elapsed = end.getTime() - start.getTime(); // elapsed time in milliseconds
</pre>

<pre>// Testen einer funktion und Rückgabe des Rückgabewertes
function printElapsedTime (fTest) {
	var nStartTime = Date.now(),
            vReturn = fTest(),
            nEndTime = Date.now();

	alert("Elapsed time: " + String(nEndTime - nStartTime) + " milliseconds");
	return vReturn;
}

yourFunctionReturn = printElapsedTime(yourFunction);
</pre>

<p><strong>Anmerkung:</strong> In Browsern, die die hochauflösende Zeitfunktionen von der {{domxref("window.performance", "Web Performance API", "", 1)}} unterstützen, kann {{domxref("Performance.now()")}} bessere und präzisere Messergebnisse liefern als {{jsxref("Date.now()")}}.</p>

<h3 id="Die_Anzahl_der_Sekunden_seit_der_Unix_Epoche_ermitteln">Die Anzahl der Sekunden seit der Unix Epoche ermitteln</h3>

<pre>var seconds = Math.floor(Date.now() / 1000);</pre>

<p>In diesem Fall ist es wichtig, nur eine ganze Zahl zurückzugeben (eine einfache Division würde nicht reichen) und auch nur tatsächlich verstrichene Sekunden zurückzugeben (deswegen nutzt der Quelltext die {{jsxref("Math.floor()")}} Funktion und nicht die {{jsxref("Math.round()")}} Funktion).</p>

<h2 id="Spezifikationen">Spezifikationen</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Spezifikation</th>
   <th scope="col">Status</th>
   <th scope="col">Kommentar</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Initiale Definition. Implementiert in JavaScript 1.1.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-15.9', 'Date')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td></td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-date-objects', 'Date')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td></td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-date-objects', 'Date')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="Browserkompatibilität">Browserkompatibilität</h2>

<p>The compatibility table in this page is generated from structured data. If you'd like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</p>

<p>{{Compat("javascript.builtins.Date")}}</p>
