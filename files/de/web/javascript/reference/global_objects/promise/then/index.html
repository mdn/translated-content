---
title: Promise.prototype.then()
slug: Web/JavaScript/Reference/Global_Objects/Promise/then
translation_of: Web/JavaScript/Reference/Global_Objects/Promise/then
---
<div>{{JSRef}}</div>

<div>Die <strong>then()</strong>-Methode gibt ein <code>Promise</code>-Objekt zurück. Sie benötigt zwei Argumente, jeweils eine Callback-Funktion für den Erfolg und den Fehlschlag des <code>Promise</code>.</div>

<div> </div>

<h2 id="Syntax">Syntax</h2>

<pre class="syntaxbox"><var>p.then(onFulfilled, onRejected)</var>;

p.then(function(value) {
   // fulfillment
  }, function(reason) {
  // rejection
});
</pre>

<h3 id="Parameter">Parameter</h3>

<dl>
 <dt>onFulfilled</dt>
 <dd>Eine {{jsxref("Function")}}, welche aufgerufen wird, wenn der <code>Promise</code> erfüllt wurde. Die Funktion hat ein Argument, den Rückgabewert <code>value</code>.</dd>
 <dt>onRejected {{optional_inline}}</dt>
 <dd>Eine {{jsxref("Function")}}, welche aufgerufen wird, wenn der <code>Promise</code> fehlschlägt. Die Funktion hat ein Argument, den Grund für den Fehlschlag: <code>reason</code>. Ist keine Funktion definiert, so wird sie intern durch die "Thrower" Funktion ersetzt (Dieser gibt einen Fehler als Argument zurück)</dd>
</dl>

<h2 id="Beschreibung">Beschreibung</h2>

<p>Die <code>then</code>- und {{jsxref("Promise.prototype.catch()")}}-Methoden, können, da sie Promises zurückgeben<font face="Consolas, Liberation Mono, Courier, monospace">, verkettetet werden </font>— ein Vorgehen, das <em>composition</em> genannt wird.</p>

<h2 id="Beispiele">Beispiele</h2>

<h3 id="Benutzen_der_then-Methode">Benutzen der <code>then</code>-Methode</h3>

<pre class="brush: js">var p1 = new Promise(function(resolve, reject) {
  resolve("Success!");
  // or
  // reject ("Error!");
});

p1.then(function(value) {
  console.log(value); // Success!
}, function(reason) {
  console.log(reason); // Error!
});
</pre>

<h3 id="Verketten">Verketten</h3>

<p>Da die <code>then</code>-Methode einen <code>Promise</code> zurückliefert, können <code>then</code>-Aufrufe leicht verkettet werden.</p>

<pre class="brush: js">var p2 = new Promise(function(resolve, reject) {
  resolve(1);
});

p2.then(function(value) {
  console.log(value); // 1
  return value + 1;
}).then(function(value) {
  console.log(value); // 2
});

p2.then(function(value) {
  console.log(value); // 1
});
</pre>

<h2 id="Spezifikationen">Spezifikationen</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Spezifikation</th>
   <th scope="col">Status</th>
   <th scope="col">Kommentar</th>
  </tr>
  <tr>
   <td>{{SpecName('ES2015', '#sec-promise.prototype.then', 'Promise.prototype.then')}}</td>
   <td>{{Spec2('ES2015')}}</td>
   <td>Initiale Definition in einem ECMAScript-Standard.</td>
  </tr>
 </tbody>
</table>

<h2 id="Browserkompatibilität">Browserkompatibilität</h2>

{{Compat}}

<p>[1] Gecko 24 besitzt, unter dem Namen Future, eine experimentielle Implementation von Promise. In Gecko 25 wurde der Name final festgelegt aber standardmäßig durch die Einstellung <code>dom.promise.enabled </code>deaktiviert. Durch <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=918806">Bug 918806</a> wurden Promises in Gecko 29 standardmäßig aktiviert.</p>

<h2 id="Siehe_auch">Siehe auch</h2>

<ul>
 <li>{{jsxref("Promise")}}</li>
 <li>{{jsxref("Promise.prototype.catch()")}}</li>
</ul>
