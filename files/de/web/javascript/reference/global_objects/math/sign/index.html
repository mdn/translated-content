---
title: Math.sign()
slug: Web/JavaScript/Reference/Global_Objects/Math/sign
tags:
  - JavaScript
  - Math
  - Method
  - Reference
translation_of: Web/JavaScript/Reference/Global_Objects/Math/sign
---
<div>{{JSRef}}</div>

<p>Die <strong><code>Math.sign()</code></strong> Funktion gibt das Vorzeichen einer Zahl zurück, welches angibt, ob eine Zahl positiv, negativ oder 0 ist.</p>

<div>{{EmbedInteractiveExample("pages/js/math-sign.html")}}</div>



<h2 id="Syntax">Syntax</h2>

<pre class="syntaxbox"><code>Math.sign(<var>x</var>)</code></pre>

<h3 id="Parameter">Parameter</h3>

<dl>
 <dt><code>x</code></dt>
 <dd>Eine Zahl.</dd>
</dl>

<h3 id="Rückgabewert">Rückgabewert</h3>

<p>Eine Zahl, die das Vorzeichen des übergebenen Wertes repräsentiert. Wenn der Parameter eine positive Zahl ist, eine negative Zahl ist oder eine Null (0) ist, wird die Funktion <code>1</code>, <code>-1</code>, <code>0</code> oder <code>-0</code> zurückgeben. Andernfalls wird {{jsxref("NaN")}} zurückgegeben.</p>

<h2 id="Beschreibung">Beschreibung</h2>

<p>Weil <code>sign()</code> eine statische Funktion von <code>Math</code> ist, wird sie immer als <code>Math.sign()</code> eingesetzt, jedoch nicht als Methode eines erzeugten <code>Math</code> Objektes (<code>Math</code> ist kein Konstruktor).</p>

<p>Diese Funktion hat die 5 möglichen Rückgabewerte <code>1</code>, <code>-1</code>, <code>0</code>, <code>-0</code> und <code>NaN</code>, welche "positive Zahlen", "negative Zahlen", "positiv 0", "negativ 0" und {{jsxref("NaN")}} repräsentieren.</p>

<p>Der Übergebeparameter dieser Funktion wird implizit zu einem <code>number</code>-Type konvertiert.</p>

<h2 id="Beispiele">Beispiele</h2>

<h3 id="Einsatz_von_Math.sign()">Einsatz von <code>Math.sign()</code></h3>

<pre class="brush: js">Math.sign(3);     //  1
Math.sign(-3);    // -1
Math.sign('-3');  // -1
Math.sign(0);     //  0
Math.sign(-0);    // -0
Math.sign(NaN);   // NaN
Math.sign('foo'); // NaN
Math.sign();      // NaN
</pre>

<h2 id="Polyfill">Polyfill</h2>

<pre class="brush: js line-numbers  language-js"><code class="language-js"><span class="keyword token">if</span> <span class="punctuation token">(</span><span class="operator token">!</span>Math<span class="punctuation token">.</span>sign<span class="punctuation token">)</span> <span class="punctuation token">{</span>
  Math<span class="punctuation token">.</span>sign <span class="operator token">=</span> <span class="keyword token">function</span><span class="punctuation token">(</span>x<span class="punctuation token">)</span> <span class="punctuation token">{</span>
    <span class="comment token">// If x is NaN, the result is NaN.</span>
    <span class="comment token">// If x is -0, the result is -0.</span>
    <span class="comment token">// If x is +0, the result is +0.</span>
    <span class="comment token">// If x is negative and not -0, the result is -1.</span>
    <span class="comment token">// If x is positive and not +0, the result is +1.</span>
    <span class="keyword token">return</span> <span class="punctuation token">(</span><span class="punctuation token">(</span>x <span class="operator token">&gt;</span> <span class="number token">0</span><span class="punctuation token">)</span> <span class="operator token">-</span> <span class="punctuation token">(</span>x <span class="operator token">&lt;</span> <span class="number token">0</span><span class="punctuation token">)</span><span class="punctuation token">)</span> <span class="operator token">||</span> <span class="operator token">+</span>x<span class="punctuation token">;</span>
    <span class="comment token">// A more aesthetical persuado-representation is shown below</span>
    <span class="comment token">//</span>
    <span class="comment token">// ( (x &gt; 0) ? 0 : 1 )  // if x is negative then negative one</span>
    <span class="comment token">//          +           // else (because you cant be both - and +)</span>
    <span class="comment token">// ( (x &lt; 0) ? 0 : -1 ) // if x is positive then positive one</span>
    <span class="comment token">//         ||           // if x is 0, -0, or NaN, or not a number,</span>
    <span class="comment token">//         +x           // Then the result will be x, (or) if x is</span>
    <span class="comment token">//                      // not a number, then x converts to number</span>
  <span class="punctuation token">}</span><span class="punctuation token">;</span>
<span class="punctuation token">}</span></code></pre>

<p>In diesem Polyfill ist keine weitere Typumwandlung nötig, um aus <code>(x &gt; 0)</code> oder <code>(x &lt; 0)</code> Zahlen zu machen, weil das Subtrahieren voneinander eine Typkonvertierung von boolean zu Zahlen erzwingt.</p>

<h2 id="Spezifikationen">Spezifikationen</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Spezifikation</th>
   <th scope="col">Status</th>
   <th scope="col">Comment</th>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-math.sign', 'Math.sign')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td>Initiale Definition.</td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-math.sign', 'Math.sign')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td> </td>
  </tr>
 </tbody>
</table>

<h2 id="Browserkompatibilität">Browserkompatibilität</h2>

<p>{{Compat("javascript.builtins.Math.sign")}}</p>

<h2 id="Siehe_auch">Siehe auch</h2>

<ul>
 <li>{{jsxref("Math.abs()")}}</li>
 <li>{{jsxref("Math.ceil()")}}</li>
 <li>{{jsxref("Math.floor()")}}</li>
 <li>{{jsxref("Math.round()")}}</li>
 <li>{{jsxref("Math.trunc()")}}</li>
</ul>
