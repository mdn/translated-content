---
title: Error
slug: Web/JavaScript/Reference/Global_Objects/Error
tags:
  - Error
  - JavaScript
  - Reference
translation_of: Web/JavaScript/Reference/Global_Objects/Error
---
<div>{{JSRef}}</div>

<p>Der <strong><code>Error</code></strong> Konstruktor erstellt ein Fehler (Error) Objekt. Instanzen von <code>Error</code> Objekten werden geworfen (thrown), wenn zur Laufzeit ein Fehler auftritt. Das <code>Error</code> Objekt kann zudem als Basis für benutzerdefinierte Fehler benutzt werden. Weiter unten werden schon eingebaute Fehlertypen beschrieben.</p>

<h2 id="Syntax">Syntax</h2>

<pre class="syntaxbox">new Error([<var>message</var>[, <var>fileName</var>[, <var>lineNumber</var>]]])</pre>

<h3 id="Parameter">Parameter</h3>

<dl>
 <dt><code>message</code></dt>
 <dd>Optional. Für Menschen lesbare Beschreibung des Errors.</dd>
 <dt><code>fileName</code> {{non-standard_inline}}</dt>
 <dd>Optional. Der Wert für die <code>fileName</code> Eigenschaft eines erstellten <code>Error</code> Objekts. Der Standardwert ist der Name der Datei, in dem der Quelltext <code>Error()</code> aufgerufen wird.</dd>
 <dt><code>lineNumber</code> {{non-standard_inline}}</dt>
 <dd>Optional. Der Wert für die <code>lineNumber</code> Eigenschaft eines erstellten <code>Error</code> Objekts. Der Standardwert ist die Zeilennummer, in dem der Quelltext <code>Error()</code> aufgerufen wird.</dd>
</dl>

<h2 id="Beschreibung">Beschreibung</h2>

<p>Laufzeitfehler resultieren in einem neu erstellten und geworfenen <code>Error</code> Objekt.</p>

<p>Diese Seite Dokumentiert den Einsatz des <code>Error</code> Objektes und den Einsatz als Konstruktorfunktion. Für eine Liste der Eigenschaften und Methoden, die eine <code>Error</code> Instanz erbt, siehe auf der Seite {{jsxref("Error.prototype")}}.</p>

<h3 id="Einsatz_als_Funktion">Einsatz als Funktion</h3>

<p>Wenn <code>Error</code> als Funktion genutzt wird -- ohne <code>new</code>, wird diese ein <code>Error</code> Objekt zurückgeben. Daher wird der Aufruf der Funktion das gleiche zurückgeben wie der Aufruf des <code>Error</code> Konstruktors (mit <code>new</code> Schlüsselwort).</p>

<pre class="brush: js">// dieser Aufruf:
const x = Error('Ich wurde mit einem Funktionsaufruf erstellt!');
​​​​// hat die gleiche Funktion wie folgender:
const y = new Error('Ich wurde mit dem "new" Schlüsselwort erstellt!');</pre>

<h3 id="Fehlertypen">Fehlertypen</h3>

<p>Neben dem generischen <code>Error</code> Konstruktor sind in JavaScript noch sieben weitere Error-Konstruktoren eingebaut. Für benutzerdefinierte Fehler siehe <a href="/de/docs/Web/JavaScript/Guide/Statements#Statements_zur_Fehler-_bzw._Ausnahmebehandlung">Statements zur Fehler- und Ausnahmebehandlung</a>.</p>

<dl>
 <dt>{{jsxref("EvalError")}}</dt>
 <dd>Erstellt eine Instanz, die einen Fehler repräsentiert, der bei der globalen {{jsxref("Global_Objects/eval", "eval()")}} Funktion auftritt.</dd>
 <dt>{{jsxref("InternalError")}} {{non-standard_inline}}</dt>
 <dd>Erstellt eine Instanz, die einen Fehler repräsentiert, der auftritt, wenn ein interner Fehler in JavaScript auftaucht (z. B. zu viel Rekursion).</dd>
 <dt>{{jsxref("RangeError")}}</dt>
 <dd>Erstellt eine Instanz, die einen Fehler repräsentiert, der auftritt, wenn eine nummerische Variable oder ein nummerischer Parameter außerhalb seiner validen Grenzen ist.</dd>
 <dt>{{jsxref("ReferenceError")}}</dt>
 <dd>Erstellt eine Instanz, die einen Fehler repräsentiert, der auftritt, wenn eine nicht valide Referenz referenziert werden soll.</dd>
 <dt>{{jsxref("SyntaxError")}}</dt>
 <dd>Erstellt eine Instanz, die einen Fehler repräsentiert, der auftritt, wenn die Syntax von  Quellcode, der in der {{jsxref("Global_Objects/eval", "eval()")}} Funktion übergeben wird, nicht richtig ist.</dd>
 <dt>{{jsxref("TypeError")}}</dt>
 <dd>Erstellt eine Instanz, die einen Fehler repräsentiert, der auftritt, wenn eine Variable oder ein Parameter einen nicht validen Typen enthält.</dd>
 <dt>{{jsxref("URIError")}}</dt>
 <dd>Erstellt ein Instanz, die einen Fehler repräsentiert, der auftritt, wenn die Methode {{jsxref("Global_Objects/encodeURI", "encodeURI()")}} oder {{jsxref("Global_Objects/decodeURI", "decodeURI()")}} nicht valide Parameter übergeben bekommt.</dd>
</dl>

<h2 id="Eigenschaften">Eigenschaften</h2>

<dl>
 <dt>{{jsxref("Error.prototype")}}</dt>
 <dd>Erlaubt es die Eigenschaften aller <code>Error</code> Instanzen zu verändern.</dd>
</dl>

<h2 id="Methoden">Methoden</h2>

<p>Das globale <code>Error</code> Objekt besitzt keine eigenen Methoden. Stattdessen erbt es einige Methoden durch die Prototypenkette.</p>

<h2 id="Error_Instanzen">Error Instanzen</h2>

<div>{{page('/de/docs/Web/JavaScript/Reference/Global_Objects/Error/prototype', 'Beschreibung')}}</div>

<h3 id="Eigenschaften_2">Eigenschaften</h3>

<div>{{page('/de/docs/Web/JavaScript/Reference/Global_Objects/Error/prototype', 'Eigenschaften')}}</div>

<h3 id="Methoden_2">Methoden</h3>

<div>{{page('/de/docs/Web/JavaScript/Reference/Global_Objects/Error/prototype', 'Methoden')}}</div>

<h2 id="Beispiele">Beispiele</h2>

<h3 id="Werfen_eines_generischen_Errors">Werfen eines generischen Errors</h3>

<p>Typischerweise erstellt man ein <code>Error</code> Objekt mit der Intention es mit dem {{jsxref("Statements/throw", "throw")}} Schlüsselwort zu werfen. Man kann den Fehler auffangen, indem man ein {{jsxref("Statements/try...catch", "try...catch")}} Konstrukt benutzt.</p>

<pre class="brush: js">try {
  throw new Error('Whoops!');
} catch (e) {
  console.log(e.name + ': ' + e.message);
}
</pre>

<h3 id="Einen_Spezifischen_Error_behandeln">Einen Spezifischen Error behandeln</h3>

<p>Man kann sich aussuchen, welche spezifischen Fehlertypen behandelt werden sollen, indem man die {{jsxref("Object.prototype.constructor", "constructor")}} Eigenschaft des Errors abfragt. In modernen JavaScript-Umgebungen kann stattdessen das {{jsxref("Operators/instanceof", "instanceof")}} Schlüsselwort verwendet werden:</p>

<pre class="brush: js">try {
  foo.bar();
} catch (e) {
  if (e instanceof EvalError) {
    console.log(e.name + ': ' + e.message);
  } else if (e instanceof RangeError) {
    console.log(e.name + ': ' + e.message);
  }
  // ... etc
}
</pre>

<h3 id="Benutzerdefinierte_Fehlertypen">Benutzerdefinierte Fehlertypen</h3>

<p>Manchmal möchte man aber einen eigenen Error erstellen, der von <code>Error</code> abgeleitet ist, durch den Aufruf <code>throw new CustomError()</code>  geworfen werden kann und durch <code>instanceof CustomError</code> abgefragt werden kann. Eigene Fehlertypen führen zu einer besseren und konsistenten Fehlerbehandlung. Für eine tiefer gehende Diskussion schaue bitte auf <a href="https://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript">Stack Overflow</a> nach.</p>

<h4 id="ES6_benutzerdefinierte_Error_Klasse">ES6 benutzerdefinierte Error Klasse</h4>

<div class="warning">
<p>Babel und andere Transpiler werden den folgenden Quelltext nicht ohne <a href="https://github.com/loganfsmyth/babel-plugin-transform-builtin-extend">zusätzliche Konfigurationen</a> verarbeiten können.</p>
</div>

<div class="note">
<p>Einige Browser enthalten den CustomError Konstruktor im Stack Trace, wenn ES2015 Klassen eingesetzt werden</p>
</div>

<pre class="brush: js">class CustomError extends Error {
  constructor(foo = 'bar', ...params) {
    // Übergibt die verbleibenden Parameter (einschließlich Vendor spezifischer Parameter) dem Error Konstruktor
    super(...params);

    // Behält den richtigen Stack-Trace für die Stelle bei, an der unser Fehler ausgelöst wurde (nur bei V8 verfügbar)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CustomError);
    }

    // Benutzerdefinierte Debugging Informationen
    this.foo = foo;
    this.date = new Date();
  }
}

try {
  throw new CustomError('buz', 'buzMessage');
} catch(e){
  console.log(e.foo);     // baz
  console.log(e.message); // bazMessage
  console.log(e.stack);   // stacktrace
}</pre>

<h4 id="ES5_benutzerdefiniertes_Error_Objekt">ES5 benutzerdefiniertes Error Objekt</h4>

<div class="warning">
<p><strong>Alle</strong> Browser enthalten den CustomError Konstruktor im Stack Trace, wenn eine Prototypische Deklaration verwendet wird.</p>
</div>

<pre class="brush: js">function CustomError(foo, message, fileName, lineNumber) {
  var instance = new Error(message, fileName, lineNumber);
  instance.foo = foo;
  Object.setPropertyOf(instance, Object.getPrototypeOf(this));
  if(Error.captureStackTrace) {
    Error.captureStackTrace(instance, CustomError);
  }
  return instance;
}

CustomError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: Error,
    enumerable: false,
    writable: true,
    configurable: true
  }
});

if(typeof Object.setPropertyOf != 'undefined') {
  Object.setPrototypeOf(CustomError, Error);
} else {
  CustomError.__proto__ = Error;
}


try {
  throw new CustomError('baz', 'bazMessage');
} catch (e) {
  console.log(e.foo);      // 'baz'
  console.log(e.message);  // 'bazMessage'
}
</pre>

<h2 id="Spezifikationen">Spezifikationen</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Spezifikation</th>
   <th scope="col">Status</th>
   <th scope="col">Kommentar</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Initiale Definition. Implementiert in JavaScript 1.1.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-15.11', 'Error')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td> </td>
  </tr>
  <tr>
   <td>{{SpecName('ES2015', '#sec-error-objects', 'Error')}}</td>
   <td>{{Spec2('ES2015')}}</td>
   <td> </td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-error-objects', 'Error')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td> </td>
  </tr>
 </tbody>
</table>

<h2 id="Browserkompatibilität">Browserkompatibilität</h2>

<div>


<p>{{Compat("javascript.builtins.Error")}}</p>
</div>

<h2 id="Siehe_auch">Siehe auch</h2>

<ul>
 <li>{{jsxref("Error.prototype")}}</li>
 <li>{{jsxref("Statements/throw", "throw")}}</li>
 <li>{{jsxref("Statements/try...catch", "try...catch")}}</li>
</ul>
