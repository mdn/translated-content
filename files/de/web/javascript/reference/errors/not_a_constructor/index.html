---
title: 'TypeError: "x" is not a constructor'
slug: Web/JavaScript/Reference/Errors/Not_a_constructor
tags:
  - Fehler
  - JavaScript
  - TypeError
translation_of: Web/JavaScript/Reference/Errors/Not_a_constructor
original_slug: Web/JavaScript/Reference/Fehler/Not_a_constructor
---
<div>{{jsSidebar("Errors")}}</div>

<h2 id="Fehlermeldung">Fehlermeldung</h2>

<pre class="syntaxbox">TypeError: "x" is not a constructor

TypeError: Math is not a constructor
TypeError: JSON is not a constructor
TypeError: Symbol is not a constructor
TypeError: Reflect is not a constructor
TypeError: Intl is not a constructor
TypeError: SIMD is not a constructor
TypeError: Atomics is not a constructor
</pre>

<h2 id="Fehlertyp">Fehlertyp</h2>

<p>{{jsxref("TypeError")}}</p>

<h2 id="Was_ist_falsch_gelaufen">Was ist falsch gelaufen?</h2>

<p>Es wurde versucht auf ein Objekt oder eine Variable zuzugreifen welche kein Konstruktor ist. Mehr darüber, was ein Konstruktur ist, finden Sie unter {{Glossary("constructor")}} oder in der Beschreibung des <a href="/en-US/docs/Web/JavaScript/Reference/Operators/new"><code>new</code> Operators</a>.</p>

<p>Es gibt viele globale Objekte, wie {{jsxref("String")}} oder {{jsxref("Array")}}, welche mittels <code>new</code> erstellt werden können. Jedoch funktioniert das bei einigen Objekten nicht und deren Eigenschaften und Methoden sind statisch.</p>

<p>Die folgenden Standard build-in Objekte sind keine Konstruktoren: {{jsxref("Math")}}, {{jsxref("JSON")}}, {{jsxref("Symbol")}}, {{jsxref("Reflect")}}, {{jsxref("Intl")}}, {{jsxref("SIMD")}}, {{jsxref("Atomics")}}.</p>

<p><a href="/en-US/docs/Web/JavaScript/Reference/Statements/function*">Generelle Funktionen</a> können ebenso nicht als Konstruktor verwendet werden.</p>

<h2 id="Beispiele">Beispiele</h2>

<h3 id="Ungültige_Fälle">Ungültige Fälle</h3>

<pre class="brush: js example-bad">var Car = 1;
new Car();
// TypeError: Car is not a constructor

new Math();
// TypeError: Math is not a constructor

new Symbol();
// TypeError: Symbol is not a constructor

function* f() {};
var obj = new f;
// TypeError: f is not a constructor
</pre>

<h3 id="Ein_car_Konstruktor">Ein car Konstruktor</h3>

<p>Stellen Sie sich vor, Sie erstellen ein Objekt vom Typ vars. Sie wollen dieses Objekt als <code>Car</code> bezeichen und es soll Eigenschaften für make, model und year besitzt. Um dies zu erreichen, schreiben Sie die folgende Funktion:</p>

<pre class="brush: js">function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
</pre>

<p>Jetzt können Sie wie folgt ein Objekt mit dem Namen <code>mycar</code> erstellen:</p>

<pre class="brush: js">var mycar = new Car('Eagle', 'Talon TSi', 1993);</pre>

<h3 id="Promises">Promises</h3>

<p>Bei Rückgabe eines Promises, welches sofort im Status resolved oder rejected ist, brauchen Sie kein neues Promise mit <em>new Promise(...)</em> erstellen und damit zu arbeiten. </p>

<p>Folgendes ist nicht erlaubt (der <a href="/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise#Constructor">Promise Konstruktor</a> wird nicht korrekt aufgerufen) und wirft eine <code>TypeError: this is not a constructor</code> Exception.</p>

<pre class="brush: js example-bad">return new Promise.resolve(true);
</pre>

<p>Verwenden Sie stattdessen<a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"> Promise.resolve()</a> oder die <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject">statische Methode Promise.reject()</a>:</p>

<pre class="brush: js">// Das ist erlaubt, aber unnötig lang:
return new Promise((resolve, reject) =&gt; { resolve(true); })

// Alternative Verwendung der statische Methoden:
return Promise.resolve(true);
return Promise.reject(false);
</pre>

<h2 id="Siehe_auch">Siehe auch</h2>

<ul>
 <li>{{Glossary("constructor","Konstruktor")}}</li>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Operators/new"><code>new</code> Operator</a></li>
</ul>
