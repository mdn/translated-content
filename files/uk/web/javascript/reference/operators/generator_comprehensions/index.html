---
title: Заповнення генераторів
slug: Web/JavaScript/Reference/Operators/Generator_comprehensions
tags:
  - JavaScript
  - Ітератор
  - застарілий
  - нестандартний
translation_of: Archive/Web/JavaScript/Generator_comprehensions
---
<div>{{JSSidebar("Operators")}}{{Non-standard_Header}}{{Obsolete_Header("gecko58")}}
<div class="blockIndicator warning">
<p><strong>Нестандартний. Не використовуйте!</strong><br>
 Синтаксис заповнень генераторів є нестандартним та був прибраний, починаючи з Firefox 58. Для використання в майбутньому розгляньте {{JSxRef("Statements/function*", "генератори", "", 1)}}.</p>
</div>
</div>

<p>Синтаксис <strong>заповнення генераторів </strong>(generator comprehension) був виразом JavaScript, який дозволяв швидко збирати нову функцію-генератор, базуючись на вже існуючому ітерабельному об'єкті. Однак, він був прибраний зі стандарту та з реалізації Firefox. Не використовуйте його!</p>

<h2 id="Синтаксис">Синтаксис</h2>

<pre class="syntaxbox">(for (x of iterable) x)
(for (x of iterable) if (condition) x)
(for (x of iterable) for (y of iterable) x + y)
</pre>

<h2 id="Опис">Опис</h2>

<p>У заповненнях генераторів дозволені наступні два види компонентів:</p>

<ul>
 <li>{{JSxRef("Statements/for...of", "for...of")}} та</li>
 <li>{{JSxRef("Statements/if...else", "if")}}</li>
</ul>

<p>Перебір <code>for-of</code> завжди є першим компонентом. Можна використовувати більше одного перебору <code>for-of</code> чи if-конструкцій.</p>

<p>Значним недоліком {{JSxRef("Operators/Array_comprehensions","заповнень масивів","","true")}} є те, що вони можуть спричинити конструювання у пам'яті цілого нового масиву. Коли самі вхідні дані для заповнення є маленьким масивом, затрати пам'яті є незначними — але коли вхідні дані є великим масивом, або затратним (чи взагалі нескінченним) генератором, створення нового масиву може бути проблематичним.</p>

<p>Генератори дозволяють ліниві обчислення послідовностей, з обчисленням елементів на вимогу, коли є потреба. Заповнення генераторів синтаксично майже ідентичні заповненням масивів — вони використовують круглі дужки замість квадратних — але замість створення масиву вони створюють генератор, який може виконуватися ліниво. Можете вважати їх скороченим синтаксисом для створення генераторів.</p>

<p>Припустимо, ми маємо ітератор <code>it</code>, який перебирає великі послідовності цілих чисел. Ми бажаємо створити новий ітератор, який перебиратиме їхні подвоєні значення. Заповнення масиву створило б цілий масив у пам'яті, що містив би подвоєні значення:</p>

<pre class="brush: js">var doubles = [for (i in it) i * 2];
</pre>

<p>Заповнення генератора, з іншого боку, створило б новий ітератор, який створював би подвоєні значення на вимогу, в разі потреби:</p>

<pre class="brush: js">var it2 = (for (i in it) i * 2);
console.log(it2.next()); // Перше значення з it, подвоєне
console.log(it2.next()); // Друге значення з it, подвоєне
</pre>

<p>Коли заповнення генератора використовується як аргумент функції, круглі дужки, що використовуються для виклику функції, означають, що зовнішні дужки можна пропустити:</p>

<pre class="brush: js">var result = doSomething(for (i in it) i * 2);
</pre>

<p>Значною відмінністю між цими двома прикладами є те, що, використовуючи заповнення генератора, ви перебиратимете структуру 'obj' лише один раз, всього, на відміну від одного обходу при заповненні масиву та ще одного під час його перебору.</p>

<h2 id="Приклади">Приклади</h2>

<h3 id="Прості_заповнення_генераторів">Прості заповнення генераторів</h3>

<pre class="brush:js">(for (i of [1, 2, 3]) i * i );
// функція-генератор, що видає 1, 4 та 9

[...(for (i of [1, 2, 3]) i * i )];
// [1, 4, 9]

var abc = ['А', 'Б', 'В'];
(for (letters of abc) letters.toLowerCase());
// функція-генератор, що видає "а", "б" та "в"
</pre>

<h3 id="Заповнення_генераторів_з_оператором_if">Заповнення генераторів з оператором if</h3>

<pre class="brush: js">var years = [1954, 1974, 1990, 2006, 2010, 2014];

(for (year of years) if (year &gt; 2000) year);
// функція-генератор, що видає 2006, 2010 та 2014

(for (year of years) if (year &gt; 2000) if (year &lt; 2010) year);
// функція-генератор, що видає 2006, те саме нижче:

(for (year of years) if (year &gt; 2000 &amp;&amp; year &lt; 2010) year);
// функція-генератор, що видає 2006
</pre>

<h3 id="Заповнення_генераторів_у_порівнянні_з_функцією-генератором">Заповнення генераторів у порівнянні з функцією-генератором</h3>

<p>Легко зрозуміти синтаксис заповнення генераторів, порівнявши його з функцією-генератором.</p>

<p>Приклад 1: Простий генератор.</p>

<pre class="brush: js">var numbers = [1, 2, 3];

// Функція-генератор
(function*() {
  for (let i of numbers) {
    yield i * i;
  }
})();

// Заповнення генератора
(for (i of numbers) i * i );

// Результат: Обидва повертають генератор, який видає [1, 4, 9]
</pre>

<p>Приклад 2: Використання <code>if</code> у генераторі.</p>

<pre class="brush: js">var numbers = [1, 2, 3];

// Функція-генератор
(function*() {
  for (let i of numbers) {
    if (i &lt; 3) {
      yield i * 1;
    }
  }
})();

// Заповнення генератора
(for (i of numbers) if (i &lt; 3) i);

// Результат: обидва вертають генератор, який видає [1, 2]</pre>

<h2 id="Специфікації">Специфікації</h2>

<p>Заповнення генераторів було початково присутнє у чорнетці ECMAScript 2015, але було прибране у ревізії 27 (серпень 2014). Будь-ласка, дивіться семантику специфікації у старших ревізіях ES2015.</p>

<h2 id="Сумісність_з_веб-переглядачами">Сумісність з веб-переглядачами</h2>



<p>{{Compat("javascript.operators.generator_comprehensions")}}</p>

<h2 id="Відмінності_від_заповнень_у_JS1.7JS1.8">Відмінності від заповнень у JS1.7/JS1.8</h2>

<div class="blockIndicator warning">Заповнення JS1.7/JS1.8 були прибрані з Gecko 46 ({{bug(1220564)}}).</div>

<p><strong>Старий синтаксис заповнень (більше не використовується!):</strong></p>

<pre class="brush: js example-bad">(X for (Y in Z))
(X for each (Y in Z))
(X for (Y of Z))
</pre>

<p>Відмінності:</p>

<ul>
 <li>Заповнення ES7 створюють область видимості для кожного блоку "for", а не для всього заповнення.
  <ul>
   <li>Старе: <code>[...(()=&gt;x for (x of [0, 1, 2]))][1]() // 2</code></li>
   <li>Нове: <code>[...(for (x of [0, 1, 2]) ()=&gt;x)][1]() // 1, кожна ітерація створює свіже зв'язування для x. </code></li>
  </ul>
 </li>
 <li>Заповнення ES7 починаються з "for", а не з виразу присвоювання.
  <ul>
   <li>Старе: <code>(i * 2 for (i of numbers))</code></li>
   <li>Нове: <code>(for (i of numbers) i * 2)</code></li>
  </ul>
 </li>
 <li>Заповнення ES7 можуть мати декілька компонентів <code>if</code> та <code>for</code>.</li>
 <li>Заповнення ES7 працюють тільки з переборами <code>{{JSxRef("Statements/for...of", "for...of")}}</code>, а не з <code>{{JSxRef("Statements/for...in", "for...in")}}</code>.</li>
</ul>

<h2 id="Див._також">Див. також</h2>

<ul>
 <li>{{JSxRef("Statements/for...of", "for...of")}}</li>
 <li>{{JSxRef("Operators/Array_comprehensions", "Заповнення масивів")}}</li>
</ul>
