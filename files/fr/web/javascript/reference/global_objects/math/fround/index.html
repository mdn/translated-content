---
title: Math.fround()
slug: Web/JavaScript/Reference/Global_Objects/Math/fround
tags:
  - ECMAScript6
  - JavaScript
  - Math
  - Méthode
  - Reference
translation_of: Web/JavaScript/Reference/Global_Objects/Math/fround
original_slug: Web/JavaScript/Reference/Objets_globaux/Math/fround
---
<div>{{JSRef}}</div>

<p>La fonction <code><strong>Math.fround()</strong></code> renvoie le nombre flottant à <a class="external" href="https://en.wikipedia.org/wiki/Single_precision" title="link to the wikipedia page on single precision">précision simple</a> sur 32 bits qui est le plus proche du nombre fourni.</p>

<div>{{EmbedInteractiveExample("pages/js/math-fround.html")}}</div>

<h2 id="Syntaxe">Syntaxe</h2>

<pre class="syntaxbox">Math.fround(<var>x</var>)</pre>

<h3 id="Paramètres">Paramètres</h3>

<dl>
 <dt><code>x</code></dt>
 <dd>Un nombre.</dd>
</dl>

<h3 id="Valeur_de_retour">Valeur de retour</h3>

<p>Le nombre flottant à précision simple sur 32 bits qui est le plus proche de la valeur fournie en argument.</p>

<h2 id="Description">Description</h2>

<p>Un moteur JavaScript utilise des nombres flottant à précision simple sur 64 bits. Cela permet d'obtenir une précision fine. Toutefois, lorsqu'on manipule des valeurs représentées sur 32 bits (par exemple des valeurs extraites d'un {{jsxref("Float32Array")}}) et qu'on souhaite comparer celles-ci avec des valeurs sur 32 bits, on peut obtenir des inégalités alors que les valeurs semblent identiques.</p>

<p>Pour résoudre ce problème, on peut utiliser <code>Math.fround()</code> afin de transformer un nombre représenté sur 64 bits en un nombre représenté sur 32 bits. Pour le moteur JavaScript, la valeur sera toujours représentée sur 64 bits mais elle aura été « arrondie » à partir du 23e bit de la mantisse. Si le nombre passé en argument se situe en dehors de l'intervalle représentable sur 32 bits, la méthode renverra {{jsxref("Infinity")}} ou <code>-Infinity</code>.</p>

<p><code>fround </code>étant une méthode statique de <code>Math</code>, il faut utiliser <code>Math.<code>fround</code>()</code> et non pas la méthode d'un autre objet qui aurait été créé (<code>Math</code> n'est pas un constructeur).</p>

<h2 id="Exemples">Exemples</h2>

<h3 id="Utiliser_Math.fround()">Utiliser <code>Math.fround()</code></h3>

<pre class="brush: js">Math.fround(0);     // 0
Math.fround(1);     // 1

// 1.337 ne peut pas être représenté correctement
// sur 32 bits
Math.fround(1.337); // 1.3370000123977661

Math.fround(1.5);   // 1.5
Math.fround(NaN);   // NaN</pre>

<h2 id="Spécifications">Spécifications</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Spécification</th>
   <th scope="col">État</th>
   <th scope="col">Commentaires</th>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-math.fround', 'Math.fround')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td>Définition initiale.</td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-math.fround', 'Math.fround')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="Compatibilité_des_navigateurs">Compatibilité des navigateurs</h2>

<p>{{Compat("javascript.builtins.Math.fround")}}</p>

<h2 id="Voir_aussi">Voir aussi</h2>

<ul>
 <li>{{jsxref("Math.round()")}}</li>
</ul>
