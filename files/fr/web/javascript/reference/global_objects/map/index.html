---
title: Map
slug: Web/JavaScript/Reference/Global_Objects/Map
tags:
  - ECMAScript 2015
  - JavaScript
  - Map
  - Reference
translation_of: Web/JavaScript/Reference/Global_Objects/Map
original_slug: Web/JavaScript/Reference/Global_Objects/Map
---
<div>{{JSRef}}</div>

<p>L'objet <strong><code>Map</code></strong> représente un dictionnaire, autrement dit une carte de clés/valeurs. N'importe quelle valeur valable en JavaScript (que ce soit les objets ou les valeurs de types primitifs) peut être utilisée comme clé ou comme valeur.</p>

<p>L'ordre d'insertion des clés est mémorisé dans l'objet et les boucles sur les <code>Map</code> parcourent les clés dans cet ordre.</p>

<h2 id="Syntaxe">Syntaxe</h2>

<pre class="syntaxbox notranslate">new Map([<var>iterable</var>])</pre>

<h3 id="Paramètres">Paramètres</h3>

<dl>
 <dt><code>itérable</code></dt>
 <dd>Un tableau ({{jsxref("Array")}}) ou tout autre objet <a href="/fr/docs/Web/JavaScript/Reference/Les_protocoles_iteration#Le_protocole_«_itérable_»">itérable</a> dont les éléments sont des paires clé/valeur (par exemple un tableau de la forme <code>[[1 , "toto"],[2, "truc"]]</code>). Chaque paire clé/valeur sera ajoutée au nouvel objet <code>Map</code>. {{jsxref("null")}} est traité comme {{jsxref("undefined")}}.</dd>
</dl>

<h2 id="Description">Description</h2>

<p>Un objet <code>Map</code> permet de retrouver ses éléments dans leur ordre d'insertion. Par exemple, une boucle {{jsxref("Instructions/for...of","for...of")}} renverra un tableau de <code>[clé, valeur]</code> pour chaque itération.</p>

<p>On notera qu'un objet <code>Map</code> contenant des objets ne sera parcouru que dans l'ordre d'insertion de ces objets. Avec ES2015, l'ordre d'itération est fixé pour les objets. Toutefois, pour les versions antérieures d'ECMAScript, cet ordre n'est pas garanti.</p>

<h3 id="Égalité_des_clés">Égalité des clés</h3>

<p>L'égalité des clés est testée avec l'algorithme basé sur <a href="/fr/docs/JavaScript/Les_différents_tests_d_Égalité_comment_les_utiliser#.C3.89galit.C3.A9_de_valeurs">l'égalité de valeurs</a> :</p>

<ul>
 <li>{{jsxref("NaN")}} est considéré égal à <code>NaN</code> (bien que, pour l'égalité stricte <code>NaN !== NaN</code>)</li>
 <li>les autres valeurs sont considérées égales au sens de l'égalité stricte (l'opérateur  <code>===</code>).</li>
</ul>

<p>Dans les versions précédentes des brouillons ECMAScript 2015 (ES6) <code>-0</code> et <code>+0</code> étaient considérés différents (bien que <code>-0 === +0</code>), ceci a été changé dans les versions ultérieures et a été adapté avec Gecko 29 {{geckoRelease("29")}} ({{bug("952870")}}) et une version nocturne de <a href="https://code.google.com/p/v8/issues/detail?id=3069">Chrome</a>.</p>

<h3 id="Comparaison_entre_objets_et_maps">Comparaison entre objets et maps</h3>

<p>Les {{jsxref("Object", "objets","",1)}} sont similaires aux <code>Maps</code>, chacun manipulant des clés associées à des valeurs, récupérant ces valeurs, supprimant des clés... Il n'y avait auparavant pas d'alternatives natives et c'est pourquoi, historiquement, les objets JavaScript ont été utilisés comme des <code>Maps</code>. Malgré tout, il y a des différences importantes entre<code> Objects</code> et <code>Maps</code> qui permettent de distinguer une utilisation des objets <code>Map</code> plus efficace :</p>

<ul>
 <li>Un <code>Object</code> possède un prototype, certaines clés par défaut peuvent donc entrer en collision avec les clés qu'on souhaite créer. À partir d'ES5, on peut écrire <code>map = </code> {{jsxref("Object.create", "Object.create(null)")}} mais cette formulation est rarement utilisée.</li>
 <li>Les clés d'une <code>Map</code> sont ordonnées tandis que les clés d'un objet n'ont pas d'ordre particulier. Ainsi, quand on parcourt une <code>Map</code>, on obtient les clés selon leur ordre d'insertion. On notera qu'à partir d'ECMAScript 2015, la spécification pour les objets indique de conserver l'ordre de création pour les clés qui sont des chaînes et des symboles.</li>
 <li>Les clés d'un <code>Object</code> sont des {{jsxref("String", "chaînes de caractères","",1)}} ou des symboles (cf. {{jsxref("Symbol")}}), alors que pour une <code>Map</code> ça peut être n'importe quelle valeur.</li>
 <li>Il est possible d'obtenir facilement la taille d'une <code>Map</code> avec <code>size</code>. En revanche, pour un <code>Object</code> il faudra compter « manuellement ».</li>
 <li>Un objet <code>Map</code> est un <a href="/fr/docs/Web/JavaScript/Reference/Les_protocoles_iteration#Le_protocole_«_itérable_»">itérable</a> et on peut donc le parcourir directement. En revanche, itérer sur un <code>Object</code> nécessite de récupérer les clés de l'objet pour ensuite les parcourir.</li>
 <li>Un objet <code>Map</code> permettra d'obtenir de meilleures performances si on ajoute et supprime des éléments fréquemment.</li>
</ul>

<h2 id="Propriétés">Propriétés</h2>

<dl>
 <dt><code>Map.length</code></dt>
 <dd>La valeur de la propriété <code>length</code> est 0.<br>
 Attention, pour compter le nombre d'élément contenu dans une <code>Map</code>, on utilisera plutôt {{jsxref("Map.prototype.size")}}.</dd>
 <dt>{{jsxref("Map.@@species", "get Map[@@species]")}}</dt>
 <dd>La fonction constructeur utilisée pour créer des objets dérivées.</dd>
 <dt>{{jsxref("Map.prototype")}}</dt>
 <dd>Représente le prototype du constructeur <code>Map</code>. Permet l'addition de propriétés à tous les objets <code>Map</code>.</dd>
</dl>

<h2 id="Instances_de_Map">Instances de <code>Map</code></h2>

<p>Toutes les instances de <code>Map</code> héritent de {{jsxref("Map.prototype")}}.</p>

<h3 id="Propriétés_2">Propriétés</h3>

<p>{{page('fr/docs/Web/JavaScript/Reference/Objets_globaux/Map/prototype','Propriétés')}}</p>

<h3 id="Méthodes">Méthodes</h3>

<p>{{page('fr/docs/Web/JavaScript/Reference/Objets_globaux/Map/prototype','Méthodes')}}</p>

<h2 id="Exemples">Exemples</h2>

<h3 id="Utiliser_un_objet_Map">Utiliser un objet <code>Map</code></h3>

<pre class="brush: js notranslate">const myMap = new Map();

const objectKey = {},
    functionKey = function () {},
    stringKey = "une chaîne";

// définir les valeurs
myMap.set(stringKey, "valeur associée à 'une chaîne'");
myMap.set(objectKey, "valeur associée à objectKey");
myMap.set(functionKey, "valeur associée à functionKey");

myMap.size; // 3

// récupérer les valeurs
myMap.get(stringKey);     // "valeur associée à 'une chaîne'"
myMap.get(objectKey);      // "valeur associée à objetClé"
myMap.get(functionKey);   // "valeur associée à fonctionClé"

myMap.get("une chaîne");  // "valeur associée à 'une chaîne'"
                          // car chaineClé === 'une chaîne'
myMap.get({});            // indéfini car objetClé !== {}
myMap.get(function() {}); // indéfini car fonctionClé !== function () {}
</pre>

<h3 id="Utiliser_NaN_comme_clé">Utiliser <code>NaN</code> comme clé</h3>

<p>{{jsxref("NaN")}} peut être utilisé comme une clé. Bien que <code>NaN</code> ne soit pas strictement égal à lui-même (<code>NaN !== NaN</code> est vérifié), on peut bâtir l'exemple suivant car on ne peut pas distinguer deux valeurs <code>NaN </code>:</p>

<pre class="brush: js notranslate">const myMap = new Map();
myMap.set(NaN, "not a number");

myMap.get(NaN); // "not a number"

const otherNaN = Number("toto");
myMap.get(otherNaN); // "not a number"
</pre>

<h3 id="Parcourir_des_objets_Maps_avec_for..of">Parcourir des objets <code>Maps</code> avec <code>for..of</code></h3>

<p>Il est possible de parcourir les objets <code>Map </code>grâce à des boucles <code>for..of</code> :</p>

<pre class="brush: js notranslate">const myMap = new Map();
myMap.set(0, "zéro");
myMap.set(1, "un");
for (const [key, value] of myMap) {
  console.log(`${key} = ${value}`);
}
// On aura 2 lignes : la première avec "0 = zéro"
// la seconde avec "1 = un"

for (const key of myMap.keys()) {
  console.log(key);
}
// On aura 2 lignes : la première avec "0"
// et la seconde avec "1"

for (const value of myMap.values()) {
  console.log(valeur);
}
// On aura 2 lignes : la première avec "zéro"
// et la seconde avec "un"

for (const [key, value] of myMap.entries()) {
  console.log(`${key} = ${value}`);
}
// On aura 2 lignes : la première avec "0 = zéro"
// la seconde avec "1 = un"

myMap.forEach(function(value, key) {
  console.log(`${key} = ${value}`);
});
// On aura 2 lignes : la première avec "0 = zéro"
// la seconde avec "1 = un"
</pre>

<h3 id="Relation_avec_les_objets_Array">Relation avec les objets <code>Array</code></h3>

<pre class="brush: js notranslate">const keyValuePair = [["clé1", "valeur1"], ["clé2", "valeur2"]];

// On utilise le constructeur Map
// pour transformer un tableau de clés/valeurs
// en un objet map
const myMap = new Map(keyValuePair);

myMap.get("clé1"); // renvoie "valeur1"

// On utilise la fonction Array.from pour transformer
// une map en un tableau de clés/valeurs
console.log(Array.from(myMap)); // affichera la même chose que tableauCléValeur

// On peut aussi l'utiliser pour n'extraire que les clés
// ou les valeurs et créer le tableau associé
console.log(Array.from(myMap.keys())); // affichera ["clé1", "clé2"]</pre>

<h3 id="Cloner_et_fusionner_des_objets_Map">Cloner et fusionner des objets <code>Map</code></h3>

<p>Il est possible de cloner des <code>Map</code> comme on clone des tableaux :</p>

<pre class="brush: js notranslate">const original = new Map([
  [1, 'un']
]);

const clone = new Map(original);

console.log(clone.get(1)); // un
console.log(original === clone); // false. Utile pour une comparaison superficielle</pre>

<p>Attention, la donnée contenue dans la <code>Map</code> n'est pas clonée.</p>

<p>Il est également possible de fusionner deux <code>Map</code> en conservant le critère d'unicité sur les clés :</p>

<pre class="brush: js notranslate">const first = new Map([
  [1, 'un'],
  [2, 'deux'],
  [3, 'trois'],
]);

const second = new Map([
  [1, 'uno'],
  [2, 'dos']
]);

// On fusionne les deux maps. C'est la "dernière" version
// de la clé qui l'emporte.
// L'opérateur de décomposition nous permet principalement ici
// de convertir une map en un tableau
const fusion = new Map([...first, ...second]);

console.log(fusion.get(1)); // uno
console.log(fusion.get(2)); // dos
console.log(fusion.get(3)); // trois</pre>

<p>Il est également possible de fusionner des objets <code>Map</code> avec des objets <code>Array</code> :</p>

<pre class="brush: js notranslate">const first = new Map([
  [1, 'un'],
  [2, 'deux'],
  [3, 'trois'],
]);

const second = new Map([
  [1, 'uno'],
  [2, 'dos']
]);

// On peut fusionner des Maps avec un tableau
// Là encore c'est le dernier exemplaire de la clé qui l'emporte
const fusion = new Map([...first, ...second, [1, 'eins']]);

console.log(fusion.get(1)); // eins
console.log(fusion.get(2)); // dos
console.log(fusion.get(3)); // trois</pre>

<h2 id="Spécifications">Spécifications</h2>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Spécification</th>
   <th scope="col">État</th>
   <th scope="col">Commentaires</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{SpecName('ES2015', '#sec-map-objects', 'Map')}}</td>
   <td>{{Spec2('ES2015')}}</td>
   <td>Définition initiale.</td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-map-objects', 'Map')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="Compatibilité_des_navigateurs">Compatibilité des navigateurs</h2>

<p>{{Compat("javascript.builtins.Map")}}</p>

<h2 id="Voir_aussi">Voir aussi</h2>

<ul>
 <li><a class="link-https" href="https://bugzilla.mozilla.org/show_bug.cgi?id=697479">Le bug sur Map et Set pour Mozilla</a></li>
 <li><a class="external" href="https://web.archive.org/web/20170105121945/http://wiki.ecmascript.org:80/doku.php?id=harmony:simple_maps_and_sets">La proposition ECMAScript Harmony</a></li>
 <li>{{jsxref("Set")}}</li>
 <li>{{jsxref("WeakMap")}}</li>
 <li>{{jsxref("WeakSet")}}</li>
</ul>
