---
title: RDF in Mozilla FAQ
slug: Archive/Web_Standards/RDF_in_Mozilla_FAQ
tags:
  - RDF
  - 移行
translation_of: Archive/Web_Standards/RDF_in_Mozilla_FAQ
---
<h3 id="1._.E4.B8.80.E8.88.AC.E7.9A.84.E3.81.AA.E8.B3.AA.E5.95.8F" name="1._.E4.B8.80.E8.88.AC.E7.9A.84.E3.81.AA.E8.B3.AA.E5.95.8F">1. 一般的な質問</h3>

<h4 id=".E3.81.A8.E3.81.A3.E3.81.8B.E3.81.8B.E3.82.8A.E3.81.AF.E3.81.A9.E3.81.93.E3.81.8C.E3.81.84.E3.81.84.E3.81.A7.E3.81.99.E3.81.8B.3F" name=".E3.81.A8.E3.81.A3.E3.81.8B.E3.81.8B.E3.82.8A.E3.81.AF.E3.81.A9.E3.81.93.E3.81.8C.E3.81.84.E3.81.84.E3.81.A7.E3.81.99.E3.81.8B.3F">とっかかりはどこがいいですか?</h4>

<p>Mozilla では RDF には 2つの主要な目的のために利用します。 第一の目的は単純なもので、小さいデータを保存するクロスプラットフォームなデータベースとしてです。 第二の目的はより重要なもので、情報を表示する抽象"API"として <a class="external" href="http://www.mozilla-japan.org/docs/xul/xulnotes/template-primer.html">XULテンプレート</a> と共に使用されます。 [RDF_in_Fifty_Words_or_Less RDFを50単語以下で説明しなさい] は RDF が Mozilla で何を行うのかについてのてっとりばやい説明になっています。 <a class="external" href="http://www.mozilla.org/rdf/back-end-architecture.html">バックエンドアーキテクチャ</a> の文書は Mozilla の RDF 実装がどのように動くのかについてより詳細な説明をしています。 またこの文書から、他に利用する際のインターフェースについて手早い概要が得られます。</p>

<h4 id="Open_Directory.28.22dmoz.22.29_.E3.81.AE.E3.81.A9.E3.81.93.E3.81.8B.E3.82.89.E6.83.85.E5.A0.B1.E5.BE.97.E3.82.89.E3.82.8C.E3.81.BE.E3.81.99.E3.81.8B.3F" name="Open_Directory.28.22dmoz.22.29_.E3.81.AE.E3.81.A9.E3.81.93.E3.81.8B.E3.82.89.E6.83.85.E5.A0.B1.E5.BE.97.E3.82.89.E3.82.8C.E3.81.BE.E3.81.99.E3.81.8B.3F">Open Directory("dmoz") のどこから情報得られますか?</h4>

<p>残念、<em>ここじゃないですね</em>! <a class="external" href="http://www.dmoz.org/" rel="freelink">http://www.dmoz.org/</a> から始めましょう。 dmoz の日本語の Mozilla ディレクトリは <a class='\"external\"' href='\"http://dmoz.org/World/Japanese/%a5%b3%a5%f3%a5%d4%a5%e5%a1%bc%a5%bf/%a5%bd%a5%d5%a5%c8%a5%a6%a5%a7%a5%a2/%a5%a4%a5%f3%a5%bf%a1%bc%a5%cd%a5%c3%a5%c8/%a5%d6%a5%e9%a5%a6%a5%b6/Mozilla/\"'>こちら</a></p>

<h4 id=".E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.81.A3.E3.81.A6.E4.BD.95.E3.81.A7.E3.81.99.E3.81.8B.3F" name=".E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.81.A3.E3.81.A6.E4.BD.95.E3.81.A7.E3.81.99.E3.81.8B.3F">データソースって何ですか?</h4>

<p>RDF の切り口は一般に 2通りあります: ノードと弧&lt;arc&gt;のグラフとして、または論理学の命題 &lt;logical statement&gt; の「スープ」としての視点です。 データソースはある理由により集められたサブグラフ(もしくは命題の集合、これらは視点により違う) 今あるデータソースの例としては、「ブラウザのブックマーク」、「ブラウザ全体の履歴」、「IMAP メイルアカウント」、「NNTPニュースサーバー」、「RDF/XML ファイル」といったものがあります。 Mozilla はデータソースを <a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFCompositeDataSource.idl">composite data source</a> を用いて組み合わせることができます。 これは積み重ねられたグラフや、命題群の集合(小さな定理の集まり)を融合させることに似ています。 同じ RDF<em>リソース</em>に関する命題群を混ぜ合わせることができます: 例えば、あるウェブサイトの「最終訪問日」は「ブラウザ全体の履歴」データソースから得られます。さらに、そのウェブサイトへ行くために打ち込む「ショートカットキーワード」は「ブラウザブックマーク」から得られます。どちらのデータソースも「ウェブサイト」を URL で参照します: これがデータソースを効果的に「混ぜ合わ」せるための「鍵」となります。 データソースの<em>書き方</em>についてより詳しい説明は、 [datasource-howto.html Datasource HOWTO] を参照してください。</p>

<h4 id="Mozilla_.E3.81.AF.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.82.92.E3.81.A9.E3.81.86.E7.AE.A1.E7.90.86.E3.81.97.E3.81.A6.E3.81.84.E3.81.BE.E3.81.99.E3.81.8B.3F" name="Mozilla_.E3.81.AF.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.82.92.E3.81.A9.E3.81.86.E7.AE.A1.E7.90.86.E3.81.97.E3.81.A6.E3.81.84.E3.81.BE.E3.81.99.E3.81.8B.3F">Mozilla はデータソースをどう管理していますか?</h4>

<p><a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFService.idl">RDFサービス</a> はロードした全てのデータソースのテーブルを管理します。 このテーブルはデータソースの "URI" によって索引付けられます。 データソースの URI とは、 RDF/XML ファイルの URL か <code>rdf:</code> で始まる組み込みデータソースを参照する特殊な URI です。 <code>GetDataSource()</code> メソッドを用いて RDFサービスを介してデータソースをロードできます。 URI引数が RDF/XML ファイルの URL を指していたら、RDFサービスは<em>RDF/XMLデータソース</em>を作成し、それを非同期的にパースします。 データソースはそれへの最後の参照が解放されるまで「キャッシュ」されます。 URI引数が組み込みデータソースを参照していた場合、RDFサービスは XPCOM の<em>Component Manager</em> を用いて、「特殊」URI と <code>@mozilla.org/rdf/datasource;1?name=</code>. というプリフィクスから構成される<em>ContractID</em>を持つコンポーネントをロードします。 例として <code>rdf:foo</code> は次のコンポーネントをロードします: <code>@mozilla.org/rdf/datasource;1?name=foo</code> RDF/XMLデータソースと同様に、この方法で解決されたデータソースは最後の参照が捨てられるまで RDFサービスにより「キャッシュ」されます。</p>

<h4 id=".E3.81.A9.E3.81.86.E3.82.84.E3.81.A3.E3.81.A6_RDF.2FXML.E3.83.95.E3.82.A1.E3.82.A4.E3.83.AB.E3.81.8B.E3.82.89.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.82.92.E4.BD.9C.E3.82.8B.E3.82.93.E3.81.A7.E3.81.99.E3.81.8B" name=".E3.81.A9.E3.81.86.E3.82.84.E3.81.A3.E3.81.A6_RDF.2FXML.E3.83.95.E3.82.A1.E3.82.A4.E3.83.AB.E3.81.8B.E3.82.89.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.82.92.E4.BD.9C.E3.82.8B.E3.82.93.E3.81.A7.E3.81.99.E3.81.8B">どうやって RDF/XMLファイルからデータソースを作るんですか</h4>

<p><a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFService.idl">RDFサービスの</a> <code>GetDataSource()</code> メソッドを用いて RDF/XML データソースを作ることができます:</p>

<pre>// RDFサービスを得る
var RDF =
  Components
  .classes["@mozilla.org/rdf/rdf-service;1"]
  .getService(Components.interfaces.nsIRDFService);

// …次にデータソースを得ます。Webブラウザが次のリソースを
// '''text/rdf''' で扱うようにしておいてください。
var ds = RDF.GetDataSource("http://www.mozilla.org/some-rdf-file.rdf");

// '''ds'''は非同期にロードされますので、アサーションはすぐには
// 利用可能になりません。
</pre>

<p>または、XPCOM Component Manager を用いて直接作成することもできます。 以下のコード断片はこのやり方を表しています:</p>

<pre>// XPCOM Component Manager を使って RDF/XMLデータソースを作る
var ds =
  Components
  .classes["@mozilla.org/rdf/datasource;1?name=xml-datasource"]
  .createInstance(Components.interfaces.nsIRDFDataSource);

// [http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFRemoteDataSource.idl nsIRDFRemoteDataSource]インターフェースは、データソースをセットアップ
// する必要のあるインターフェースを提供しています。
var remote =
   ds.QueryInterface(Components.interfaces.nsIRDFRemoteDataSource);

// Webブラウザはこれを'''text/rdf'''として届けること!
remote.Init("http://www.mozilla.org/some-rdf-file.rdf");

// ロードします。これは非同期に行われることに注意してください。
// '''aBlocking''' を真にセットすることで同期的に行うことができますが、
// これはえてして悪い考えです。というのも UI が完全にロックされてしまいます。
remote.Refresh(false);

// '''ds'''は非同期にロードされますので、アサーションはすぐには
// 利用可能になりません。
</pre>

<p>同期的にロードするために、RDF/XMLデータソースを「手で」作成する必要があると考えるかもしれません。</p>

<h4 id="RDF.2FXML.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.81.AE.E3.83.AA.E3.83.AD.E3.83.BC.E3.83.89.E3.81.AF.E3.81.A9.E3.81.86.E3.82.84.E3.82.8B.E3.82.93.E3.81.A7.E3.81.99.E3.81.8B.3F" name="RDF.2FXML.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.81.AE.E3.83.AA.E3.83.AD.E3.83.BC.E3.83.89.E3.81.AF.E3.81.A9.E3.81.86.E3.82.84.E3.82.8B.E3.82.93.E3.81.A7.E3.81.99.E3.81.8B.3F">RDF/XMLデータソースのリロードはどうやるんですか?</h4>

<p>RDF/XMLデータソース(または <a class="external" href="http://lxr.mozilla.org/mozilla/source/source/rdf/base/idl/nsIRDFRemoteDataSource.idl"><code>nsIRDFRemoteDataSource</code></a> をサポートする全てのデータソース)に対して、 <code>nsIRDFRemoteDataSource</code> の <code>Refresh()</code> メソッドを使ってリロードできます。 <code>Refresh()</code> はオペレーションを同期的に("blocking")または非同期的に("non-blocking")行うよう指定するパラメーターをひとつとります。<em>本当に</em>自分のやることを理解していないなら、同期的にロードするべきでは<em>ありません</em><span class="nowiki">: 同期的なロードは完了するまで UI をフリーズします! </span></p>

<h4 id="RDF.2FXML.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.81.8C.E3.83.AD.E3.83.BC.E3.83.89.E3.81.95.E3.82.8C.E3.81.9F.E3.81.8B.E3.81.A9.E3.81.86.E3.81.8B.E3.81.AF.E3.81.A9.E3.81.86.E8.A6.8B.E5.88.86.E3.81.91.E3.82.8B.E3.82.93.E3.81.A7.E3.81.99.E3.81.8B.3F" name="RDF.2FXML.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.81.8C.E3.83.AD.E3.83.BC.E3.83.89.E3.81.95.E3.82.8C.E3.81.9F.E3.81.8B.E3.81.A9.E3.81.86.E3.81.8B.E3.81.AF.E3.81.A9.E3.81.86.E8.A6.8B.E5.88.86.E3.81.91.E3.82.8B.E3.82.93.E3.81.A7.E3.81.99.E3.81.8B.3F">RDF/XMLデータソースがロードされたかどうかはどう見分けるんですか?</h4>

<p><a class="external" href="http://lxr.mozilla.org/mozilla/source/source/rdf/base/idl/nsIRDFRemoteDataSource.idl"><code>nsIRDFRemoteDataSource</code></a> インターフェースを用いて、データソースがロードされたかそうでないかを <code>loaded</code>プロパティに即時に尋ねることができます。</p>

<pre>// RDFサービスを得る
var RDF =
  Components
  .classes["@mozilla.org/rdf/rdf-service;1"]
  .getService(Components.interfaces.nsIRDFService);

// データソースを得る
var ds = RDF.GetDataSource("http://www.mozilla.org/some-rdf-file.rdf");

// ここで、ロードされたかそうでないか確認…
var remote =
  ds.QueryInterface(Components.interfaces.nsIRDFRemoteDataSource);

if (remote.loaded) {
  alert("データソースはもうロードされています!");
}
else {
  alert("データソースはロードされていません。でもただ今ロードしています!");
}
</pre>

<p>データソースがロードされてい<em>ない</em>ということは、つまり非同期的にロードを行っているということです。 この API と JavaScript の <code>setTimeout</code> を用いることで、<code>loaded</code>プロパティを繰り返しチェックする<em>ポーリングループ</em>をセットアップできます。 これはクラッジ的(※)で、さらに悪いことにはロードの<em>失敗</em>を検出できません。例えば URL に何のデータも無い場合です! (※訳注 クラッジ(kludge); jargon. その場しのぎ的な安易な方法による問題回避策。とりあえず動くもの。) この理由により、 <a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFXMLSink.idl">オブザーバーインターフェース</a> があります。 これはデータソースの進捗を見張れるようにします。以下のコードに使い方を示しています:</p>

<pre>// RDF/XML の読み込み進捗を観察するオブジェクト
var Observer = {
  onBeginLoad: function(aSink)
    {},

  onInterrupt: function(aSink)
    {},

  onResume: function(aSink)
    {},

  onEndLoad: function(aSink)
    { alert("done!"); },

  onError: function(aSink, aStatus, aErrorMsg)
    { alert("error! " + aErrorMsg); }
};

// RDFサービスを得る
var RDF =
  Components
  .classes["@mozilla.org/rdf/rdf-service;1"]
  .getService(Components.interfaces.nsIRDFService);

// データソースを得る
var ds = RDF.GetDataSource("http://www.mozilla.org/some-rdf-file.rdf");

// ここで、ロードされたかそうでないか確認…
var remote =
  ds.QueryInterface(Components.interfaces.nsIRDFRemoteDataSource);

if (remote.loaded) {
  alert("データソースはもうロードされています!");
}
else {
  alert("データソースはロードされていません。でもただ今ロードしています!");

  // RDF/XML データソースは '''nsIRDFXMLSink''' でもあります
  var sink =
    ds.QueryInterface(Components.interfaces.nsIRDFXMLSink);

  // Observer を sinkとしてのデータソースに関連付けます
  sink.addXMLSinkObserver(Observer);

  // '''Observer'''のメソッドがロードの進捗につれてコールバックされます。
}
</pre>

<h4 id=".E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E5.86.85.E3.81.AE.E6.83.85.E5.A0.B1.E3.81.B8.E3.81.AE.E3.82.A2.E3.82.AF.E3.82.BB.E3.82.B9.E6.96.B9.E6.B3.95.E3.81.AF.3F" name=".E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E5.86.85.E3.81.AE.E6.83.85.E5.A0.B1.E3.81.B8.E3.81.AE.E3.82.A2.E3.82.AF.E3.82.BB.E3.82.B9.E6.96.B9.E6.B3.95.E3.81.AF.3F">データソース内の情報へのアクセス方法は?</h4>

<p>The <a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFDataSource.idl"><code>nsIRDFDataSource</code></a> インターフェースがデータソースのアサーションを扱ったりアクセスしたりする方法です。</p>

<ul>
 <li><code>boolean HasAssertion(aSource, aProperty, aTarget, aTruthValue)</code>. これでデータソースが指定されたタップルを持つかどうかをテストします。</li>
 <li><code>nsIRDFNode GetTarget(aSource, aProperty, aTruthValue)</code>.</li>
 <li><code>nsISimpleEnumerator GetTargets(aSource, aProperty, aTruthValue)</code>.</li>
 <li><code>nsIRDFResource GetSource(aProperty, aTarget, aTruthValue)</code>.</li>
 <li><code>nsISimpleEnumerator GetSoruces(aProperty, aTarget, aTruthValue)</code>.</li>
 <li><code>nsISimpleEnumerator ArcLabelsIn(aTarget)</code>.</li>
 <li><code>nsISimpleEnumerator ArcLabelsOut(aSource)</code>.</li>
</ul>

<p>RDF<em>コンテナ</em> 内の情報にアクセスするためには、 [#how_do_i_manipulate_rdf_containers RDF container] インターフェースを使うこともできます。</p>

<h4 id=".E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E5.86.85.E3.81.AE.E6.83.85.E5.A0.B1.E3.81.AE.E5.A4.89.E6.9B.B4.E6.96.B9.E6.B3.95.E3.81.AF.3F" name=".E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E5.86.85.E3.81.AE.E6.83.85.E5.A0.B1.E3.81.AE.E5.A4.89.E6.9B.B4.E6.96.B9.E6.B3.95.E3.81.AF.3F">データソース内の情報の変更方法は?</h4>

<h4 id="RDF.2FXML.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.81.B8.E3.81.AE.E5.A4.89.E6.9B.B4.E3.82.92.E6.9B.B8.E3.81.8D.E6.88.BB.E3.81.99.E3.81.AB.E3.81.AF.E3.81.A9.E3.81.86.E3.81.99.E3.82.8B.E3.82.93.E3.81.A7.E3.81.99.E3.81.8B.3F" name="RDF.2FXML.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.81.B8.E3.81.AE.E5.A4.89.E6.9B.B4.E3.82.92.E6.9B.B8.E3.81.8D.E6.88.BB.E3.81.99.E3.81.AB.E3.81.AF.E3.81.A9.E3.81.86.E3.81.99.E3.82.8B.E3.82.93.E3.81.A7.E3.81.99.E3.81.8B.3F">RDF/XMLデータソースへの変更を書き戻すにはどうするんですか?</h4>

<p><a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFRemoteDataSource.idl"><code>nsIRDFRemoteDataSource</code></a><code>QueryInterface()</code><code>Flush()</code><code>file:</code><code>http:</code><code>Flush()</code> 今のところは file: URL のみ Flush() が効くみたいです。(see <a class='\"external\"' href='\"http://www.geocrawler.com/archives/3/125/2001/10/0/6956391/\"'>http://www.geocrawler.com/archives/3/125/2001/10/0/6956391</a>.</p>

<h4 id=".E3.81.84.E3.81.8F.E3.81.A4.E3.81.8B.E3.81.AE.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.82.92.E5.90.88.E3.82.8F.E3.81.9B.E3.81.A6_1.E3.81.A4.E3.81.AE.E3.82.88.E3.81.86.E3.81.AB.E6.89.B1.E3.81.86.E3.81.AB.E3.81.AF.E3.81.A9.E3.81.86.E3.82.84.E3.82.8A.E3.81.BE.E3.81.99.E3.81.8B.3F" name=".E3.81.84.E3.81.8F.E3.81.A4.E3.81.8B.E3.81.AE.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.82.92.E5.90.88.E3.82.8F.E3.81.9B.E3.81.A6_1.E3.81.A4.E3.81.AE.E3.82.88.E3.81.86.E3.81.AB.E6.89.B1.E3.81.86.E3.81.AB.E3.81.AF.E3.81.A9.E3.81.86.E3.82.84.E3.82.8A.E3.81.BE.E3.81.99.E3.81.8B.3F">いくつかのデータソースを合わせて 1つのように扱うにはどうやりますか?</h4>

<h4 id=".E3.80.8C.E7.B5.84.E3.81.BF.E8.BE.BC.E3.81.BF.E3.80.8D.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.81.B8.E3.81.AF.E3.81.A9.E3.81.86.E3.82.84.E3.81.A3.E3.81.A6.E3.82.A2.E3.82.AF.E3.82.BB.E3.82.B9.E3.81.97.E3.81.BE.E3.81.99.E3.81.8B.3F" name=".E3.80.8C.E7.B5.84.E3.81.BF.E8.BE.BC.E3.81.BF.E3.80.8D.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.81.B8.E3.81.AF.E3.81.A9.E3.81.86.E3.82.84.E3.81.A3.E3.81.A6.E3.82.A2.E3.82.AF.E3.82.BB.E3.82.B9.E3.81.97.E3.81.BE.E3.81.99.E3.81.8B.3F">「組み込み」データソースへはどうやってアクセスしますか?</h4>

<p><em>組み込みデータソース</em>とは、ローカルにインストールされているコンポーネントで、 <a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFDataSource.idl">nsIRDFDataSource</a>. を実装しているものです。 例えば、 <a class="external" href="http://lxr.mozilla.org/mozilla/source/xpfe/components/bookmarks/src/nsBookmarksService.cpp">ブックマークサービス</a> まず始めに、[#what_is_the_security_model ここ]を見て組み込みデータソースへアクセスできることを確認してください。 信頼されない XUL や JS から、組み込みデータソースへのアクセスする際にはいくつかセキュリティ上の制限があります。 組み込みデータソースはまるっきり XPCOM コンポーネントにすぎませんので、XPConnect コンポーネントマネージャーを用いて直接インスタンス化することができます。</p>

<pre>// コンポーネントマネージャーを用いてブックマークサービスを得る
var bookmarks =
  Components.
  classes["@mozilla.org/rdf/datasource;1?name=bookmarks"].
  getService(Components.interfaces.nsIRDFDataSource);

// ここに実際に何か行うコードを書く...
if (bookmarks.HasAssertion(
     RDF.GetResource("http://home.netscape.com/NC-rdf#BookmarksRoot"),
     RDF.GetResource("http://home.netscape.com/NC-rdf#child"),
     RDF.GetResource("http://home.netscape.com/NC-rdf#PersonalToolbarFolder"),
     true) {
  // ...
}
</pre>

<p>また別に、データソースのいくつかは「特別な」RDF向きの ContractID を持っているので、それを <a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFService.idl"><code>nsIRDFSerivce</code></a> の <code>GetDataSource()</code> メソッドや XULテンプレートの <code>datasources</code> 属性に用いてデータソースを簡単にインスタンスにできます。 これらの ContractID は <code>@mozilla.org/rdf/datasource;1?name=<em>name</em></code> という形式をしています。 さらに、 <code>GetDataSource()</code> と <code>datasources</code> 属性 に省略表記の <code>rdf:<em>name</em></code> を使ってアクセスすることもできます。 例えば、以下の XUL断片は XULテンプレートにデータソースとしてブックマークサービスを追加する方法を示しています。</p>

<pre>&lt;tree datasources="rdf:bookmarks"&gt;
  ...
&lt;/tree&gt;
</pre>

<h4 id="RDF.E3.80.8C.E3.82.B3.E3.83.B3.E3.83.86.E3.83.8A.E3.80.8D.E3.81.AF.E3.81.A9.E3.81.86.E6.89.B1.E3.81.84.E3.81.BE.E3.81.99.E3.81.8B.3F" name="RDF.E3.80.8C.E3.82.B3.E3.83.B3.E3.83.86.E3.83.8A.E3.80.8D.E3.81.AF.E3.81.A9.E3.81.86.E6.89.B1.E3.81.84.E3.81.BE.E3.81.99.E3.81.8B.3F">RDF「コンテナ」はどう扱いますか?</h4>

<p>RDF「コンテナ」(<code>&lt;rdf:Seq&gt;</code> など)を扱うためには <a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFContainerUtils.idl"><code>nsIRDFContainerUtils</code></a> が使えます。 <code>IRDFContainerUtils</code> は以下の ContractID でサービスとしてインスタンス化されます。 <code> @mozilla.org/rdf/container-utils;1 </code> このサービスの <code>IsSeq()</code>, <code>IsBag()</code>, <code>IsAlt()</code> を用いて、あるオブジェクトが RDFコンテナであるかどうかを判別できます。 <code> まだ <code>MakeSeq()</code>, <code>MakeBag()</code>, <code>MakeAlt()</code> を使われていない「リソースをコンテナに格納」できます。 これらのメソッドは <a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFContainer.idl"><code>nsIRDFContainer</code></a> を返し、このインターフェースで手間をかけずにコンテナライクな操作ができます。 また別のやり方として、もしデータソースが既に RDFコンテナ<em>である</em>オブジェクトを持っているならば、<code>nsIRDFContainer</code>オブジェクトを <code> @mozilla.org/rdf/container;1 </code> な ContractID でインスタンス化し、データソースとリソースをパラメータに <code>Init()</code> することができます。 このやり方は、リソースが既にコンテナでない場合は失敗することに注意してください。 </code></p>

<h3 id="2._XUL.E3.83.86.E3.83.B3.E3.83.97.E3.83.AC.E3.83.BC.E3.83.88" name="2._XUL.E3.83.86.E3.83.B3.E3.83.97.E3.83.AC.E3.83.BC.E3.83.88"><code>2. XULテンプレート </code></h3>

<p><code>XULテンプレートは XULドキュメント中の <code>datasources</code> で指定される属性で作成されます。 XULテンプレートを書くには 2通りの「形式」があります。 Mozillaコードベースで現在のところ最も一般的に使われている「簡易」形式と、RDFグラフに対して洗練されたマッチングを可能にする「拡張」形式です。 「簡易」形式は <a class="external" href="http://www.mozilla-japan.org/rdf/doc/xul-template-reference.html">XUL Template Reference</a> で議論されています。 「拡張」形式は <a class="external" href="http://www.mozilla-japan.org/docs/xul/xulnotes/template-primer.html">XUL Template Primer</a> で議論されています。 (これはやや変な扱い方です。というのも、<em>最終的な</em>目的は、概念的にはより簡単な拡張形式を用いてテンプレートを紹介し、後に「簡易」形式を拡張形式の省略記法として扱うことだからです。) </code></p>

<h4 id="XUL.E3.83.86.E3.83.B3.E3.83.97.E3.83.AC.E3.83.BC.E3.83.88.E3.81.A7.E6.A7.8B.E7.AF.89.E3.81.A7.E3.81.8D.E3.82.8B.E5.86.85.E5.AE.B9.E3.81.AF.E3.81.A9.E3.82.93.E3.81.AA.E3.82.82.E3.81.AE.E3.81.A7.E3.81.99.E3.81.8B.3F" name="XUL.E3.83.86.E3.83.B3.E3.83.97.E3.83.AC.E3.83.BC.E3.83.88.E3.81.A7.E6.A7.8B.E7.AF.89.E3.81.A7.E3.81.8D.E3.82.8B.E5.86.85.E5.AE.B9.E3.81.AF.E3.81.A9.E3.82.93.E3.81.AA.E3.82.82.E3.81.AE.E3.81.A7.E3.81.99.E3.81.8B.3F"><code>XULテンプレートで構築できる内容はどんなものですか? </code></h4>

<p><code><em>あらゆる</em>種類の内容を XULテンプレートを用いて構築することができます。 <a class="external" href="http://www.mozilla-japan.org/docs/xul/xulnotes/template-primer.html">primer</a> にあるほとんどのサンプルは treeウィジェットが使われていますが、 <code>&lt;rule&gt;</code>中の <code>&lt;action&gt;</code> 節にはどんなタグ(HTML や任意の XML も含みます)も使うことができます。 </code></p>

<h4 id=".E3.81.A9.E3.82.93.E3.81.AA.E6.99.82.E3.81.AB_XUL.E3.83.86.E3.83.B3.E3.83.97.E3.83.AC.E3.83.BC.E3.83.88.E3.82.92.E5.88.A9.E7.94.A8.E3.81.99.E3.81.B9.E3.81.8D.E3.81.A7.E3.81.99.E3.81.8B.3F" name=".E3.81.A9.E3.82.93.E3.81.AA.E6.99.82.E3.81.AB_XUL.E3.83.86.E3.83.B3.E3.83.97.E3.83.AC.E3.83.BC.E3.83.88.E3.82.92.E5.88.A9.E7.94.A8.E3.81.99.E3.81.B9.E3.81.8D.E3.81.A7.E3.81.99.E3.81.8B.3F"><code>どんな時に XULテンプレートを利用すべきですか? </code></h4>

<p><code>RDF と XULテンプレートを使うやり方の代替手段ひとつは、 <a class="external" href="http://www.w3.org/TR/REC-DOM-Level-1/">W3C DOM APIs</a> を使って XUL(や HTML) コンテントモデルを構築・操作することです。 ですが、これには不都合な時がままあります: </code></p>

<ol>
 <li><code><em>データには様々な「見せ方」があります</em>。 For example, Mozilla mail/news reveals the folder hierarchy in the toolbar, the "folder pane", in several menus, and in some of the dialogs. <code>&lt;menubutton&gt;</code>、<code>&lt;menu&gt;</code>, <code>&lt;tree&gt;</code> それぞれの DOMツリーを構築するために 3つの JS(か C++)コードを書くよりも、各内容モデルに対してひとつづつ、計 3つのコンパクトなルール集合を書く方がよいでしょう。 </code></li>
 <li><code><em>データは変わります</em>。 たとえば、mail/news ユーザーは IMAP フォルダを追加したり削除したりします。 (この要求が内容モデルを構築するのをどんなに面倒にすることか!) XULテンプレートビルダはルールを使って、<em>全ての</em>内容モデルを変化に自動的に同期させます。 </code></li>
</ol>

<p><code>もちろんこの機能を活用するためには情報を <a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFDataSource.idl">RDF datasource API</a>, の規約で表現できなければなりません。 これは、組み込みの<em>メモリデータソース</em>を使ったり、情報を格納するのに RDF/XML を使ったり、自分で <code>nsIRDFDataSource</code> の実装を(たぶん JavaScript で)書くことで行います。 </code></p>

<h4 id=".22datasources.3D.22_.E3.81.AB.E6.8C.87.E5.AE.9A.E3.81.97.E3.81.9F.E3.82.89.E4.BD.95.E3.81.8C.E3.83.AD.E3.83.BC.E3.83.89.E3.81.95.E3.82.8C.E3.82.8B.E3.82.93.E3.81.A7.E3.81.99.E3.81.8B.3F" name=".22datasources.3D.22_.E3.81.AB.E6.8C.87.E5.AE.9A.E3.81.97.E3.81.9F.E3.82.89.E4.BD.95.E3.81.8C.E3.83.AD.E3.83.BC.E3.83.89.E3.81.95.E3.82.8C.E3.82.8B.E3.82.93.E3.81.A7.E3.81.99.E3.81.8B.3F"><code>"datasources=" に指定したら何がロードされるんですか? </code></h4>

<p><code>ロードしたい<em>データソースURI</em>を空白で区切ったリストを、 テンプレートの「ルート」にある <code>datasources</code>属性に指定します。 でも「データソースURI」とは何なのでしょうか? それは、以下のいずれかです: </code></p>

<ul>
 <li><code>ローカルにインストールされているコンポーネントの ContractID の省略表記です。 <code>rdf:<em>name</em></code> で指定することで、テンプレートビルダに <code>@mozilla.org/rdf/datasource;1?name=<em>name</em></code> という ContractID の XPCOMコンポーネントをロードするよう指示します。 </code></li>
 <li><code>RDF/XML ファイルの URL です。例えばこんなもの:<br>
  <a class="external" rel="freelink">file:///tmp/foo.rdf</a><br>
  <a class="external" rel="freelink">chrome://mycomponent/content/component-data.rdf</a><br>
  <a class="external" href="http://www.mysite.com/generate-rdf.cgi" rel="freelink">http://www.mysite.com/generate-rdf.cgi</a><br>
  <a class="link-ftp" href="ftp://ftp.somewhere.org/toc.rdf" rel="freelink">ftp://ftp.somewhere.org/toc.rdf</a> </code></li>
</ul>

<p><code>ロードは<em>非同期に</em>行われます。 RDF/XML が届けられるにつれて、テンプレートビルダは内容を生成します。 どの場合でも、データソースは <a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFService.idl"><code>nsIRDFService</code></a> の <code>GetDataSource()</code> メソッドを用いてロードされます。 ですので、この方法によりロードされる他のデータソース全てと同じように [#how_does_mozilla_manage 管理] されます。 </code></p>

<h4 id="XUL_.E3.81.AE_RDF.2FXML_.E3.81.AE.E3.82.BB.E3.82.AD.E3.83.A5.E3.83.AA.E3.83.86.E3.82.A3.E3.83.A2.E3.83.87.E3.83.AB.E3.81.AF.E3.81.A9.E3.82.93.E3.81.AA.E3.82.82.E3.81.AE.E3.81.A7.E3.81.99.E3.81.8B.3F" name="XUL_.E3.81.AE_RDF.2FXML_.E3.81.AE.E3.82.BB.E3.82.AD.E3.83.A5.E3.83.AA.E3.83.86.E3.82.A3.E3.83.A2.E3.83.87.E3.83.AB.E3.81.AF.E3.81.A9.E3.82.93.E3.81.AA.E3.82.82.E3.81.AE.E3.81.A7.E3.81.99.E3.81.8B.3F"><code>XUL の RDF/XML のセキュリティモデルはどんなものですか? </code></h4>

<p><code>「信頼された」URL(今のところ <code>chrome:</code> URLの全て)からロードされた XUL は、XULテンプレートの <code>datasources</code>属性に<em>あらゆる</em>データソースURI を指定できます。 「信頼されていない」URLからロードされた XUL は、その XUL ドキュメントが由来したのと同じ (Java流に言えば)<em>codebase</em> からの RDF/XML ドキュメントのみを指定できます。 信頼されないXUL は「特殊な」(すなわち<code>rdf:</code>)データソースをロードできません。 </code></p>

<h4 id="XUL.E3.83.86.E3.83.B3.E3.83.97.E3.83.AC.E3.83.BC.E3.83.88.E3.81.AB.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.82.92.E8.BF.BD.E5.8A.A0.E3.81.99.E3.82.8B.E3.81.AB.E3.81.AF.E3.81.A9.E3.81.86.E3.82.84.E3.82.8A.E3.81.BE.E3.81.99.E3.81.8B.3F" name="XUL.E3.83.86.E3.83.B3.E3.83.97.E3.83.AC.E3.83.BC.E3.83.88.E3.81.AB.E3.83.87.E3.83.BC.E3.82.BF.E3.82.BD.E3.83.BC.E3.82.B9.E3.82.92.E8.BF.BD.E5.8A.A0.E3.81.99.E3.82.8B.E3.81.AB.E3.81.AF.E3.81.A9.E3.81.86.E3.82.84.E3.82.8A.E3.81.BE.E3.81.99.E3.81.8B.3F"><code>XULテンプレートにデータソースを追加するにはどうやりますか? </code></h4>

<p><code>XULテンプレートを <code>datasources</code>属性に指定された「暗黙の」データソース集合と共に生成できますが、 XULがロードされた<em>後</em>で加えたいデータソースが分かる場合がしばしばあります。 たとえば、表示したいデータソースを <code>onload</code>ハンドラで計算する必要があるかもしれませんし、ユーザーのアクションによって後からデータソースを加える必要があるかもしれません。 どうやってこれを行うのかを示した簡単な例を示します。 以下の XUL を見てください。 </code></p>

<pre><code>&lt;window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"&gt;
  ...
  &lt;tree id="my-tree" datasources="rdf:null"&gt;
    ...
  &lt;/tree&gt;
  ...
&lt;/window&gt;
</code></pre>

<p><code>どうにかしてデータソースを得たとします(例えば [#how_do_i_create_rdfxml こう]やって)。 以下のサンプルコードに、どうやってこのデータソースをテンプレートに<em>追加し</em>、その新たなデータソースの内容に基いてテンプレートを再構築するのかを示します。 </code></p>

<pre><code>var ds = /* とにかく得ました! */;

// 'my-tree' の DOMエレメントを得ます
var tree = document.getElementById('my-tree');

// データソースを加えます
tree.database.AddDataSource(ds);

// ここで tree を再構築します。「手動で」行わなければいけません!
tree.builder.rebuild();
</code></pre>

<p><code><code>datasources</code> を持った XULエレメントは全て <code>database</code>プロパティと <code>builder</code>プロパティを「獲得」します。 <code>database</code>プロパティは <a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIRDFCompositeDataSource.idl"><code>nsIRDFCompositeDataSource</code></a> オブジェクトを参照していて、ここにテンプレートを構築したデータソースが含まれています。 <code>builder</code>プロパティは <a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/base/idl/nsIXULTemplateBuilder.idl"><code>nsIXULTemplateBuilder</code></a> オブジェクトを参照していて、これはテンプレート内容の状態を維持する「ビルダ」です。 ところで <code>rdf:null</code>データソースというものがあります: これは特殊なデータソースで、「まだデータソースは無いぜ。だが後から加えるから準備しといてくれ!」と言ってることになります。 これで <code>database</code> と <code>builder</code> プロパティがインストールされますが、<code>database</code> は空のデータソース集合になっています: あとで自分で追加します! </code></p>

<h4 id="XUL.E3.83.86.E3.83.B3.E3.83.97.E3.83.AC.E3.83.BC.E3.83.88.E3.81.AF_DOM_API_.E3.81.A7.E6.89.B1.E3.81.88.E3.81.BE.E3.81.99.E3.81.8B.3F" name="XUL.E3.83.86.E3.83.B3.E3.83.97.E3.83.AC.E3.83.BC.E3.83.88.E3.81.AF_DOM_API_.E3.81.A7.E6.89.B1.E3.81.88.E3.81.BE.E3.81.99.E3.81.8B.3F"><code>XULテンプレートは DOM API で扱えますか? </code></h4>

<p><code>できます: ルールを追加したり削除したり、ルールの条件を変更したり、ルールから構築される内容を変更することができます。 実際には、 <a class="external" href="http://www.w3.org/TR/REC-DOM-Level-1/">W3C DOM APIs</a> を使って、テンプレートに関する<em>あらゆるもの</em>を変更できます。 ひとつ注意しておくことは、(XULテンプレートに [#how_do_i_add_datasource データソースを追加する] ためにしなければならないのとまったく同じように、)変更が効果を表すためには <code>rebuild()</code> を呼ばなければならないということです。 </code></p>

<h4 id=".E3.83.86.E3.83.B3.E3.83.97.E3.83.AC.E3.83.BC.E3.83.88.E3.81.8B.E3.82.89.E3.81.AE.E3.83.87.E3.83.BC.E3.82.BF.E3.82.92.E3.83.97.E3.83.AC.E3.83.BC.E3.83.B3.E3.83.86.E3.82.AD.E3.82.B9.E3.83.88.E3.81.A8.E3.81.97.E3.81.A6.E5.B7.AE.E3.81.97.E8.BE.BC.E3.82.80.E3.81.AB.E3.81.AF.E3.81.A9.E3.81.86.E3.82.84.E3.82.8A.E3.81.BE.E3.81.99.E3.81.8B.3F" name=".E3.83.86.E3.83.B3.E3.83.97.E3.83.AC.E3.83.BC.E3.83.88.E3.81.8B.E3.82.89.E3.81.AE.E3.83.87.E3.83.BC.E3.82.BF.E3.82.92.E3.83.97.E3.83.AC.E3.83.BC.E3.83.B3.E3.83.86.E3.82.AD.E3.82.B9.E3.83.88.E3.81.A8.E3.81.97.E3.81.A6.E5.B7.AE.E3.81.97.E8.BE.BC.E3.82.80.E3.81.AB.E3.81.AF.E3.81.A9.E3.81.86.E3.82.84.E3.82.8A.E3.81.BE.E3.81.99.E3.81.8B.3F"><code>テンプレートからのデータをプレーンテキストとして差し込むにはどうやりますか? </code></h4>

<p><code>テンプレートにプレーンテキストを挿入するには、<code>&lt;text&gt;</code>エレメントを使います。 </code></p>

<pre><code>&lt;template&gt;
  &lt;rule&gt;
    &lt;conditions&gt;...&lt;/condition&gt;
    &lt;bindings&gt;...&lt;/bindings&gt;
    &lt;action&gt;
      &lt;text value="?some-variable" /&gt;
    &lt;/action&gt;
  &lt;/rule&gt;
&lt;/template&gt;
</code></pre>

<p><code>上のテンプレートは一連のテキストノードと共に稼働する内容モデルを作成します。 </code></p>

<h3 id="3._.E3.81.86.E3.81.BE.E3.81.8F.E3.81.84.E3.81.8B.E3.81.AA.E3.81.8B.E3.81.A3.E3.81.9F.E3.82.89" name="3._.E3.81.86.E3.81.BE.E3.81.8F.E3.81.84.E3.81.8B.E3.81.AA.E3.81.8B.E3.81.A3.E3.81.9F.E3.82.89"><code>3. うまくいかなかったら </code></h3>

<p><code>実地から得られた trick や tips です。 </code></p>

<h4 id="RDF.2FXML.E3.83.95.E3.82.A1.E3.82.A4.E3.83.AB.E3.81.8C.E3.83.AD.E3.83.BC.E3.83.89.E3.81.95.E3.82.8C.E3.81.AA.E3.81.84" name="RDF.2FXML.E3.83.95.E3.82.A1.E3.82.A4.E3.83.AB.E3.81.8C.E3.83.AD.E3.83.BC.E3.83.89.E3.81.95.E3.82.8C.E3.81.AA.E3.81.84"><code>RDF/XMLファイルがロードされない </code></h4>

<p><code>Webサーバーから RDF/XML がロードされない理由の一番よくある原因は、MIME型が間違っていることです。サーバーが RDF/XMLファイルを <code>text/rdf</code> で配布していることを確認してください。 RDF/XML が実際に妥当&lt;valid&gt;であることを確認するためには <code>rdfcat</code> や <code>rdfpoll</code> ユーティリティを利用できます。 これら両方のプログラムともデフォルトでは Windows で構築されます。Linux では <code>configure --enable-tests</code> を指定してください。 </code></p>

<ul>
 <li><code><code><a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/tests/rdfcat/rdfcat.cpp">rdfcat</a><em>url</em></code> と指定します。パラメーターの指定した URL から RDF/XML ファイルを読み込み、コンソールに「表示&lt;cat&gt;」します。これを使って、あなたの書いた RDF/XML が Mozilla によってパーズされているかを確認できます。 </code></li>
 <li><code><code><a class="external" href="http://lxr.mozilla.org/mozilla/source/rdf/tests/rdfpoll/rdfpoll.cpp">rdfpoll</a><em>url</em> [<em>interval</em>]</code> と指定します。 パラメーターに読み込む RDF/XML ファイルの URL を指定します。 オプションで URL をリロードする<em>ポーリング間隔</em> をとります。 各ロードで生成されたアサーションを出力します。 ポーリングリロードは、今回と前回との RDF/XMLファイル内容の<em>差分</em>集合を生成することに注意してください。 これは、動的に生成され時間的に変化する RDF/XML ファイルをデバッグするのに有用です。 </code></li>
</ul>

<p><code>これらのプログラムはロードと実行が遅いです(でも最終的には動くで<em>しょう</em>)。 これらは XPCOM を初期化し、ロードと URLの処理ができるよう Necko を準備します。ちょうど Mozilla がやってるのと同じです。 </code></p>

<h3 id="Notes" name="Notes"><code>Notes </code></h3>

<h3 id="Contributors" name="Contributors"><code>Contributors </code></h3>

<div class="originaldocinfo">
<h2 id="Original_Document_Information" name="Original_Document_Information"><code>Original Document Information</code></h2>

<ul>
 <li><code>Author(s): <a class="link-mailto" href="mailto:waterson@netscape.com">Chris Waterson</a> </code></li>
 <li><code>Last Updated Date: December 22, 2004 </code></li>
 <li><code>Copyright Information: Copyright (C) <a class="link-mailto" href="mailto:waterson@netscape.com">Chris Waterson</a> </code></li>
</ul>
</div>

<div class="noinclude"> </div>
