---
title: クライアントサイドフレームワークの概要
slug: Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Introduction
l10n:
  sourceCommit: 70da4a8f77d691220aa8ed9d7305b290d52e7337
---

{{LearnSidebar}}{{NextMenu("Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Main_features", "Learn/Tools_and_testing/Client-side_JavaScript_frameworks")}}

JavaScript とフレームワークの簡単な歴史を見て、フレームワークがなぜ存在するのか、そしてそれが私たちに何をもたらすのか、学習するフレームワークの選択をどのように考え始めるか、そしてクライアント側フレームワークの代替手段は何があるのかをこの分野の一般的な概要からフレームワークの考察を始めます。

<table>
  <tbody>
    <tr>
      <th scope="row">前提条件:</th>
      <td>
        <a href="/ja/docs/Learn/HTML">HTML</a>、
        <a href="/ja/docs/Learn/CSS">CSS</a>、
        <a href="/ja/docs/Learn/JavaScript">JavaScript</a> に精通していること。
      </td>
    </tr>
    <tr>
      <th scope="row">目的:</th>
      <td>
        クライアントサイド JavaScript フレームワークがどのようにして登場したのか、それによって何が解決されるのか、どのような代替案があるのか​​、どのように一つを選べばよいかを理解すること。
      </td>
    </tr>
  </tbody>
</table>

## 簡単な歴史

1996 年に JavaScript が登場すると、それまで静的な文書で構成されていたウェブに、ところどころの操作の可能性と興奮が加わりました。 ウェブは単に _ものを読む_ だけではなく、 _何かをする_ ための場所になりました。 JavaScript の人気は着実に高まりました。 JavaScript を扱う開発者は、直面した問題を解決するためのツールを作成し、**ライブラリー**と呼ばれる再利用可能なパッケージにパッケージ化して、他のユーザーとソリューションを共有できるようにしました。このライブラリーの共有エコシステムは、ウェブの成長を形作るのに役立ちました。

現在、 JavaScript はウェブに不可欠な部分となり、[すべてのウェブサイトの 98% で使用されており](https://w3techs.com/technologies/details/cp-javascript)、ウェブは現代生活に不可欠な部分です。ユーザーは論文を書いたり、予算を管理したり、音楽をストリーミングしたり、映画を鑑賞したり、テキスト、音声、またはビデオチャットを使って遠距離の他のユーザーと瞬時にコミュニケーションしたりできます。ウェブを使用すると、これまでコンピューターにインストールされたネイティブアプリケーションでのみ可能であったことが実行できるようになります。これらの最新の複雑でインタラクティブなウェブサイトは、**ウェブアプリケーション**と呼ばれることがよくあります。

最新の JavaScript フレームワークの出現により、非常に動的でインタラクティブなアプリケーションの構築がはるかに簡単になりました。**フレームワーク**は、ソフトウェアの構築方法についての意見を提供するライブラリーです。これらの意見により、アプリケーションの予測可能性と均一性が可能になります。予測可能性により、ソフトウェアを巨大なサイズに拡張しながらも保守可能になります。予測可能性と保守性は、ソフトウェアの健全性と寿命にとって不可欠です。

JavaScript フレームワークは、あなたが毎日使用するウェブサイトの多くを含む、現代のウェブ上の優れたソフトウェアの多くを強化しています。現在この記事を読んでいる MDN Web Docs は、React/ReactDOM フレームワークを使用してフロントエンドを強化します。

## どのようなフレームワークがあるのか

さまざまなフレームワークが存在しますが、現在「ビッグ 4」は次のとおりであると考えられています。

### Ember

[Ember](https://emberjs.com/) は、 [SproutCore](https://en.wikipedia.org/wiki/SproutCore) プロジェクトで開始された作業の継続として、2011 年 12 月に最初にリリースされました。これは古いフレームワークであり、React や Vue などの最新の代替フレームに比べてユーザー数は少ないですが、その安定性、コミュニティサポート、いくつかの賢いコーディング原則により、依然としてかなりの人気を誇っています。

[Ember の学習を開始する](/ja/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_getting_started)

### Angular

[Angular](https://angular.io) は、Google の Angular チームと個人および企業のコミュニティが主導するオープンソースのウェブアプリケーションフレームワークです。これは、 [AngularJS](https://angularjs.org/) を構築したのと同じチームによる完全な書き直しです。 Angular は 2016 年 9 月 14 日に正式にリリースされました。

Angular は、宣言型 HTML テンプレートを使用するコンポーネントベースのフレームワークです。ビルド時に、開発者に対して透過的に、フレームワークのコンパイラーがテンプレートを最適化された JavaScript 命令に変換します。 Angular は、JavaScript のスーパーセットである [TypeScript](https://www.typescriptlang.org/) を使用します。これについては、次の章でもう少し詳しく説明します。

[Angular の学習を開始する](/ja/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Angular_getting_started)

### Vue

オリジナルの [AngularJS](https://angularjs.org/) プロジェクトに取り組み、そこから学んだエヴァン・ユーは、2014年に [Vue](https://vuejs.org/) をリリースしました。 Vue はビッグ 4 の中では最も歴史が浅いが、最近人気が急上昇しています。

Vue は、 [AngularJS](https://angularjs.org/) と同様に、独自のコードの一部で HTML を拡張します。それとは別に、主に最新の標準 JavaScript に依存しています。

[Vue の学習を開始する](/ja/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_getting_started)

### React

Facebook は 2013 年に [React](https://react.dev/) をリリースしました。この時点で、Facebook はすでに React を使用して社内の問題の多くを解決していました。技術的には、 React 自体はフレームワークではありません。これは UI コンポーネントをレンダリングするためのライブラリーです。 React は、アプリケーションを作成するために他のライブラリーと組み合わせて使用されます。 React と [React Native](https://reactnative.dev/) を使用すると、開発者はモバイルアプリケーションを作成できます。 React と [ReactDOM](https://react.dev/reference/react-dom) を使用すると、ウェブアプリケーションなどを作成できます。

React と ReactDOM は一緒に使用されることが多いため、React は口語的に JavaScript フレームワークとして理解されています。このモジュールを読み進めるにつれて、その口語的な理解に基づいて作業していきます。

React は、 [JSX](https://react.dev/learn/writing-markup-with-jsx) として知られる HTML のような構文で JavaScript を拡張します。

[React の学習を開始する](/ja/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started)

## 何故フレームワークが存在するのか

フレームワークの作成にインスピレーションを与えた環境について説明しましたが、実際には、開発者がフレームワークを作成する必要性を _なぜ_ 感じたのかというと、そうではありません。その理由を探るには、まずソフトウェア開発の課題を検討する必要があります。

一般的な種類のアプリケーション、 To-Do リスト作成ツールを考えてみましょう。これについては、今後の章でさまざまなフレームワークを使用して実装する方法を見ていきます。このアプリケーションでは、ユーザーがタスクのリストの表示、新しいタスクの追加、タスクの削除などを実行できるようにする必要があります。そして、アプリケーションの基礎となるデータを確実に追跡および更新しながらこれを実行する必要があります。ソフトウェア開発では、この基礎となるデータは状態として知られています。

私達のそれぞれの目標は、理論的には単独では単純です。データを反復処理してレンダリングできます。オブジェクトに追加して新しいタスクを作成できます。識別子を使用してタスクを検索、編集、削除できます。アプリケーションではユーザーがこれら _すべて_ をブラウザー経由で実行できるようにする必要があることを思い出すと、いくつかの課題が見え始めます。**本当の問題は、アプリケーションの状態を変更するたびに、それに合わせて UI を更新する必要があるということです。**

この問題の難しさは、To Do リストアプリの _1_ つの機能、つまりタスクのリストのレンダリングだけを見て調べることができます。

## DOM の変更の冗長性

HTML 要素を構築し、適切なタイミングでブラウザーにレンダリングするには、驚くほどの量のコードが必要です。状態が次のように構造化されたオブジェクトの配列であるとします。

```js
const state = [
  {
    id: "todo-0",
    name: "Learn some frameworks!",
  },
];
```

それらのタスクの 1 つをユーザーにどのように表示すればよいでしょうか? 各タスクをリスト項目として表現したいとします。つまり、(順序なしリスト要素 [`<ul>`](/ja/docs/Web) 内の) HTML [`<li>`](/ja/docs/Web/HTML/Element/li) 要素です。どうやって作るのでしょうか？それは次のようになります。

```js
function buildTodoItemEl(id, name) {
  const item = document.createElement("li");
  const span = document.createElement("span");

  span.textContent = name;

  item.id = id;
  item.appendChild(span);
  item.appendChild(buildDeleteButtonEl(id));

  return item;
}
```

ここでは、 [`document.createElement()`](/ja/docs/Web/API/Document/createElement) メソッドを使用して `<li>` を作成し、さらに数行のコードで必要なプロパティと子要素を作成しています。

前のスニペットでは、別のビルド関数 `buildDeleteButtonEl()` を参照しています。これは、リスト項目要素を構築するために使用したパターンと同様のパターンに従います。

```js
function buildDeleteButtonEl(id) {
  const button = document.createElement("button");
  button.setAttribute("type", "button");
  button.textContent = "Delete";

  return button;
}
```

このボタンはまだ何も実行しませんが、削除機能の実装を決定すると後で実行されます。ページ上に項目をレンダリングするコードは次のようになります。

```js
function renderTodoList() {
  const frag = document.createDocumentFragment();
  state.tasks.forEach((task) => {
    const item = buildTodoItemEl(task.id, task.name);
    frag.appendChild(item);
  });

  while (todoListEl.firstChild) {
    todoListEl.removeChild(todoListEl.firstChild);
  }
  todoListEl.appendChild(frag);
}
```

これで、UI 専用のコードが 30 行をおよそ超えています。つまり、 DOM 内で _何かを_ レンダリングするためだけに、後でリスト項目のスタイルを設定するために使用できるクラスを追加する必要はありません。

DOM を直接操作して、この例のように要素の作り方、プロパティを変更する方法、要素を互いの内側に配置する方法、ページ上にそれらを表示する方法など DOM の仕組みについて多くのことを理解する必要があります。このコードは実際にユーザー操作を処理したり、タスクの追加や削除に対処したりするものはありません。これらの機能を追加する場合は、適切なタイミングで適切な方法で UI を更新することを忘れないでください。

JavaScript フレームワークは、この種の作業をはるかに簡単にするために作成されました。 JavaScript フレームワークは、より良い _開発者体験_ を提供するために存在します。これらは JavaScript にまったく新しい機能をもたらすわけではありません。これらにより、JavaScript の機能に簡単にアクセスできるようになり、今日のウェブに合わせて構築できるようになります。

このセクションのコードサンプルの動作を確認したい場合は、 [CodePen 上のアプリの動作バージョン](https://codepen.io/mxmason/pen/XWbPNmw) をチェックアウトしてください。これにより、ユーザーは次の機能を追加したり、新しいタスクを削除します。

このセクションで使用される JavaScript 機能について詳しくは、以下をご覧ください。

- [`Array.forEach()`](/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
- [`Document.createDocumentFragment()`](/ja/docs/Web/API/Document/createDocumentFragment)
- [`Document.createElement()`](/ja/docs/Web/API/Document/createElement)
- [`Element.setAttribute()`](/ja/docs/Web/API/Element/setAttribute)
- [`Node.appendChild()`](/ja/docs/Web/API/Node/appendChild)
- [`Node.removeChild()`](/ja/docs/Web/API/Node/removeChild)
- [`Node.textContent`](/ja/docs/Web/API/Node/textContent)

## UI を構築する別の方法

すべての JavaScript フレームワークは、ユーザーインターフェイスをより _宣言的に_ 記述する方法を提供します。つまり、UI がどのように見えるべきかを記述するコードを作成でき、フレームワークはそれを舞台裏の DOM で実行します。

新しい DOM 要素を繰り返し構築する標準的な JavaScript のアプローチは、一見しただけでは理解するのが困難でした。対照的に、次のコードブロックは、 Vue を使用してタスクのリストを記述する方法を示しています。

```html
<ul>
  <li v-for="task in tasks" v-bind:key="task.id">
    <span>\{{task.name\}}</span>
    <button type="button">Delete</button>
  </li>
</ul>
```

これだけです。このスニペットにより、約 32 行のコードが 6 行に減ります。 ここでの中括弧と `v-` 属性に馴染みがなくても大丈夫です。 Vue 固有の構文については、モジュールの後半で学習します。ここで理解すべきことは、このコードはそれが表す UI に似ているのに対し、バニラ Javascript コードはそうではないということです。

Vue のおかげで、 UI を構築するために独自の関数を作成する必要がなくなりました。フレームワークは、最適化された効率的な方法でそれを処理します。ここでの私たちの唯一の役割は、各項目がどのように見えるべきかを Vue に記述することでした。 Vue に精通している開発者は、プロジェクトに参加すると何が起こっているのかをすぐに理解できます。これは Vue だけではありません。フレームワークを使用すると、チームだけでなく個人の効率も向上します。

これと _似たようなこと_ をバニラ Javascript でも実現できます。[テンプレートリテラル文字列](/ja/docs/Web/JavaScript/Reference/Template_literals)を使用すると、最終的な要素がどのようになるかを表す HTML の文字列を簡単に作成できます。これは、 To Do リストアプリケーションのような単純なものには便利なアイデアかもしれませんが、数千のデータレコードを管理し、ユーザーインターフェイスに同じ数の固有の要素をレンダリングする可能性がある大規模なアプリケーションでは維持できません。

## フレームワークが私たちに与えてくれるその他のこと

フレームワークが提供する他の利点を見てみましょう。前にも述べたように、フレームワークの利点はバニラ Javascript でも実現可能ですが、フレームワークを使うことで、これらの問題を自分で解決しなければならないという認知的な負荷をすべて取り除くことができます。

### ツール

このモジュールに含まれるフレームワークはそれぞれ大規模で活発なコミュニティを持っているので、それぞれのフレームワークのエコシステムは開発者の経験を向上させるツールを提供します。これらのツールによって、テスト(アプリケーションがあるべきように動作することを保証する) や lint (コードがエラーフリーでスタイルが一貫していることを保証する)のようなものを簡単に追加できます。

> [!NOTE]
> ウェブツールのコンセプトについてもっと詳しく知りたい方は、[クライアントサイドツールの概要](/ja/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Overview)をご覧ください。

### コンパートメント化

ほとんどの主要なフレームワークは、開発者がユーザーインターフェイスのさまざまな部分を _コンポーネント_ 、つまり相互に通信できる保守可能で再利用可能なコードの塊に抽象化することを推奨しています。特定のコンポーネントに関連するすべてのコードは 1 つのファイル (またはいくつかの特定のファイル)に保存できるため、開発者はそのコンポーネントに変更を加えるためにどこに行けばよいかを正確に知ることができます。バニラ Javascript アプリでは、これを効率的かつスケーラブルな方法で実現するには、独自の規則セットを作成する必要があります。多くの JavaScript 開発者は、自分のデバイスに任せると、 UI の一部に関連するすべてのコードが 1 つのファイル全体に、または別のファイル全体に分散されてしまう可能性があります。

### ルーティング

ウェブの最も重要な機能は、ユーザーがあるページから別のページに移動できることです。ウェブは結局のところ、相互リンクされたドキュメントのネットワークです。このウェブサイト上のリンクをたどると、ブラウザーがサーバーと通信し、表示する新しいコンテンツを取得します。そうすると、アドレスバーの URL が変わります。この新しい URL を保存して、後でそのページに戻ったり、他のユーザーと共有して同じページを簡単に見つけたりすることができます。ブラウザーはナビゲーション履歴を記憶しており、前後に移動することもできます。これは **サーバー側ルーティング** と呼ばれます。

最新のウェブアプリケーションは通常、新しい HTML ファイルを取得してレンダリングしません。ユーザーをウェブ上の新しいアドレスに誘導することなく、単一の HTML シェルをロードし、その中の DOM (**シングルページアプリ**、または **SPA: Single Page Aoolication** と呼ばれます) を継続的に更新します。新しい擬似ウェブページは通常、 _ビュー_ と呼ばれ、デフォルトではルーティングは行われません。

SPA が十分に複雑で、十分な独自のビューをレンダリングする場合、アプリケーションにルーティング機能を組み込むことが重要です。人々は、アプリケーション内の特定のページにリンクしたり、ナビゲーション履歴を前後に移動したりできることに慣れていますが、これらの標準的なウェブ機能が壊れるとエクスペリエンスが低下します。この方法でクライアントアプリケーションによってルーティングが処理される場合、それは適切にも**クライアントサイドルーティング**と呼ばれます。

JavaScript とブラウザーのネイティブ機能を使用してルーターを作成することは _可能_ ですが、人気があり積極的に開発されているフレームワークには、ルーティングを開発プロセスのより直感的な部分にする付属ライブラリーがあります。

## フレームワークを使用する際の考慮事項

有能なウェブ開発者になるには、仕事に最適なツールを使用する必要があります。 JavaScript フレームワークはフロントエンドアプリケーションの開発を容易にしますが、すべての問題を解決する特効薬ではありません。このセクションでは、フレームワークを使用する際に考慮すべき点について説明します。フレームワークがまったく必要ない場合もあることを念頭に置いてください。フレームワークを目的だけで使用することのないように注意してください。

### ツールに精通している

バニラ Javascript と同様に、フレームワークは学習に時間がかかり、癖があります。プロジェクトにフレームワークを使用することを決定する前に、そのフレームワークが自分にとって不利になるのではなく、自分にとって役立つように、その機能を十分に学習する時間を確保し、チームメイトもそのフレームワークに慣れているかどうかを確認してください。

### オーバーエンジニアリング

もしあなたのウェブ開発プロジェクトが数ページの個人的なポートフォリオで、それらのページにインタラクティブな機能がほとんどない、もしくは全くないのであれば、フレームワーク（とその JavaScript のすべて）は全く必要ないかもしれません。とはいえ、フレームワークは一枚岩ではないし、小規模なプロジェクトに適したものもある。 Smashing Magazine の記事で、 Sarah Drasner は、ウェブページの小さな部分をインタラクティブにするツールとして、[Vue が jQuery を置き換えることができる](https://www.smashingmagazine.com/2018/02/jquery-vue-javascript/)ということを書いています。

### より大きなコードベースと抽象化

フレームワークを使用すると、舞台裏で DOM インタラクションを処理することで、より宣言的なコードを作成でき、場合によっては全体的にコードが _少なくなる_ 場合もあります。 この抽象化は開発者としてのエクスペリエンスに最適ですが、無料ではありません。作成した内容を DOM の変更に変換するには、フレームワークが独自のコードを実行する必要があり、その結果、最終的なソフトウェアのサイズが大きくなり、操作にかかる計算コストが高くなります。

追加のコードは避けられず、ツリーシェイキング(ビルドプロセス中にアプリで実際に使用されていないコードの削除)をサポートするフレームワークを使用すると、アプリケーションを小さく保つことができますが、これは依然として必要な要素です。特に携帯電話など、ネットワークやストレージに制約のあるデバイスでのアプリのパフォーマンスを考慮する際には、この点に留意してください。

フレームワークの抽象化は、 JavaScript だけでなく、ウェブの性質そのものとの関係にも影響します。ウェブ用にどのように構築しても、最終結果、つまりユーザーが最終的に対話するレイヤーは HTML です。アプリケーション全体を JavaScript で記述すると、 HTML とそのさまざまなタグの目的を見失い、セマンティックではなくアクセスできない HTML ドキュメントが作成される可能性があります。実際、 JavaScript に完全に依存し、 JavaScript なしでは機能しない脆弱なアプリケーションを作成することも可能です。

フレームワークが問題の原因ではありません。優先順位を間違えると、アプリケーションは壊れやすく、肥大化し、アクセスできなくなる可能性があります。ただし、フレームワークにより、開発者としての優先順位がさらに高まります。複雑なウェブアプリを作成することを優先する場合、それは簡単です。ただし、優先順位によってパフォーマンスとアクセシビリティが慎重に守られていない場合、フレームワークによって脆弱性、肥大化、アクセス不能性が増幅されてしまいます。フレームワークによって強化された現代の開発者の優先順位は、多くの場所でウェブの構造を逆転させています。 現在のウェブでは、堅牢なコンテンツ優先のドキュメントネットワークの代わりに、 JavaScript が優先され、ユーザーエクスペリエンスが最後に配置されることが多くなっています。

## フレームワーク主導のウェブでのアクセシビリティ

前のセクションで述べたことを踏まえて、アクセシビリティについてもう少し詳しく説明しましょう。ユーザーインターフェイスをアクセスしやすくするには、常にある程度の思考と努力が必要ですが、フレームワークによってそのプロセスが複雑になる場合があります。 ARIA [ライブリージョン](/ja/docs/Web/Accessibility/ARIA/ARIA_Live_Regions) やフォーカス管理などのネイティブブラウザー機能にアクセスするには、多くの場合、高度なフレームワーク API を使用する必要があります。

場合によっては、フレームワークアプリケーションによって、従来のウェブサイトには存在しないアクセシビリティの障壁が生じることがあります。この最大の例は、前述したように、クライアント側のルーティングです。

従来の(サーバーサイド)ルーティングでは、ウェブをナビゲートすると予測可能な結果が得られます。ブラウザーはページの上部にフォーカスを設定することを認識し、支援技術がページのタイトルをアナウンスします。これらのことは、新しいページに移動するたびに発生します。

クライアント側ルーティングでは、ブラウザーは新しいウェブページを読み込まないため、フォーカスを自動的に調整したり、新しいページタイトルをアナウンスしたりする必要があることを認識しません。フレームワークの作成者は、これらの機能を再現する JavaScript の作成に膨大な時間と労力を費やしてきましたが、それでも、これほど完璧に実行できるフレームワークはありませんでした。

結論としては、 _すべての_ ウェブプロジェクトの最初からアクセシビリティを考慮する必要がありますが、そうしないと、フレームワークを使用する抽象化されたコードベースで重大なアクセシビリティの問題が発生する可能性が高くなることに留意してください。

## フレームワークの選び方

このモジュールで説明する各フレームワークは、ウェブアプリケーション開発に対して異なるアプローチを取ります。それぞれが定期的に改善されたり変化したりしており、それぞれに長所と短所があります。適切なフレームワークを選択することは、チームとプロジェクトに依存するプロセスであり、何があなたのニーズに合っているかを明らかにするために、あなた自身で調査する必要があります。とはいえ、選択肢をより効果的に調査するために、いくつかの質問を挙げてみました

1. フレームワークはどのブラウザーをサポートしていますか？
2. フレームワークではどのようなドメイン固有言語が使用されますか？
3. このフレームワークには強力なコミュニティがあり、優れたドキュメント(およびその他のサポート)が利用可能ですか？

このセクションの表は、各フレームワークが現在提供している _ブラウザーのサポート_ と、**ドメイン固有言語**を一目でわかるようにまとめたものです。

大まかに言うと、{{Glossary("DSL/Domain_specific_language", "ドメイン固有言語（DSL）")}}は、ソフトウェア開発の特定の分野に関連するプログラミング言語です。フレームワークの文脈では、 DSL は JavaScript や HTML のバリエーションで、そのフレームワークでの開発を容易にします。重要なことは、どのフレームワークも特定の DSL を使うことを開発者に _要求_ しませんが、ほとんどすべてのフレームワークが特定の DSL を念頭に置いて設計されているということです。フレームワークが推奨する DSL を使わないという選択は、そうでなければ開発者のエクスペリエンスを向上させる機能を逃してしまうことを意味します。

新しいプロジェクトを選択するときは、フレームワークのサポートマトリックスと DSL を真剣に検討する必要があります。ブラウザーのサポートが一致しないと、ユーザーの障害となる可能性があります。 DSL サポートが一致しないと、あなたとあなたのチームメイトにとって障害となる可能性があります。

| Framework | Browser support                     | Preferred DSL | Supported DSLs         | Citation                                                                           |
| --------- | ----------------------------------- | ------------- | ---------------------- | ---------------------------------------------------------------------------------- |
| Angular   | モダン                              | TypeScript    | HTML-based; TypeScript | [公式ドキュメント](https://angular.io/guide/browser-support)                       |
| React     | モダン                              | JSX           | JSX; TypeScript        | [公式ドキュメント](https://react.dev/reference/react-dom/client#browser-support)   |
| Vue       | モダン (IE9+ in Vue 2)              | HTML-based    | HTML-based, JSX, Pug   | [公式ドキュメント](https://cli.vuejs.org/guide/browser-compatibility.html)         |
| Ember     | モダン (IE9+ in Ember version 2.18) | Handlebars    | Handlebars, TypeScript | [公式ドキュメント](https://guides.emberjs.com/v3.3.0/templates/handlebars-basics/) |

> [!NOTE]
> 「HTML-based」と説明した DSL には正式な名前がありません。これらは実際には真の DSL ではありませんが、非標準の HTML であるため、強調する価値があると考えられます。

### フレームワークには強力なコミュニティがありますか？

コミュニティの規模はアクセスしやすい数字と直接相関しないため、これはおそらく測定するのが最も難しい指標です。プロジェクトの GitHub スターの数や週ごとの npm ダウンロードを確認して人気を知ることができますが、いくつかのフォーラムを検索したり、他の開発者に相談したりするのが最善の場合もあります。コミュニティの規模だけでなく、コミュニティがどれほど歓迎的で包括的であるか、利用可能なドキュメントがどれほど優れているかも重要です。

### ウェブ上の意見

この問題については、私たちの言葉をそのまま鵜呑みにしないでください。ウェブ上では議論が行われています。ウィキメディア財団は最近、フロントエンドに Vue を使用することを選択し、[フレームワークの採用に関するコメント要求( RFC )](https://phabricator.wikimedia.org/T241180)を投稿しました。 RFC の著者である Eric Gardner は、時間をかけてウィキメディアプロジェクトのニーズと、特定のフレームワークがチームにとって良い選択である理由を概説しました。この RFC は、フロントエンドフレームワークの使用を計画するときに自分で行うべき調査の優れた例として役立ちます。

[JavaScript の現状調査アンケート](https://stateofjs.com/) は、 JavaScript 開発者からの有益なフィードバックを集めたものです。フレームワークの使用とフレームワークに対する開発者の感情の両方に関するデータなど、 JavaScript に関連する多くのトピックをカバーしています。現在、数年分のデータが入手可能であり、フレームワークの人気を把握することができます。

Vue チームは [Vue を他の一般的なフレームワークと徹底的に比較](https://v2.vuejs.org/v2/guide/comparison.html)しました。この比較には多少の偏りがあるかもしれません(彼らはそれを指摘しています)が、それでも貴重な情報源です。

## クライアント側フレームワークの代替

ウェブ開発プロセスを迅速化するツールを探していて、プロジェクトで集中的なクライアントサイド JavaScript が必要ないことがわかっている場合は、ウェブを構築するための他のいくつかのソリューションのいずれかを利用できます。

- コンテンツ管理システム
- サーバーサイドレンダリング
- 静的サイトジェネレーター

### コンテンツ管理システム

**コンテンツ管理システム** (**CMS: Content-management systems**) は、ユーザーが自分で直接コードを書かずにウェブ用のコンテンツを作成できるツールのことです。大規模なプロジェクト、特にコーディング能力に乏しいコンテンツ・ライターからのインプットを必要とするプロジェクトや時間を節約したいプログラマーにとっては良いソリューションです。しかし CMS のセットアップにはかなりの時間を要し、 CMS を利用するということは、少なくともウェブサイトの最終的なアウトプットをコントロールする手段を放棄することを意味します。例えば、選択したCMSがデフォルトでアクセシブルなコンテンツを作成しない場合、これを改善するのは難しいことが多いです。

有名な CMS システムには、 [Wordpress](https://wordpress.com/)、[Joomla](https://www.joomla.org/)、[Drupal](https://www.drupal.org/) などがあります。

### サーバーサイドレンダリング

**サーバーサイドレンダリング** (**SSR: Server-side rendering**) は、単一ページアプリケーションをレンダリングするのが _サーバー_ の仕事であるアプリケーションアーキテクチャです。これは、JavaScript アプリケーションを構築する最も一般的で最も簡単な方法である _クライアントサイドレンダリング_ の逆です。サーバーサイドレンダリングは、レンダリングされた HTML ファイルをクライアントのデバイスに送信するだけなので、クライアントのデバイスでは簡単ですが、クライアント側でレンダリングされるアプリケーションに比べてセットアップが難しい場合があります。

このモジュールで説明されているフレームワークはすべて、クライアントサイドのレンダリングだけでなくサーバーサイドのレンダリングもサポートしています。 React については [Next.js](https://nextjs.org/) 、Vue については [Nuxt](https://nuxtjs.com/)（はい、わかりにくいです、いいえ、これらのプロジェクトは関係ありません!）、 Ember の場合は [FastBoot](https://github.com/ember-fastboot/ember-cli-fastboot)、 Angular の場合は [Angular Universal](https://angular.io/guide/universal) をチェックしてください。

> [!NOTE]
> SSR ソリューションの中にはコミュニティによって作成および保守されているものもありますが、フレームワークの保守者によって提供される「公式」ソリューションもあります。

### 静的サイトジェネレーター

静的サイトジェネレーターは、複数ページのウェブサイトのすべてのウェブページ(関連する CSS や JavaScript を含む)を動的に生成し、任意の数の場所に公開できるようにするプログラムです。公開ホストは例えば、 GitHub ページブランチ、 Netlify インスタンス、または選択したプライベートサーバーにすることができます。このアプローチには多くの利点があり、主にパフォーマンス(ユーザーのデバイスは JavaScript を使用してページを構築していません。すでに完成しています)とセキュリティ(静的ページは攻撃ベクトルが少ない)に関するものです。これらのサイトでは、必要に応じて JavaScript を引き続き利用できますが、 JavaScript に「依存」しているわけではありません。静的サイトジェネレーターは、他のツールと同様に学習に時間がかかるため、開発プロセスの障壁となる可能性があります。

静的サイトには、必要な数の固有のページを含めることができます。フレームワークを使用すると、クライアント側の JavaScript アプリケーションを迅速に作成できるようになりますが、静的サイトジェネレーターを使用すると、個別に作成する必要があった HTML ファイルを迅速に作成できます。フレームワークと同様、静的サイトジェネレーターを使用すると、開発者はウェブページの共通部分を定義するコンポーネントを作成し、それらのコンポーネントを組み合わせて最終ページを作成できます。静的サイトジェネレーターのコンテキストでは、これらのコンポーネントは **テンプレート** と呼ばれます。静的サイトジェネレーターによって構築されたウェブページは、フレームワークアプリケーションのホームとなることもあります。たとえば、静的に生成されたウェブサイトの特定のページで、ユーザーがそのページにアクセスしたときに React アプリケーションを起動したい場合は、それが可能です。

静的サイトジェネレーターはかなり古くから存在しており、最近になって新たな関心と革新の波が押し寄せています。[Astro](https://astro.build/)、[Eleventy](https://www.11ty.dev/)、[Hugo](https://gohugo.io/)、[Jekyll](https://jekyllrb.com/)、[Gatsby](https://www.gatsbyjs.com/) などのいくつかの強力な選択肢が利用可能になりました。

静的サイトジェネレーター全体について詳しく知りたい場合は、Tatiana Mac の [Eleventy の初心者ガイド](https://www.tatianamac.com/posts/beginner-eleventy-tutorial-parti/)を参照してください。シリーズの最初の記事では、静的サイトジェネレーターとは何か、そしてそれがウェブコンテンツを公開する他の手段とどのように関連するのかについて説明します。

## まとめ

これで、フレームワークの紹介は終わりになります。まだコードを教えていませんが、そもそもフレームワークを使用する理由と、フレームワークの選択方法について有益な背景を提供できたことを願っています。 1 つ目は、もっと学びたい、夢中になってみたいという気持ちになっていただければ幸いです。

次の記事では、より低いレベルまで掘り下げて、フレームワークが提供する傾向にある特定の種類の機能と、フレームワークがなぜそのように機能するのかを見ていきます。

{{NextMenu("Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Main_features", "Learn/Tools_and_testing/Client-side_JavaScript_frameworks")}}
