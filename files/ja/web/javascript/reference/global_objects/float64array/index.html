---
title: Float64Array
slug: Web/JavaScript/Reference/Global_Objects/Float64Array
tags:
  - Constructor
  - JavaScript
  - TypedArray
  - TypedArrays
translation_of: Web/JavaScript/Reference/Global_Objects/Float64Array
---
<div>{{JSRef}}</div>

<p><code>Float64Array タイプは、64 ビット浮動小数点数 (C 言語の float データタイプに相当します) の配列を表します。</code>各要素のバイトオーダーはプラットフォームに依存します。もしコントロールしたい場合は代わりに{{jsxref("DataView")}}を使って下さい。各要素は0で初期化されます。生成された <code>Float64Array</code> オブジェクトのメソッドあるいは配列のような表記法 ("<code>[]</code>") を用いて、要素を参照することができます。</p>

<h2 id="Constructors" name="Constructors">構文</h2>

<pre class="syntaxbox">new Float64Array(); // new in ES2017
new Float64Array(length);
new Float64Array(typedArray);
new Float64Array(object);
​new Float64Array(buffer [, byteOffset [, length]]);</pre>

<p>コンストラクタの構文とパラメータについての詳しい情報は{{jsxref("TypedArray")}}を参照して下さい。</p>

<h2 id="プロパティ">プロパティ</h2>

<dl>
 <dt>{{jsxref("TypedArray.BYTES_PER_ELEMENT", "Float64Array.BYTES_PER_ELEMENT")}}</dt>
 <dd>要素一個あたりのバイト数を返します。<code>Float64Array</code> の場合は<font face="Consolas, Liberation Mono, Courier, monospace">8</font>です。</dd>
 <dt>Float64Array.length</dt>
 <dd><code>値は3になります</code>。実際の長さ(要素数)については{{jsxref("TypedArray.prototype.length", "Float64Array.prototype.length")}}を参照して下さい。</dd>
 <dt>{{jsxref("TypedArray.name", "Float64Array.name")}}</dt>
 <dd>コンストラクタ名を文字列値で返します。<code>Float64Array</code> の場合、"Float64Array"<code>です</code>。</dd>
 <dt>{{jsxref("TypedArray.prototype", "Float64Array.prototype")}}</dt>
 <dd><em>TypedArray</em> オブジェクトのプロトタイプです。</dd>
</dl>

<h2 id="メソッド">メソッド</h2>

<dl>
 <dt>{{jsxref("TypedArray.from", "Float64Array.from()")}}</dt>
 <dd>配列状のオブジェクトやイテレート可能なオブジェクトから、新たな <code>Float64Array</code> オブジェクトを生成します。{{jsxref("Array.from()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.of", "Float64Array.of()")}}</dt>
 <dd>可変長引数で新しい <code>Float64Array</code> オブジェクトを生成します。{{jsxref("Array.of()")}}も確かめて下さい。</dd>
</dl>

<h2 id="Float64Array_プロトタイプ"><code>Float64Array</code> プロトタイプ</h2>

<p>全ての <code>Float64Array</code> オブジェクトは {{jsxref("TypedArray.prototype", "%TypedArray%.prototype")}} を継承しています。</p>

<h3 id="プロパティ_2">プロパティ</h3>

<dl>
 <dt><code>Float64Array.prototype.constructor</code></dt>
 <dd>インスタンスのプロトタイプを作る関数を返します。これは、デフォルトで対応する <code>Float64Array</code> コンストラクタです。</dd>
 <dt>{{jsxref("TypedArray.prototype.buffer", "Float64Array.prototype.buffer")}} {{readonlyInline}}</dt>
 <dd><code>Float64Array</code> オブジェクトによって参照される{{jsxref("ArrayBuffer")}}を返します。構築時に設定され、<strong>読取専用</strong>となります。</dd>
 <dt>{{jsxref("TypedArray.prototype.byteLength", "Float64Array.prototype.byteLength")}} {{readonlyInline}}</dt>
 <dd>{{jsxref("ArrayBuffer")}}の開始位置からの<code>Float64Array</code> オブジェクトの(バイト単位の)長さを返します。構築時に設定され、<strong>読取専用</strong>となります。</dd>
 <dt>{{jsxref("TypedArray.prototype.byteOffset", "Float64Array.prototype.byteOffset")}} {{readonlyInline}}</dt>
 <dd>{{jsxref("ArrayBuffer")}}の開始位置からの<code>Float64Array</code> オブジェクトの(バイト単位の)オフセットを返します。構築時に設定され、<strong>読取専用</strong>となります。</dd>
 <dt>{{jsxref("TypedArray.prototype.length", "Float64Array.prototype.length")}} {{readonlyInline}}</dt>
 <dd><code>Float64Array</code> オブジェクト内に保持された要素の数を返します。構築時に設定され、<strong>読取専用</strong>となります。</dd>
 <dt>
 <h3 id="メソッド_2">メソッド</h3>
 </dt>
 <dt>{{jsxref("TypedArray.prototype.copyWithin()", "Float64Array.prototype.copyWithin()")}}</dt>
 <dd>配列内で一連の配列要素をコピーします。{{jsxref("Array.prototype.copyWithin()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.entries", "Float64Array.prototype.entries()")}}</dt>
 <dd>配列内で各インデックスに対して、キー／バリュー　ペアを含む新しい<code>Array Iterator</code>を返します。{{jsxref("Array.prototype.entries()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.every", "Float64Array.prototype.every()")}}</dt>
 <dd>配列内のすべての要素が関数によって提供されたテストに合格するかどうかテストを実行します。{{jsxref("Array.prototype.every()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.fill", "Float64Array.prototype.fill()")}}</dt>
 <dd>開始位置から終了位置までの配列のすべての要素を固定値で設定します。{{jsxref("Array.prototype.fill()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.filter", "Float64Array.prototype.filter()")}}</dt>
 <dd>与えられたフィルタリング関数がtrueを返す配列のすべての要素をもつ新しい配列を生成します。{{jsxref("Array.prototype.filter()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.find", "Float64Array.prototype.find()")}}</dt>
 <dd>配列要素が与えられたテスト関数を満足したら、配列の値を返します。満足しなかった場合、<code>undefined</code>を返します。 {{jsxref("Array.prototype.find()")}}を確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.findIndex", "Float64Array.prototype.findIndex()")}}</dt>
 <dd>配列要素が与えられたテスト関数を満足したら、配列のインデックスを返します。満足しなかった場合、-1を返します。{{jsxref("Array.prototype.findIndex()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.forEach", "Float64Array.prototype.forEach()")}}</dt>
 <dd>配列内の各要素に対する関数を呼び出します。{{jsxref("Array.prototype.forEach()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.includes", "Float64Array.prototype.includes()")}}  {{experimental_inline}}</dt>
 <dd>typed arrayがある要素を含むかどうか判断し、それに応じて、<code>true</code> か <code>false</code>を返します。 {{jsxref("Array.prototype.includes()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.indexOf", "Float64Array.prototype.indexOf()")}}</dt>
 <dd>指定された値に等しい配列内の要素の最初のインデックスを返します。見つからない場合、-1を返します。{{jsxref("Array.prototype.indexOf()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.join", "Float64Array.prototype.join()")}}</dt>
 <dd>すべての配列要素を文字列に結合します。{{jsxref("Array.prototype.join()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.keys", "Float64Array.prototype.keys()")}}</dt>
 <dd>配列内の各インデックスに対するキーを含む新しい<code>Array Iterator</code>を返します。{{jsxref("Array.prototype.keys()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.lastIndexOf", "Float64Array.prototype.lastIndexOf()")}}</dt>
 <dd>指定された値と等しい配列の要素の最後のインデックスを返します。見つからない場合、-1を返します。{{jsxref("Array.prototype.lastIndexOf()")}}を確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.map", "Float64Array.prototype.map()")}}</dt>
 <dd>この配列のすべての要素で与えられた関数を呼び出した結果をもつ新しい配列を生成します。{{jsxref("Array.prototype.map()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.reduce", "Float64Array.prototype.reduce()")}}</dt>
 <dd>アキュムレータに対して関数を適用し、隣り合う二つのtyped arrayの要素(左から右へ)は単一の値になります。{{jsxref("Array.prototype.reduce()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.reduceRight", "Float64Array.prototype.reduceRight()")}}</dt>
 <dd>アキュムレータに対して関数を適用し、隣り合う二つのtyped arrayの要素(右から左へ)は単一の値になります。{{jsxref("Array.prototype.reduceRight()")}}を確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.reverse", "Float64Array.prototype.reverse()")}}</dt>
 <dd>配列要素の順番を反転させます。— 最初の要素は最後になり、最後の要素は最初になります。{{jsxref("Array.prototype.reverse()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.set", "Float64Array.prototype.set()")}}</dt>
 <dd>入力値を指定した配列から読み込み、typed array内に複数の値を格納します。</dd>
 <dt>{{jsxref("TypedArray.slice", "Float64Array.prototype.slice()")}}</dt>
 <dd>配列の一部を取り出して新しい配列を返します。{{jsxref("Array.prototype.slice()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.some", "Float64Array.prototype.some()")}}</dt>
 <dd>ある配列の少なくとも 1 つの要素が与えられたテスト関数を満たした場合にtrueを返します。{{jsxref("Array.prototype.some()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.sort", "Float64Array.prototype.sort()")}}</dt>
 <dd>配列の要素をソートし、その結果を返します。{{jsxref("Array.prototype.sort()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.subarray", "Float64Array.prototype.subarray()")}}</dt>
 <dd>与えられた開始位置と終了位置の要素インデックスの新しい<code>Float64Array</code> オブジェクトを返します。</dd>
 <dt>{{jsxref("TypedArray.values", "Float64Array.prototype.values()")}}</dt>
 <dd>配列内で各インデックスに対する値を含む新しい<code>Array Iterator</code>オブジェクトを返します。{{jsxref("Array.prototype.values()")}}を確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.toLocaleString", "Float64Array.prototype.toLocaleString()")}}</dt>
 <dd>配列と要素を表すローカライズされた文字列を返します。{{jsxref("Array.prototype.toLocaleString()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.toString", "Float64Array.prototype.toString()")}}</dt>
 <dd>配列と要素を表す文字列を返します。{{jsxref("Array.prototype.toString()")}}も確かめて下さい。</dd>
 <dt>{{jsxref("TypedArray.@@iterator", "Float64Array.prototype[@@iterator]()")}}</dt>
 <dd>配列内で各インデックスに対する値を含む新しい<code>Array Iterator</code>オブジェクトを返します。</dd>
</dl>

<h2 id="例">例</h2>

<pre class="brush: js">// From a length
var float64 = new Float64Array(2);
float64[0] = 42;
console.log(float64[0]); // 42
console.log(float64.length); // 2
console.log(float64.BYTES_PER_ELEMENT); // 8

// From an array
var arr = new Float64Array([21,31]);
console.log(arr[1]); // 31

// From another TypedArray
var x = new Float64Array([21, 31]);
var y = new Float64Array(x);
console.log(y[0]); // 21

// From an ArrayBuffer
var buffer = new ArrayBuffer(32);
var z = new Float64Array(buffer, 0, 4);

// From an iterable
var iterable = function*(){ yield* [1,2,3]; }();
var float64 = new Float64Array(iterable);
// Float64Array[1, 2, 3]</pre>

<h2 id="仕様">仕様</h2>

<table class="standard-table" style="line-height: 1.5;">
 <tbody>
  <tr>
   <th scope="col">仕様書</th>
   <th scope="col">策定状況</th>
   <th scope="col">コメント</th>
  </tr>
  <tr>
   <td>{{SpecName('Typed Array')}}</td>
   <td>{{Spec2('Typed Array')}}</td>
   <td>ECMAScript 6 で置き換えられました。</td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#table-49', 'TypedArray constructors')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td>ECMA 標準では最初の定義。<code>new</code> 演算子が必要なことが仕様書に含まれました。</td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#table-49', 'TypedArray constructors')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="ブラウザ実装状況">ブラウザ実装状況</h2>



<p>{{Compat("javascript.builtins.Float64Array")}}</p>

<h2 id="互換性について">互換性について</h2>

<p>ECMAScript 2015 (ES6)から、<code>Float64Array</code> コンストラクタでインスタンスを生成する場合、 {{jsxref("Operators/new", "new")}} 演算子が必要となります。 <code>Float64Array</code> を <code>new 演算子を使用せずに関数呼び出しした場合、</code>{{jsxref("TypeError")}} 例外が投げられるでしょう。</p>

<pre class="brush: js example-bad">var dv = Float64Array([1, 2, 3]);
// TypeError: calling a builtin Float64Array constructor
// without new is forbidden</pre>

<pre class="brush: js example-good">var dv = new Float64Array([1, 2, 3]);</pre>

<h2 id="関連情報">関連情報</h2>

<ul>
 <li><a href="/ja/docs/Web/JavaScript/Typed_arrays">JavaScript typed arrays</a></li>
 <li>{{jsxref("ArrayBuffer")}}</li>
 <li>{{jsxref("DataView")}}</li>
</ul>
