---
title: クラス式
slug: Web/JavaScript/Reference/Operators/class
tags:
  - Class
  - Classes
  - ECMAScript6
  - Expression
  - JavaScript
  - Operator
  - Reference
translation_of: Web/JavaScript/Reference/Operators/class
---
<div>{{jsSidebar("Operators")}}</div>

<p><span class="seoSummary"><strong>クラス式</strong>は、 ECMAScript 2015 でクラスを定義する方法の 1 つです。{{jsxref("Operators/function", "関数式", "", "true")}}と同じように、クラス式は名前を付けることも付けないこともできます。名前を付ける場合、クラス名はクラス内部のみのローカルです。</span></p>

<p>JavaScript のクラスはプロトタイプベースの継承が使われます。</p>

<div>{{EmbedInteractiveExample("pages/js/expressions-classexpression.html")}}</div>

<div class="hidden">このデモのソースファイルは GitHub リポジトリに格納されています。デモプロジェクトに協力したい場合は、 <a href="https://github.com/mdn/interactive-examples">https://github.com/mdn/interactive-examples</a> をクローンしてプルリクエストを送信してください。</div>

<h2 id="Syntax" name="Syntax">構文</h2>

<pre class="syntaxbox notranslate">const <var>MyClass</var> = class [<var>className</var>] [extends <var>otherClassName</var>] {
    // クラス本体
};</pre>

<h2 id="Description" name="Description">説明</h2>

<p>クラス式の構文は、{{jsxref("Statements/class", "クラス宣言 (文)", "", "true")}} と似ています。 <code>class</code> 文では、 <code>class</code> 式の本体が{{jsxref("Strict_mode", "厳格モード", "", 1)}}で実行されます。</p>

<p>しかし、クラス式と{{jsxref("Statements/class", "クラス文", "", "true")}}はいくつかの相違点があります。</p>

<ul>
 <li>クラス式ではクラス名 ("<ruby>束縛識別子<rp> (</rp><rt>binding identifier</rt><rp>) </rp></ruby>") を省略できますが、{{jsxref("Statements/class", "クラス文", "", "true")}}では省略できません。</li>
 <li>クラス式は {{jsxref("Global_Objects/SyntaxError", "SyntaxError")}} <strong>を発生させずに</strong>クラスを再宣言することができます。これは{{jsxref("Statements/class", "クラス文", "", "true")}}の場合はできません。</li>
</ul>

<p><code>constructor</code> メソッドは省略可能です。クラス式で生成されたクラスは、常に {{jsxref("Operators/typeof", "typeof")}} が "<code>function</code>" の値を返します。</p>

<pre class="brush: js notranslate">'use strict';
let Foo = class {};  // コンストラクタープロパティは省略可能
Foo = class {};      // 再宣言が可能

typeof Foo;             // "function" を返す
typeof class {};        // "function" を返す

Foo instanceof Object;   // true
Foo instanceof Function; // true
class Foo {}            // SyntaxError が発生 (クラス<em>宣言</em>は再宣言ができない)
</pre>

<h2 id="Examples" name="Examples">例</h2>

<h3 id="A_simple_class_expression" name="A_simple_class_expression">簡単なクラス式</h3>

<p>以下は、名前のない簡単なクラス式です。変数 <code>Foo</code> を使って参照できます。</p>

<pre class="brush: js notranslate">const Foo = class {
  constructor() {}
  bar() {
    return 'Hello World!';
  }
};

const instance = new Foo();
instance.bar();  // "Hello World!"
Foo.name;        // "Foo"
</pre>

<h3 id="Named_class_expressions" name="Named_class_expressions">名前付きクラス式</h3>

<p>クラス内部で現在のクラスを参照したい場合は、<em>名前付きクラス式</em>を作成してください。この名前は、そのクラス式自身のスコープ内だけで見ることができます。</p>

<pre class="brush: js notranslate">const Foo = class NamedFoo {
  constructor() {}
  whoIsThere() {
    return NamedFoo.name;
  }
}
const bar = new Foo();
bar.whoIsThere();  // "NamedFoo"
NamedFoo.name;     // ReferenceError: NamedFoo is not defined
Foo.name;          // "NamedFoo"
</pre>

<h2 id="Specifications" name="Specifications">仕様書</h2>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">仕様書</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-class-definitions', 'Class definitions')}}</td>
  </tr>
 </tbody>
</table>

<h2 id="Browser_compatibility" name="Browser_compatibility">ブラウザーの互換性</h2>

<p>{{Compat("javascript.operators.class")}}</p>

<h2 id="See_also" name="See_also">関連情報</h2>

<ul>
 <li>{{jsxref("Operators/function", "関数式", "", "true")}}</li>
 <li>{{jsxref("Statements/class", "クラス宣言", "", "true")}}</li>
 <li>{{jsxref("Classes", "クラス", "", "true")}}</li>
</ul>
