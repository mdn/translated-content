---
title: 符号なし右シフト演算子 (>>>)
slug: Web/JavaScript/Reference/Operators/Unsigned_right_shift
l10n:
  sourceCommit: fad67be4431d8e6c2a89ac880735233aa76c41d4
---

**符号なし右シフト演算子 (`>>>`)** は、 1 つ目のオペランドを指定されたビット数だけ右にずらしたバイナリー表現を持つ、数値または長整数を返します。右にずらしてあふれたビットは破棄され、 0 のビットが左からずれて入ります。この演算は「ゼロ埋め右シフト」とも呼ばれます。符号ビットが `0` になるため、結果の数値は常に正の値となるからです。符号なし右シフトは[長整数](/ja/docs/Web/JavaScript/Reference/Global_Objects/BigInt)の値を受け入れません。

{{InteractiveExample("JavaScript デモ: 符号なし右シフト演算子 (>>>)", "shorter")}}

```js interactive-example
const a = 5; //  00000000000000000000000000000101
const b = 2; //  00000000000000000000000000000010
const c = -5; //  11111111111111111111111111111011

console.log(a >>> b); //  00000000000000000000000000000001
// 予想される結果: 1

console.log(c >>> b); //  00111111111111111111111111111110
// 予想される結果: 1073741822
```

## 構文

```js-nolint
x >>> y
```

## 解説

他の算術演算子やビット演算子とは異なり、符号なし右シフト演算子は[長整数](/ja/docs/Web/JavaScript/Reference/Global_Objects/BigInt)の値を受け入れません。これは、左端のビットをゼロで埋めるためですが、概念的には長整数は無限の数の先頭符号ビットを持つため、ゼロで埋める「左端のビット」が存在しないためです。

この演算子は、左オペランドのビット表現を [2 の補数](https://ja.wikipedia.org/wiki/2の補数)で演算します。 10 進数の `9` と `-9` の 32 ビット 2 進表現を考えてみましょう。

```plain
     9 (10 進数): 00000000000000000000000000001001 (2 進数)
    -9 (10 進数): 11111111111111111111111111110111 (2 進数)
```

2 の補数法における負の 10 進数値 `-9` の 2 進表現は、その絶対値である `9` （2 進数で `00000000000000000000000000001001`）のすべてのビットを反転させ、 `1` を加算することで形成します。

どちらの場合も、 2 進数値の符号は最左端のビットによって指定されます。正の 10 進数 `9` の場合、 2 進表現の最左端ビットは `0` であり、負の 10 進数 `-9` の場合、 2 進表現の最左端ビットは `1` です。

10 進数の `9` と `-9` の 2 進表現が指定された場合を見てみましょう。

正の値 `9` に対して、ゼロ埋め右シフトと[符号伝播右シフト](/ja/docs/Web/JavaScript/Reference/Operators/Right_shift) は同じ結果を返します：`9 >>> 2` は `2` を返し、`9 >> 2` と同じになります。

```plain
      9 (10 進数): 00000000000000000000000000001001 (2 進数)
                   --------------------------------
9 >>  2 (10 進数): 00000000000000000000000000000010 (2 進数) = 2 (10 進数)
9 >>> 2 (10 進数): 00000000000000000000000000000010 (2 進数) = 2 (10 進数)
```

右端の 2 ビットである `01` がずれて外れ、 2 つのゼロが左から入るということに注目してください。

しかし、 `-9` で起こることに注目してください。 `-9 >> 2` （[符号伝播右シフト](/ja/docs/Web/JavaScript/Reference/Operators/Right_shift)）は `-3` になりますが、 `-9 >>> 2` （ゼロ埋め右シフト）は 1073741821 になります。

```plain
      -9 (10 進数): 11111111111111111111111111110111 (2 進数)
                    --------------------------------
-9 >>  2 (10 進数): 11111111111111111111111111111101 (2 進数) = -3 (10 進数)
-9 >>> 2 (10 進数): 00111111111111111111111111111101 (2 進数) = 1073741821 (10 進数)
```

右端の 2 ビットである `11` がずれて消えていることに注目してください。`-9 >> 2`（[符号伝播右シフト](/ja/docs/Web/JavaScript/Reference/Operators/Right_shift)) では、左端の `1` ビットが左から2つコピーされて入ってくるため、これにより負の符号が保持されます。一方、`-9 >>> 2`（ゼロ埋め右シフト）では、代わりに左側からゼロが入ってくるので、数値の負の符号は保持されず、結果は（大きな）正の値となります。

左オペランドが 32 ビットを超える数値の場合、上位側のビットが破棄されます。例えば、以下の 32 ビットを超える整数は 32 ビット整数に変換されます。

```plain
Before: 11100110111110100000000000000110000000000001
After:              10100000000000000110000000000001
```

右オペランドは符号なし 32 ビット整数に変換され、その後モジュロ 32 が取られます。したがって、実際のシフト量は常に 0 以上 31 以下の正の整数とみなされます。例えば、`100 >>> 32` は `100 >>> 0` と同じ結果 (`100`) になります。これは 32 モジュロ 32 が 0 となるためです。

## 例

### 符号なし右シフトの使用

```js
9 >>> 2; // 2
-9 >>> 2; // 1073741821
```

符号なし右シフトは、長整数では動作しません。

```js
9n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead
```

## 仕様書

{{Specifications}}

## ブラウザーの互換性

{{Compat}}

## 関連情報

- [ビット演算子 (JavaScript ガイド)](/ja/docs/Web/JavaScript/Guide/Expressions_and_operators#ビット演算子)
- [符号なし右シフト代入演算子 (`>>>=`)](/ja/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift_assignment)
