---
title: 右シフト演算子 (>>)
slug: Web/JavaScript/Reference/Operators/Right_shift
l10n:
  sourceCommit: fad67be4431d8e6c2a89ac880735233aa76c41d4
---

**右シフト演算子 (`>>`)** は、 1 つ目のオペランドを指定されたビット数だけ右にずらしたバイナリー表現を持つ、数値または長整数を返します。右にずらしてあふれたビットは破棄され、最も左のビットをコピーして入ります。この演算は「符号伝播右シフト」または「算術右シフト」とも呼ばれています。これは結果の数値の符号が 1 つ目のオペランドの符号と同じであるためです。

{{InteractiveExample("JavaScript デモ: 右シフト演算子 (>>)", "shorter")}}

```js interactive-example
const a = 5; //  00000000000000000000000000000101
const b = 2; //  00000000000000000000000000000010
const c = -5; //  11111111111111111111111111111011

console.log(a >> b); //  00000000000000000000000000000001
// 予想される結果: 1

console.log(c >> b); //  11111111111111111111111111111110
// 予想される結果: -2
```

## 構文

```js-nolint
x >> y
```

## 解説

`>>` 演算子は、数値と[長整数](/ja/docs/Web/JavaScript/Reference/Global_Objects/BigInt)の 2 種類のオペランドに対してオーバーロードされています。数値の場合、この演算子は 32 ビット整数を返します。 長整数の場合、演算子は長整数を返します。最初の両オペランドを数値型に変換し、それらの型を検査します。両オペランドが長整数になった場合、長整数の右シフトを実行します。そうでない場合、両オペランドを [32 ビット整数](/ja/docs/Web/JavaScript/Reference/Global_Objects/Number#固定長数値への変換)に変換し、数値の右シフトを実行します。一方のオペランドが長整数になり、もう一方が数値になった場合、 {{jsxref("TypeError")}} が発生します。

最も左のビットが以前の最も左のビットと同じになるため、符号ビット (最も左のビット) は変化しません。よって「符号維持」という名前です。

この演算子は、左オペランドのビット表現を [2 の補数](https://ja.wikipedia.org/wiki/2の補数)で演算します。 10 進数の `9` と `-9` の 32 ビット 2 進表現を考えてみましょう。

```plain
     9 (10 進数): 00000000000000000000000000001001 (2 進数)
    -9 (10 進数): 11111111111111111111111111110111 (2 進数)
```

2 の補数法における負の 10 進数値 `-9` の 2 進表現は、その絶対値である `9` （2 進数で `00000000000000000000000000001001`）のすべてのビットを反転させ、 `1` を加算することで形成します。

どちらの場合も、 2 進数値の符号は最左端のビットによって指定されます。正の 10 進数 `9` の場合、 2 進表現の最左端ビットは `0` であり、負の 10 進数 `-9` の場合、 2 進表現の最左端ビットは `1` です。

10 進数の `9` と `-9` の 2 進表現が指定された場合を見てみましょう。

`9 >> 2` は 2 となります。

```plain
     9 (10 進数): 00000000000000000000000000001001 (2 進数)
                  --------------------------------
9 >> 2 (10 進数): 00000000000000000000000000000010 (2 進数) = 2 (10 進数)
```

右端の 2 ビットである `01` がずれて外れ、左端のビット `0` が左から 2 回コピーされるということに注目してください。

`-9 >> 2` は `-3` となります。

```plain
     -9 (10 進数): 11111111111111111111111111110111 (2 進数)
                   --------------------------------
-9 >> 2 (10 進数): 11111111111111111111111111111101 (2 進数) = -3 (10 進数)
```

右端の 2 ビットである `11` がずれて消えていることに注目してください。しかし左端のビットについては、この場合左端ビットは `1` です。つまり左端の `1` ビットが 2 つ、左からずれて入ってきたことになります。これにより負の符号が保持されます。

2 進表現 `1111111111111111111111111111101` は、負の 10 進数値 `-3` に等しくなります。らすべての負の整数は [2 の補数](https://ja.wikipedia.org/wiki/2の補数)として格納されます。正の値（10 進数） `3` の 2 進表現 `00000000000000000000000000000011` のすべてのビットを反転し、 1 を加算することで算出することができます。

左オペランドが 32 ビットを超える数値の場合、上位側のビットが破棄されます。例えば、以下の 32 ビットを超える整数は 32 ビット整数に変換されます。

```plain
Before: 11100110111110100000000000000110000000000001
After:              10100000000000000110000000000001
```

右オペランドは符号なし 32 ビット整数に変換され、その後モジュロ 32 が取られます。したがって、実際のシフト量は常に 0 以上 31 以下の正の整数とみなされます。例えば、`100 >> 32` は `100 >> 0` と同じ結果 (`100`) になります。これは 32 モジュロ 32 が 0 となるためです。

> [!WARNING]
> 整数に切り詰めるために `>> 0` を使用する例を見かけるかもしれません。任意の数値 `x` を `0` ビット右シフトすると、`x` が 32 ビット整数に変換され、さらに -2147483648 から 2147483647 の範囲外の数の先行ビットが除去された結果が得られます。代わりに[`Math.trunc()`](/ja/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#ビット単位の_no-op_を使った数値の切り捨て)を使用してください。

長整数では切り捨ては発生しません。概念的には、正の長整数は先頭に無限の `0` ビットを持ち、負の長整数は先頭に無限の `1` ビットを持つと解釈します。

## 例

### 右シフトの使用

```js
9 >> 2; // 2
-9 >> 2; // -3

9n >> 2n; // 2n
```

## 仕様書

{{Specifications}}

## ブラウザーの互換性

{{Compat}}

## 関連情報

- [ビット演算子 (JavaScript ガイド)](/ja/docs/Web/JavaScript/Guide/Expressions_and_operators#ビット演算子)
- [右シフト代入演算子 (`>>=`)](/ja/docs/Web/JavaScript/Reference/Operators/Right_shift_assignment)
- [符号なし右シフト演算子 (`>>>`)](/ja/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift)
