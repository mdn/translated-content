---
title: パッケージ管理の基本
short-title: パッケージ管理
slug: Learn_web_development/Extensions/Client-side_tools/Package_management
l10n:
  sourceCommit: 48d220a8cffdfd5f088f8ca89724a9a92e34d8c0
---

{{PreviousMenuNext("Learn_web_development/Extensions/Client-side_tools/Overview","Learn_web_development/Extensions/Client-side_tools/Introducing_complete_toolchain", "Learn_web_development/Extensions/Client-side_tools")}}

この記事では、パッケージマネージャーを詳細に見て、プロジェクトツールの依存関係をインストールし、それらを最新の状態に保つなど、独自のプロジェクトでパッケージマネージャーを使用する方法を理解します。

<table>
  <tbody>
    <tr>
      <th scope="row">前提条件:</th>
      <td>
        主要な <a href="/ja/docs/Learn_web_development/Core/Structuring_content">HTML</a>、<a href="/ja/docs/Learn_web_development/Core/Styling_basics">CSS</a>、と <a href="/ja/docs/Learn_web_development/Core/Scripting">JavaScript</a> 言語
      </td>
    </tr>
    <tr>
      <th scope="row">目標:</th>
      <td>
        パッケージマネージャーとパッケージリポジトリーとは何か、必要な理由や使用方法の基本を理解する。
      </td>
    </tr>
  </tbody>
</table>

## プロジェクトの依存関係

**依存関係**とは、サードパーティ製のソフトウェアであり、おそらく他の誰かによって作成されたものであり、理想的には 1 つの問題を解決してくれます。ウェブプロジェクトには、0 から多数の範囲で任意の数の依存関係を含めることができます。また依存関係には、明示的にインストールしていないサブ依存関係が含まれる場合があります。依存関係には、独自の依存関係がある場合があります。

プロジェクトで必要になる可能性のある便利な依存関係の簡単な例は、相対日付を人間が判読できるテキストとして計算するコードです。もちろん自分でコーディングすることもできますが、他の誰かがすでにこの問題を解決している可能性が高いです。さらに、信頼できるサードパーティの依存関係は、さまざまな状況でテストされている可能性が高く、独自のソリューションよりも堅牢でクロスブラウザー互換性があります。

プロジェクトの依存関係は、React や Vue などの JavaScript ライブラリーまたはフレームワーク全体、または人間が読める日付ライブラリーのような非常に小さなユーティリティ、または以前の記事で説明した Prettier や ESLint などのコマンドラインツールである可能性があります。

最新のビルドツールがなければ、単純な [`<script>`](/ja/docs/Web/HTML/Reference/Elements/script) 要素を使用して、このような依存関係をプロジェクトに含めることができますが、これはすぐには機能しない可能性があります。また、コードと依存関係がウェブ上にリリースされるときに、コードと依存関係を一緒にバンドルするための最新のツールが必要になる可能性があります。バンドルとは、通常、ソフトウェアのすべての JavaScript を含むウェブサーバー上の単一のファイルを指すために使用される用語です。通常、ソフトウェアをダウンロードしてブラウザーの訪問者に表示にかかる時間を短縮するために、可能な限り圧縮されています。

さらに、現在のツールの代わりに使用したいより良いツールを見つけた場合、または更新したい依存関係の新しいバージョンがリリースされた場合はどうなりますか? これは、いくつかの依存関係についてはそれほど苦痛ではありませんが、多くの依存関係がある大規模なプロジェクトでは、この種のことを追跡するのが非常に困難になる可能性があります。npm などの **パッケージマネージャー** を使用する方が理にかなっています。これにより、コードがクリーンに追加および削除され、他の多くの利点が得られることが保証されます。

## パッケージマネージャーとは正確には何ですか？

[npm](https://www.npmjs.com/) については既に触れましたが、npm 自体から離れて、パッケージマネージャーはプロジェクトの依存関係を管理するシステムです。

パッケージマネージャーは、新しい依存関係 (「パッケージ」とも呼ばれます) をインストールする方法を提供し、ファイルシステム上のパッケージの保存場所を管理し、独自のパッケージを公開する機能を提供します。

理論的には、パッケージマネージャーは必要なく、プロジェクトの依存関係を手動でダウンロードして保存することもできますが、パッケージマネージャーはパッケージのインストールとアンインストールをシームレスに処理します。使用していない場合は、手動で処理する必要があります。

- すべての正しいパッケージ JavaScript ファイルの検索。
- それらをチェックして、既知の脆弱性がないことを確認します。
- それらをダウンロードして、プロジェクト内の正しい場所に配置します。
- アプリケーションにパッケージを含めるためのコードを作成します (これは、よく読んで理解する価値のあるもう 1 つの主題である [JavaScript モジュール](/ja/docs/Web/JavaScript/Guide/Modules) モジュールを使用して行われます)。
- すべてのパッケージのサブ依存関係 (数十または数百になる可能性があります) に対して同じことを行います。
- パッケージを削除する場合は、すべてのファイルを再度削除します。

さらに、パッケージマネージャーは重複した依存関係 (フロントエンド開発で重要かつ一般的になるもの) を処理します。

npm (と JavaScript と Node ベースのパッケージマネージャー) の場合、依存関係をインストールする場所には 2 つのオプションがあります。前回の記事で触れたように、依存関係はプロジェクトにグローバルまたはローカルにインストールできます。グローバルにインストールする方がメリットが多い傾向にありますが、コードの移植性やバージョンのロックなど、ローカルにインストールする方がより重要です。

たとえば、プロジェクトが特定の構成の webpack に依存している場合、そのプロジェクトを別のマシンにインストールしたり、後でそのプロジェクトに戻ったりした場合でも、構成が引き続き機能することを確認する必要があります。異なるバージョンの webpack がインストールされている場合、互換性がない可能性があります。これを軽減するために、依存関係がプロジェクトにローカルにインストールされます。

ローカルの依存関係が本当に輝いていることを確認するには、既存のプロジェクトをダウンロードして実行するだけです。ーそれが機能し、すべての依存関係が箱から出してすぐに機能する場合、コードが移植可能であるという事実に感謝するローカル依存関係があります。

> [!NOTE]
> 利用可能なパッケージマネージャーは npm だけではありません。成功し、人気のある代替パッケージマネージャーは [Yarn](https://yarnpkg.com/) です。Yarn は別のアルゴリズムを使用して依存関係を解決します。これは、より高速なユーザー エクスペリエンスを意味します。[pnpm](https://pnpm.js.org/) など、他の多くの新しいクライアントもあります。

## パッケージレジストリー

パッケージマネージャーが機能するには、どこからパッケージをインストールするかを知る必要があり、これはパッケージレジストリーの形式で提供されます。レジストリーは、パッケージが公開され、そこからインストールできる中心的な場所です。npm は、パッケージマネージャーであるだけでなく、JavaScript パッケージで最も一般的に使用されるパッケージ レジストリーの名前でもあります。npm レジストリーは [npmjs.com](https://www.npmjs.com/) にあります。

npm だけが選択肢ではありません。独自のパッケージ レジストリーを管理できます。[Microsoft Azure](https://azure.microsoft.com/) などの製品を使用すると、npm レジストリーへのプロキシーを作成できます (特定のパッケージをオーバーライドまたはロックできます)。[GitHub もパッケージレジストリーサービス提供しています。](https://docs.github.com/en/packages) であり、時間が経つにつれてより多くのオプションが表示される可能性があります。

重要なのは、自分に最適なレジストリーを選択したことを確認することです。多くのプロジェクトで npm が使用されるため、モジュールの残りの例ではこれに関係します。

## パッケージエコシステムの使用

パッケージマネージャーとレジストリーを使用してコマンドラインユーティリティをインストールするための例を見てみましょう。

[Vite](https://vite.dev/) を使用して、空白のウェブサイトを作成します。次の記事では、ツールチェーンを展開してより多くのツールを含め、サイトの展開方法について示します。

Vite は、実際のプロジェクトをすばやく始めるために、必要なすべての依存関係と構成を含むいくつかの [init テンプレート](https://vite.dev/guide/#scaffolding-your-first-vite-project) を提供しています。デモでは、[React テンプレート](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react) を参照して、 1 つをゼロから構成します。

### アプリを npm パッケージとしてセットアップする

まず、実験的なアプリを保存するための新しいディレクトリーを作成します。これを `npm-experiment` と呼びますが、好きなように呼ぶことができます。

```bash
mkdir npm-experiment
cd npm-experiment
```

次に、構成ファイル、`package.json` を作成する npm パッケージとしてアプリを初期化しましょう。これにより、後でこの環境を再作成したり、パッケージを npm レジストリーに公開したりする場合に備えて、構成の詳細を保存できます（ただし、この記事では、再利用可能なライブラリーではなくアプリケーションを開発しているため、これは関係ありません）。

`npm-experiment` ディレクトリー内で、次のコマンドを入力します。

```bash
npm init
```

これで、いくつかの質問が表示されます。 npm は、その回答に基づいて、既定の `package.json` ファイルを作成します。なお、これらはパッケージをレジストリーに公開し、他のユーザーがそれをインストールおよびインポートする場合にのみ使用されるため、今回の目的には関係ありません。

- `name`: アプリを識別するための名前です。既定の `npm-experiment` を受け入れるには、<kbd>Return</kbd> を押してください。
- `version`: アプリの開始バージョン番号です。ここでも、既定の `1.0.0` を受け入れるには、<kbd>Return</kbd> を押してください。
- `description`: アプリの目的を簡単に説明します。ここでは省略しますが、同様に何らかの説明を入力することもできます。<kbd>Return</kbd> を押します。
- `entry point`: 他のユーザーがパッケージをインポートしたときに実行される JavaScript ファイルです。ここでは使用しないので、<kbd>Return</kbd> を押します。
- `test command`、`git repository`、`keywords`: ここでは、それぞれを空白のままにして、<kbd>Return</kbd> を押してください。
- `author`: プロジェクトの作成者。自分の名前を入力し、<kbd>Return</kbd> を押してください。
- `license`: パッケージを公開するライセンス。ここでは、<kbd>Return</kbd> を押して既定のものをそのまま受け入れてください。

これらの設定を受け入れるためにもう一度 <kbd>Return</kbd> を入力します。

`npm-experiment` ディレクトリーに移動すると、package.json ファイルが作成されていることがわかります。それを開くと、次のようになります。

```json
{
  "name": "npm-experiment",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Your name",
  "license": "ISC"
}
```

package.json に 2 行を追加します。

- `"type": "module"` は、Node がすべての `.js` ファイルを、従来の CommonJS モジュールではなく [ES モジュール](/ja/docs/Web/JavaScript/Guide/Modules) として解釈するようにします。これは、一般的に良く知られた習慣です。
- `"private": true` は、パッケージを誤って npm レジストリーの公開すべきでないパッケージとして公開することを防ぎます。

`"name"` のすぐ下に、以下の行を追加してください。

```json
"name": "npm-experiment",
"type": "module",
"private": true,
```

これで、パッケージを定義する設定ファイルができました。これで、これで良いので、次に移りましょう。

### Vite のインストール

まず、ウェブサイト用のビルドツールである Vite をインストールします。これは、HTML、CSS、JavaScript ファイルを、ブラウザー用に最適化されたバンドルにまとめる役割を担います。

```bash
npm install --save-dev vite
```

それが完了したら、package.json ファイルを見てみましょう。npm が新しいフィールド `devDependencies` を追加したことがわかります。

```json
"devDependencies": {
  "vite": "^5.2.13"
}
```

これは npm マジックの一部です。将来、コードベースを別の場所、別のマシンに移動した場合、コマンドを実行して同じセットアップを再作成できます。 `npm install` を実行すると npm が依存関係を調べてインストールします。

1 つの欠点は、 Vite は `npm-experiment` アプリ内でのみ利用できることです。別のディレクトリーでは実行できません。しかし、その利点は欠点よりもはるかに大きいです。

`vite` を開発依存関係としてインストールすることを選んだことに注意してください。この違いはアプリケーションではほとんど問題になりませんが、ライブラリーの場合、他の人があなたのパッケージをインストールしても、Vite が暗黙的にインストールされないことを意味します。通常、アプリケーションでは、ソースコードでインポートされるパッケージはすべて実際の依存関係であり、開発に使用されるパッケージ（通常はコマンドラインツール）は開発依存関係となります。 `--save-dev` フラグを除去して、実際の依存関係をインストールしてください。

また、新しいファイルがいくつか作成されていることがわかります。

- `node_modules`: Vite を実行するために必要な依存関係ファイル。npm は、これらのファイルをすべてダウンロードしています。
- `package-lock.json`: `node_modules` ディレクトリを再現するために必要な正確な情報を格納するロックファイル。これにより、ロックファイルが変更されない限り、`node_modules` ディレクトリーは異なるマシンでも同じになります。

これらのファイルは npm によって管理されるため、気にする必要はありません。Git を使用している場合は、`node_modules` を `.gitignore` ファイルに追加してください。ただし、前述のように `package-lock.json` は、異なるマシン間で `node_modules` の状態を同期するために使用されるため、通常は残しておく必要があります。

### サンプルアプリのセットアップ

とにかく、セットアップを続けます。

Vite では、`index.html` ファイルが最前面に配置されます。このファイルはアプリの開始点を定義し、Vite はこのファイルを使用して、アプリを構築するために必要な他のファイルを探します。 `index.html` ファイルを `npm-experiment` ディレクトリーに作成し、次のコンテンツを記入してください。

```html
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>テストページ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

`<script>` 要素は、アプリの JavaScript ロジックのエントリーポイントを宣言する `src/main.jsx` というファイルへの依存関係を作成することに注意してください。 `src` フォルダーを作成し、このフォルダー内に `main.jsx` を作成しますが、これについては、ここでは空白のままにしておきます。

> [!NOTE]
> 属性 [`type="module"`](/ja/docs/Web/HTML/Reference/Elements/script/type) が重要です。これは、スクリプトを ES モジュールとして扱うようブラウザーに指示し、 `import` および `export` 構文を JavaScript コードで使用できるようにします。ファイル拡張子は `.jsx` です。これは、次の記事で React JSX 構文を追加するためです。ブラウザーは JSX を理解しませんが、Vite はそれを、ブラウザーが理解できる通常の JavaScript に変換します。

### Vite を楽しむ

これで、新しくインストールした Vite ツールを実行できます。端末で、次のコマンドを実行してください。

```bash
npx vite
```

端末に、次のような内容が表示されます。

```plain
VITE v5.2.13  ready in 326 ms

➜  Local:   http://localhost:5173/
➜  Network: use --host to expose
➜  press h + enter to show help
```

これで、 JavaScript パッケージのエコシステムをフルに活用できる準備が整いました。まず、 `http://localhost:5173` でローカルウェブサーバーが実行されています。今のところ何も表示されませんが、このサーバーの優れた点は、アプリに変更を加えると、 Vite がアプリを再構築してサーバーを自動的に更新するため、更新の効果を即座に確認できることです。
開発サーバーは、 <kbd>Ctrl</kbd> + <kbd>C</kbd> でいつでも停止でき、同じコマンドで再び開始できます。サーバーを実行したままにしておく場合は、新しい端末ウィンドウを開いて、それ以外のコマンドを実行できます。

それでは、ページコンテンツを作成しましょう。デモとして、ページにグラフを追加してみましょう。データ視覚化ライブラリーである [plotly.js](https://www.npmjs.com/package/plotly.js) パッケージを使用します。次のコマンドを実行してインストールしてください。

```bash
npm install plotly.js-dist-min
```

`--save-dev` フラグを使用せずにインストールしていることに注意してください。前述のように、これは、このパッケージをコマンドラインツールとしてだけでなく、ソースコードでも実際に使用するためです。このコマンドにより、新しい `"dependencies"` オブジェクトが `package.json` ファイルに追加され、その中に `plotly.js-dist-min` が含まれます。

> [!NOTE]
> ここでは、この課題を行うために必要なパッケージを選べます。自分自身でコードを書く場合は、依存関係を探してインストールする際に、次の質問について考えてみてください。
>
> - 依存関係はまったく必要ですか？組み込み機能で対応可能ですか、それとも自分で書くほど単純なものですか？
> - 具体的に何をする必要があるのでしょうか？詳細を記載するほど、必要な機能を正確に果たすパッケージを見つけやすくなります。npm または Google でキーワードを検索してください。また、大きなパッケージはインストールや実行時にパフォーマンスの問題が発生する可能性があるため、小さなパッケージを優先してください。
> - 依存関係は信頼でき、よく保守されていますか？最後のバージョンが公開された時期、作成者、パッケージの 1 週間のダウンロード数を調べます。パッケージの信頼性を判断するには、パッケージの更新の必要性や、そのパッケージを必要とするユーザーの数など、さまざまな要素を考慮する必要があるため、使い勝手による経験が重要です。

`src/main.jsx` ファイルに次のコードを追加して保存します。

```js
import Plotly from "plotly.js-dist-min";

const root = document.getElementById("root");
Plotly.newPlot(
  root,
  [
    {
      x: [1, 2, 3, 4, 5],
      y: [1, 2, 4, 8, 16],
    },
  ],
  {
    margin: { t: 0 },
  },
);
```

`http://localhost:5173` に戻ると、ページにグラフが表示されます。さまざまな数値を変更すると、ファイルを保存するたびにグラフが更新されます。

### 本番用コードの構築

しかし、このコードは本番環境にはまだ使用できません。 Vite を含むほとんどのビルドツールシステムには、「開発モード」と「本番モード」があります。重要な違いは、開発で使用する便利な機能の多くは、最終的なサイトでは必要ないため、本番環境では削除されることです。例えば、「ホットモジュール置換」、「ライブリロード」、「圧縮されていないコメント付きのソースコード」などです。これらは、すべてではありませんが、開発段階ではとても役立つが、本番環境ではあまり有用ではない、一般的なウェブ開発機能の一部です。本番環境では、これらの機能はサイトを肥大化させるだけになります。

これで、<kbd>Ctrl</kbd> + <kbd>C</kbd> を使用して、実行中の Vite dev サーバーを停止します。

これで、架空の展開用の基本的なサイト例を準備することができます。 Vite には、公開に適したファイルを生成するための追加の `build` コマンドが用意されています。

次のコマンドを実行します。

```bash
npx vite build
```

次のような出力が表示されます。

```plain
vite v5.2.13 building for production...
✓ 6 modules transformed.
dist/index.html                    0.32 kB │ gzip:     0.24 kB
dist/assets/index-BlYAJQFz.js  3,723.18 kB │ gzip: 1,167.74 kB

(!) Some chunks are larger than 500 kB after minification. Consider:
- Using dynamic import() to code-split the application
- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks
- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.
✓ built in 4.36s
```

Vite は `dist` というディレクトリーを作成します。その中を見ると、ルートディレクトリーとよく似た `index.html` ファイルがあります。ただし、`script` のソースが `assets` フォルダーへのパスに置き換えられています。`assets` フォルダーには、変換された JavaScript 出力が格納されています。この出力は、縮約され、実運用用に最適化されています。

> [!NOTE]
> 大きすぎる塊がある、という警告が表示されて心配になるかもしれません。これは、裏で多くのことを行うライブラリーを読み込んでいるためです（同じグラフを描画するためのコードをすべて自分で書くことを想像してみてください）。今のところ、これについて心配する必要はありません。

## パッケージマネージャークライアントの大まかなガイド

このチュートリアルでは npm を使用して Vite パッケージをインストールしましたが、前述のようにいくつかの代替手段があります。少なくともそれらが存在することを知って、ツール間で共通のコマンドについて漠然とした考えを持つことは価値があります。すでにいくつかの動作を見てきましたが、他のものを見てみましょう。

リストは時間の経過とともに増加しますが、執筆時点では、次の主要なパッケージマネージャーが利用可能です。

- npm at [npmjs.org](https://www.npmjs.com/)
- pnpm at [pnpm.js.org](https://pnpm.js.org/)
- Yarn at [yarnpkg.com](https://yarnpkg.com/)

npm と pnpm は、コマンド ラインの観点からは似ています。実際、pnpm は、npm が提供する引数オプションと完全に同等であることを目指しています。パッケージをダウンロードしてコンピューターに保存する方法が異なり、必要な全体的なディスク容量を削減することを目的としています。

以下の例では npm が示されていますが、pnpm を入れ替えると、コマンドが機能します。

多くの場合、インストールプロセスに関しては、yarn は npm よりも高速であると考えられています(マイレージは異なる場合があります)。依存関係のインストール(およびコンピューターへのコピー)を待つためにかなりの時間が浪費される可能性があるため、これは開発者にとって重要です。

> [!NOTE]
> npm コマンドと Yarn コマンドの両方を紹介します。これらは同じプロジェクトで実行することを意図したものではありません。 npm または Yarn のいずれかでプロジェクトを設定し、そのパッケージマネージャーのコマンドを一貫して使用してください。

### 新しいプロジェクトを初期化する

```bash
npm init
yarn init
```

上記のように、これにより一連の質問が表示され、プロジェクトを説明するための一連の質問(名前、ライセンス、説明など) が表示されます。`package.json` プロジェクトとその依存関係に関するメタ情報が含まれています。

### 依存関係のインストール

```bash
npm install vite
yarn add vite
```

上記の動作で `install` も見ました。これにより、 `vite` パッケージが、 `vite` 自体の依存関係とともに、 `node_modules` と呼ばれるサブディレクトリー内の作業ディレクトリーに直接追加されます。

デフォルトでは、このコマンドは `vite` の最新バージョンをインストールしますが、これも制御できます。`vites@4` を要求すると、最新の 4.x バージョン (4.5.3) が得られます。または、`vite@^4.0.0` を試すこともできます。これは、4.0.0 以降の最新バージョンを意味します。

### 依存関係の更新

```bash
npm update
yarn upgrade
```

これにより、現在インストールされている依存関係が調べられ、利用可能な更新がある場合は、パッケージで指定されている範囲内で更新されます。

範囲は、 `package.json` の依存関係のバージョンで指定され、 `date-fns@^2.0.1` — この場合、キャレット文字 `^` 2.0.1 以降、3.0.0 を除くすべてのマイナーおよびパッチリリースを意味します。

これは [semver](https://semver.org/) と呼ばれるシステムを使用して決定されます。このシステムはドキュメントから見ると少し複雑に見えるかもしれませんが、要約情報とバージョンが `MAJOR.MINOR.PATCH` 、たとえば 2.0.1 はメジャーバージョン 2 でパッチバージョン 1 です。semver 値を試す優れた方法は、[semver calculator](https://semver.npmjs.com/) を使用することです。

`npm update` は依存関係を `package.json` で定義された範囲を超えてアップグレードしないことを覚えておくことが重要です — これを行うには、そのバージョンを具体的にインストールする必要があります。

### その他のコマンド

[npm](https://docs.npmjs.com/cli-documentation/) および [yarn](https://classic.yarnpkg.com/en/docs/cli/) の個々のコマンドの詳細をオンラインで確認できます。繰り返しますが、[pnpm](https://pnpm.io/cli/add) コマンドは npm と同等であり、いくつかの追加があります。

## 独自のコマンドを作成する

パッケージマネージャーは、コマンドラインから自分自身でコマンドを作成して実行することも対応しています。たとえば、前回は `npx` に対応するコマンド `vite` を呼び出して Vite 開発サーバーを始めました。次のようなコマンドを作成することができます。

```bash
npm run dev
# or yarn run dev
```

これにより、プロジェクトを「開発モード」で開始するためのカスタム スクリプトが実行されます。実際、ローカルでの開発セットアップは本番環境での実行方法とは若干異なる傾向があるため、すべてのプロジェクトにこれを定期的に含めています。

以前のテストプロジェクトでこれを実行しようとすると、「dev スクリプトが見つかりません」というメッセージが表示されるでしょう。これは、npm、Yarn （および同様のもの）が、 `package.json` ファイルの `scripts` プロパティで `dev` というプロパティを探しているためです。そこで、 `package.json` に独自の短縮コマンド「dev」を作成しましょう。先のチュートリアルに従った場合、npm-experiment ディレクトリー内に `package.json` ファイルが存在しているはずです。このファイルを開くと、 `scripts` メンバーは次のように見えるはずです。

```json
"scripts": {
  "test": "echo \"Error: no test specified\" && exit 1",
},
```

次のように更新し、ファイルを保存します。

```json
"scripts": {
  "dev": "vite"
},
```

カスタム `dev` コマンドを npm スクリプトとして追加しました。

端末で次のコマンドを実行してみてください。`npm-experiment` ディレクトリー内にいることを確認してください。

```bash
npm run dev
```

これで Vite が起動し、先ほどと同じローカル開発サーバーが起動するはずです。
ここで定義したスクリプトは、`npx` という接頭辞が不要になったことに注意してください。これは、npm （および yarn）コマンドが、従来の方法 (通常、コンピューターがソフトウェアを格納し、検索できるようにする場所) でコマンドラインツールを検索する前に、プロジェクトにローカルにインストールされているコマンドラインツールを検索するという賢い仕組みになっているためです。 [`run` コマンドの技術的な複雑さについて詳しく学ぶ](https://docs.npmjs.com/cli/run-script/)ことができますが、ほとんどの場合、ご自身で作成したスクリプトは問題なく実行されます。

この具体的なものは不必要に見えるかもしれません — `npm run dev` は `npx vite` よりも入力する文字数が多いですが、これは一種の抽象化です。これにより、将来、環境変数の設定、一時ファイルの生成など、コマンドを複雑にすることなく、`dev` コマンドに作業を追加することができます。

`scripts` プロパティには、作業に役立つあらゆることを追加することができます。例えば、Vite がテンプレートで推奨しているものは次のとおりです。

```json
"scripts": {
  "dev": "vite",
  "build": "vite build",
  "preview": "vite preview"
},
```

## まとめ

これで、パッケージマネージャーのツアーは終了です。次のステップは、これまでに学んだことをすべて実践して、ツールチェーンのサンプルを構築することです。

## 関連情報

- [npm スクリプト リファレンス](https://docs.npmjs.com/cli/v8/using-npm/scripts/)
- [package.json リファレンス](https://docs.npmjs.com/cli/v8/configuring-npm/package-json/)

{{PreviousMenuNext("Learn_web_development/Extensions/Client-side_tools/Overview","Learn_web_development/Extensions/Client-side_tools/Introducing_complete_toolchain", "Learn_web_development/Extensions/Client-side_tools")}}
