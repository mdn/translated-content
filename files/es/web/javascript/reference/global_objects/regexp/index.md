---
title: RegExp
slug: Web/JavaScript/Reference/Global_Objects/RegExp
tags:
  - Clase
  - Expresiones Regulares
  - JavaScript
  - Referencia
  - RegExp
translation_of: Web/JavaScript/Reference/Global_Objects/RegExp
original_slug: Web/JavaScript/Referencia/Objetos_globales/RegExp
---
<div>{{JSRef}}</div>

<p>El objeto <strong><code>RegExp</code></strong> se utiliza para hacer coincidir texto con un patrón.</p>

<p>Para obtener una introducción a las expresiones regulares, lee el {{JSxRef("../Guide/Regular_Expressions", "capítulo sobre expresiones regulares")}} en la {{JSxRef("../Guide/Regular_Expressions", "Guía de JavaScript")}}.</p>

<h2 id="Descripción">Descripción</h2>

<h3 id="Notación_literal_y_constructor">Notación literal y constructor</h3>

<p>Hay dos formas de crear un objeto <code>RegExp</code>: una <em>notación literal</em> y un <em>constructor</em>.</p>

<ul>
 <li>Los parámetros de <strong>la notación literal</strong> se encierran entre barras y no utilizan comillas.</li>
 <li>Los parámetros de <strong>la función constructora</strong> no se encierran entre barras, pero utilizan comillas.</li>
</ul>

<p>Las siguientes tres expresiones crean el mismo objeto de expresión regular:</p>

<pre class="brush: js notranslate">let er = /ab+c/i; // notación literal
let er = new RegExp('ab+c', 'i') // constructor con patrón de cadena como primer argumento
let er = new RegExp(/ab+c/, 'i') // constructor con expresión regular literal como primer argumento (a partir de ECMAScript 6)
</pre>

<p>La notación literal da como resultado la compilación de la expresión regular cuando se evalúa la expresión. Utiliza la notación literal cuando la expresión regular permanecerá constante. Por ejemplo, si usas notación literal para construir una expresión regular usada en un bucle, la expresión regular no se volverá a compilar en cada iteración.</p>

<p>El constructor del objeto de expresión regular, por ejemplo, <code>new RegExp('ab+c')</code>, da como resultado la compilación en tiempo de ejecución de la expresión regular. Utiliza la función constructora cuando sepas que el patrón de expresión regular cambiará, o no conozcas el patrón y lo obtienes de otra fuente, tal como la entrada del usuario.</p>

<h3 id="Banderas_en_el_constructor">Banderas en el constructor</h3>

<p>A partir de ECMAScript 6, <code>new RegExp(/ab+c/, 'i')</code> ya no arroja un {{JSxRef("TypeError")}} (<code>"no puedes proporcionar banderas cuando construyes una expresión regular a partir de otra"</code>) cuando el primer argumento es una <code>RegExp</code> y el segundo argumento <code><var>flags</var></code> está presente. En su lugar, se crea una nueva <code>RegExp</code> a partir de los argumentos.</p>

<p>Cuando se utiliza la función constructora, las reglas de escape de cadenas normales (antes de los caracteres especiales con <code>\</code> cuando se incluyen en una cadena) son necesarias.</p>

<p>Por ejemplo, los siguientes son equivalentes:</p>

<pre class="brush: js notranslate">let er = /\w+/
let er = new RegExp('\\w+')
</pre>

<h3 id="Propiedades_de_expresiones_regulares_similares_a_Perl">Propiedades de expresiones regulares similares a Perl</h3>

<p>Ten en cuenta que varias de las propiedades de {{JSxRef("RegExp")}} tienen nombres largos y cortos (tipo Perl). Ambos nombres siempre se refieren al mismo valor. (Perl es el lenguaje de programación a partir del cual JavaScript modeló sus expresiones regulares). Consulta también las propiedades {{JSxRef("Características_Desaprobadas", "en desuso de RegExp", "#Propiedades_de_RegExp")}}</p>

<h2 id="Constructor">Constructor</h2>

<dl>
 <dt>{{JSxRef("Objetos_globales/RegExp/RegExp", "RegExp()")}}</dt>
 <dd>Crea un nuevo objeto <code>RegExp</code>.</dd>
</dl>

<h2 id="Propiedades_estáticas">Propiedades estáticas</h2>

<dl>
 <dt>{{JSxRef("RegExp.@@species", "get RegExp[@@species]")}}</dt>
 <dd>La función constructora utilizada para crear objetos derivados.</dd>
 <dt>{{JSxRef("RegExp.lastIndex")}}</dt>
 <dd>El índice en el que comenzará la siguiente búsqueda.</dd>
</dl>

<h2 id="Propiedades_de_la_instancia">Propiedades de la instancia</h2>

<dl>
 <dt>{{JSxRef("RegExp.prototype.flags")}}</dt>
 <dd>Una cadena que contiene las banderas del objeto <code>RegExp</code>.</dd>
 <dt>{{JSxRef("RegExp.prototype.dotAll")}}</dt>
 <dd>Si el "<code>.</code>" coincide con nuevas líneas o no.</dd>
 <dt>{{JSxRef("RegExp.prototype.global")}}</dt>
 <dd>Si se debe probar o no la expresión regular con todas las posibles ocurrencias en una cadena, o solo con la primera.</dd>
 <dt>{{JSxRef("RegExp.prototype.ignoreCase")}}</dt>
 <dd>Si se deben o no ignorar las mayúsculas/minúsculas al buscar en una cadena.</dd>
 <dt>{{JSxRef("RegExp.prototype.multiline")}}</dt>
 <dd>Si buscar o no en cadenas multilínea.</dd>
 <dt>{{JSxRef("RegExp.prototype.source")}}</dt>
 <dd>El texto del patrón.</dd>
 <dt>{{JSxRef("RegExp.prototype.sticky")}}</dt>
 <dd>Si la búsqueda es pegajosa o no.</dd>
 <dt>{{JSxRef("RegExp.prototype.unicode")}}</dt>
 <dd>Si las funciones Unicode están habilitadas o no.</dd>
</dl>

<h2 id="Métodos_de_instancia">Métodos de instancia</h2>

<dl>
 <dt>{{JSxRef("RegExp.prototype.compile()")}}</dt>
 <dd>(Re)compila una expresión regular durante la ejecución de un script.</dd>
 <dt>{{JSxRef("RegExp.prototype.exec()")}}</dt>
 <dd>Ejecuta una búsqueda de una coincidencia en su parámetro de cadena.</dd>
 <dt>{{JSxRef("RegExp.prototype.test()")}}</dt>
 <dd>Prueba una coincidencia en su parámetro de cadena.</dd>
 <dt>{{JSxRef("RegExp.prototype.toString()")}}</dt>
 <dd>Devuelve una cadena que representa el objeto especificado. Redefine el método {{JSxRef("Object.prototype.toString()")}}.</dd>
 <dt>{{JSxRef("RegExp.prototype.@@match()", "RegExp.prototype[@@match]()")}}</dt>
 <dd>Realiza la coincidencia con la cadena dada y devuelve el resultado de la coincidencia.</dd>
 <dt>{{JSxRef("RegExp.prototype.@@matchAll()", "RegExp.prototype[@@matchAll]()")}}</dt>
 <dd>Devuelve todas las coincidencias de la expresión regular con una cadena.</dd>
 <dt>{{JSxRef("RegExp.prototype.@@replace()", "RegExp.prototype[@@replace]()")}}</dt>
 <dd>Reemplaza las coincidencias en una cadena dada con una nueva subcadena.</dd>
 <dt>{{JSxRef("RegExp.prototype.@@search()", "RegExp.prototype[@@search]()")}}</dt>
 <dd>Busca la coincidencia en la cadena dada y devuelve el índice del patrón encontrado en la cadena.</dd>
 <dt>{{JSxRef("RegExp.prototype.@@split()", "RegExp.prototype[@@split]()")}}</dt>
 <dd>Divide la cadena dada en un arreglo separando la cadena en subcadenas.</dd>
</dl>

<h2 id="Ejemplos">Ejemplos</h2>

<h3 id="Usar_una_expresión_regular_para_cambiar_el_formato_de_los_datos">Usar una expresión regular para cambiar el formato de los datos</h3>

<p>El siguiente script usa el método {{JSxRef("String.prototype.replace()", "replace()")}} de la instancia {{JSxRef("Objetos_globales/String", "String")}} para hacer coincidir una nombre en el formato <em>primero último</em> y enviarlo en el formato <em>último, primero</em>.</p>

<p>En el texto de reemplazo, el script usa <code>$1</code> y <code>$2</code> para indicar los resultados de los correspondientes paréntesis coincidentes en el patrón de expresión regular.</p>

<pre class="brush: js notranslate">let er = /(\w+)\s(\w+)/
let str = 'John Smith'
let newstr = str.replace(er, '$2, $1')
console.log(newstr)
</pre>

<p>Esto muestra <code>"Smith, John"</code>.</p>

<h3 id="Uso_de_expresiones_regulares_para_dividir_líneas_con_diferentes_finales_de_líneasaltos_de_línea">Uso de expresiones regulares para dividir líneas con diferentes finales de línea/saltos de línea</h3>

<p>El final de línea predeterminado varía según la plataforma (Unix, Windows, etc.). La división de líneas proporcionada en este ejemplo funciona en todas las plataformas.</p>

<pre class="brush: js notranslate">let texto = 'Un poco de texto\ny un poco más\r\ny aún\reste es el final'
let lineas = texto.split(/\r\n|\r|\n/)
console.log(lineas) // logs [ 'Un poco de texto', 'y un poco más', 'y aún', 'este es el final' ]
</pre>

<p>Ten en cuenta que el orden de los patrones en la expresión regular es importante.</p>

<h3 id="Usar_expresiones_regulares_en_varias_líneas">Usar expresiones regulares en varias líneas</h3>

<pre class="brush: js notranslate">let s = '¡Por favor, sí\nhazme el día!'

s.match(/sí.*día/);
// Devuelve null

s.match(/sí[^]*día/);
// Devuelve ["sí\nhazme el día"]
</pre>

<h3 id="Usar_una_expresión_regular_con_la_bandera_pegajosa">Usar una expresión regular con la bandera pegajosa</h3>

<p>La bandera {{JSxRef("Objetos_globales/RegExp/sticky", "sticky")}} indica que la expresión regular realiza una coincidencia permanente en la cadena de destino al intentar hacer coincidir a partir de {{JSxRef("RegExp.prototype.lastIndex")}}.</p>

<pre class="brush: js notranslate">let str = '#foo#'
let regex = /foo/y

regex.lastIndex = 1
regex.test(str)      // true
regex.lastIndex = 5
regex.test(str)      // false (lastIndex se tiene en cuenta con una bandera pegajosa)
regex.lastIndex      // 0 (restablecer después de un error de coincidencia)</pre>

<h3 id="La_diferencia_entre_la_bandera_pegajosa_y_la_bandera_global">La diferencia entre la bandera pegajosa y la bandera global</h3>

<p>Con la bandera pegajosa <code>y</code>, la siguiente coincidencia tiene que ocurrir en la posición <code>lastIndex</code>, mientras que con la bandera global <code>g</code>, la coincidencia puede ocurrir en la posición <code>lastIndex</code> o posterior:</p>

<pre class="brush: js notranslate">er = /\d/y;
while (r = re.exec("123 456")) console.log(r, "Y er.lastIndex", er.lastIndex);

// [ '1', index: 0, input: '123 456', groups: undefined ] AND er.lastIndex 1
// [ '2', index: 1, input: '123 456', groups: undefined ] AND er.lastIndex 2
// [ '3', index: 2, input: '123 456', groups: undefined ] AND er.lastIndex 3
//   ... y no más coincidencias.</pre>

<p>Con la bandera global <code>g</code>, coincidirían los 6 dígitos, no solo 3.</p>

<h3 id="Expresión_regular_y_caracteres_Unicode">Expresión regular y caracteres Unicode</h3>

<p><code>\w</code> y <code>\W</code> solo coincide con caracteres basados en ASCII; por ejemplo, <code>a</code> a <code>z</code>, <code>A</code> a <code>Z</code>, <code>0</code> a <code>9</code> y <code>_</code>.</p>

<p>Para hacer coincidir caracteres de otros idiomas como Cirílico o Hebreo, usa <code>\u<var>hhhh</var></code>, donde <code><var>hhhh</var></code> es el Valor Unicode en hexadecimal.</p>

<p>Este ejemplo demuestra cómo se pueden separar los caracteres Unicode de una palabra.</p>

<pre class="brush: js notranslate">let texto = 'Образец texto на русском языке'
let regex = /[\u0400-\u04FF]+/g

let match = regex.exec(text)
console.log(match[0])        // registra 'Образец'
console.log(regex.lastIndex) // registra '7'

let match2 = regex.exec(texto)
console.log(match2[0])       // registra 'на' [no registró 'texto']
console.log(regex.lastIndex) // registra '15'

// y así sucesivamente
</pre>

<p>La función {{JSxRef("../Guide/Regular_Expressions/Unicode_Property_Escapes", "Escapes de propiedad Unicode")}} presenta una solución, al permitir una declaración tan simple como <code>\p{scx=Cyrl}</code>.</p>

<h3 id="Extraer_el_nombre_de_subdominio_de_la_URL">Extraer el nombre de subdominio de la URL</h3>

<pre class="brush: js notranslate">let url = 'http://xxx.dominio.com'
console.log(/[^.]+/.exec(url)[0].substr(7)) // registra 'xxx'
</pre>

<div class="blockIndicator note">
<p>En lugar de utilizar expresiones regulares para analizar las URL, normalmente es mejor utilizar el analizador de URL integrado en los navegadores mediante la <a href="/es/docs/Web/API/URL_API">API URL</a>.</p>
</div>

<h2 id="Especificaciones">Especificaciones</h2>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Especificación</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-regexp-regular-expression-objects', 'RegExp')}}</td>
  </tr>
 </tbody>
</table>

<h2 id="Compatibilidad_del_navegador">Compatibilidad del navegador</h2>

<div>


<p>{{Compat("javascript.builtins.RegExp")}}</p>
</div>

<h3 id="Notas_específicas_de_Firefox">Notas específicas de Firefox</h3>

<p>A partir de Firefox 34, en el caso de un grupo de captura con cuantificadores que impiden su ejercicio, el texto coincidente para un grupo de captura ahora es <code>undefined</code> en lugar de una cadena vacía:</p>

<pre class="brush: js notranslate">// Firefox 33 o anterior
'x'.replace(/x(.)?/g, function(m, group) {
  console.log("'grupo: " + group + "'");
});
// 'grupo: '

// Firefox 34 o más reciente
'x'.replace(/x(.)?/g, function(m, group) {
  console.log("'grupo: " + group + "'");
});
// 'grupo: undefined'
</pre>

<p>Ten en cuenta que, debido a la compatibilidad web, <code>RegExp.<var>$N</var></code> seguirá devolviendo una cadena vacía en lugar de <code>undefined</code> ({{bug(1053944)}}).</p>

<h2 id="Ve_también">Ve también</h2>

<ul>
 <li>El capítulo de {{JSxRef("../Guide/Regular_Expressions", "Expresiones regulares")}} en la {{JSxRef("../Guide", "Guía de JavaScript")}}</li>
 <li>{{JSxRef("String.prototype.match()")}}</li>
 <li>{{JSxRef("String.prototype.replace()")}}</li>
 <li>{{JSxRef("String.prototype.split()")}}</li>
</ul>
