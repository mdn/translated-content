---
title: Crear una extensión personalizada de Firefox con el Mozilla Build System
slug: Crear_una_extensión_personalizada_de_Firefox_con_el_Mozilla_Build_System
tags:
  - Complementos
  - Documentación_de_compilado
  - Todas_las_Categorías
  - XPCOM
  - extensiones
---
<p> </p>

<div class="note"><strong>Nota:</strong> Todas las instrucciones de este artículo sólo son aplicables a la rama 1.8 de Mozilla (p.e. Firefox 1.5). Intentaré mantener actualizada la versión estable aunque de hecho no deberías asumir que esto funcionará con la rama 1.5 (p.e, Firefox 1.0) o anteriores.</div>

<p>Existe una <a href="/es/Extensiones" title="es/Extensiones">infinidad de documentación</a> sobre la creación de extensiones para Firefox. Sin embargo, actualmente todos esos documentos asumen que estás desarrollando tu extensión utilizando únicamente <a href="/es/XUL" title="es/XUL">XUL</a> y <a href="/es/JavaScript" title="es/JavaScript">JavaScript</a>. Para las extensiones complejas puede ser necesario crear componentes en C++ que proporcionen funcionalidades adicionales. Las razones por las que podrías querer agregar componentes C++ en tu extensión incluyen:</p>

<ul>
 <li>La necesidad de un alto rendimiento más allá de lo que te ofrece el código JavaScript.</li>
 <li>El uso de bibliotecas de terceras partes escritas en C o en C++.</li>
 <li>El uso de interfaces de Mozilla que no están disponibles vía <a href="/es/XPCOM" title="es/XPCOM">XPCOM</a> (p.e, <a href="/es/NSPR" title="es/NSPR">NSPR</a>).</li>
</ul>

<p>Este artículo describe cómo configurar el entorno de desarrollo para una extensión de Firefox grande y compleja utilizando parcial o totalmente los requerimientos ya mencionados. El proceso de reunir esta información ha sido de algún modo un calvario debido a la falta de información publicada sobre este tema, aunque varios miembros de la comunidad de desarrolladores de Mozilla han colaborado en su creación. Ellos han mostrado una paciencia extraordinaria respondiendo preguntas típicas de novatos ignorantes. Me quedo corto si digo que estoy lejos de ser un experto de Mozilla, aunque voy mejorando. Puede que muchas partes de este documento sean imprecisas, confusas o simplemente incorrectas. De hecho, una de mis metas al escribir esto es afinar dichas instrucciones hasta que constituyan una guía definitiva para los hackers del núcleo que quieran ampliar la plataforma Firefox. Si tú eres uno de los muchos que saben más que yo sobre esto, tu ayuda mejorando este artículo será gratamente recibida.</p>

<p>También debería enfatizar que <em>no</em> tienes por qué compilar Mozilla o utilizar el sistema de compilación de Mozilla si quieres crear componentes C++ para Mozilla. Si sólo buscas crear un componente <a href="/es/XPCOM" title="es/XPCOM">XPCOM</a> o dos, este artículo será algo excesivo y puede que te interese mirar <a class="external" href="http://www.iosart.com/firefox/xpcom/">esta guía</a> en su lugar. Por otra parte, si tienes experiencia desarrollando o dirigiendo un equipo y sabes que tienes que desarrollar una extensión grande y compleja, probablemente hagas bien en considerar la aproximación descrita en este artículo.</p>

<p>Una última nota: sólo he probado dichas técnicas dentro de Firefox aunque probablemente funcionarán más o menos bien en otras plataformas basadas en Gecko como Thunderbird o SeaMonkey. Si alguien puede confirmar esto y/o suministrar guías de estilo para aquello en lo que difiere actualizaré el artículo para incorporar esta información.</p>

<h3 id="Y_Bambi_y_Mozilla_se_encontraron..." name="Y_Bambi_y_Mozilla_se_encontraron...">Y Bambi y Mozilla se encontraron...</h3>

<p>Nada en este artículo es para cobardes. En particular el primer paso conlleva la compilación de Mozilla, lo cual es un gran... no, un inmenso proyecto. Muchos desarrolladores inteligentes han sido llevados al borde de la locura intentando compilarlo por  primera vez. Si no tienes experiencia desarrollando C++ no deberías ni preocuparte. Sigue con JavaScript.</p>

<h4 id="Plataformas_Windows" name="Plataformas_Windows">Plataformas Windows</h4>

<p>La primera vez que compilé Mozilla utilicé <a href="/es/Prerrequisitos_de_compilaci%C3%B3n_en_Windows" title="es/Prerrequisitos_de_compilación_en_Windows">esta guía</a>. Ni siquiera puedo recordar por qué, pero me quedé pillado unas cuantas veces, aunque la odisea llevó más tiempo de lo que me había imaginado al principio. Me cargué los muebles y me arranqué el pelo. Aquí tienes una <a class="external" href="http://whereswalden.com/mozilla/msvcfree/">guía comprensiva rápida</a>, bien redactada. Sigue cada paso metódicamente y probablemente todo irá bien. Céntrate en el hecho de que una vez hayas completado la compilación, posiblemente el resto del trabajo no conllevará esfuerzo alguno. Posiblemente.</p>

<h4 id="Otras_plataformas" name="Otras_plataformas">Otras plataformas</h4>

<p>En otras plataformas, léase Linux y MacOS, el proceso es mucho más sencillo. Todas las herramientas para compilar están disponibles de forma integrada y por tanto todo lo que tienes que hacer es ejecutar algunas órdenes en el terminal. Puedes encontrar las instrucciones completas para casi cualquier SO <a href="/es/Documentaci%C3%B3n_de_compilaci%C3%B3n" title="es/Documentación_de_compilación">aquí</a>.</p>

<h3 id="Estructurar_tu_proyecto" name="Estructurar_tu_proyecto">Estructurar tu proyecto</h3>

<p>Mozilla incorpora un número de extensiones complejas que son integradas en su proceso de compilación. Es así que ha sido necesario resolver todos los problemas inherentes a la creación y registro de componentes XPCOM, a la compilación de ficheros JAR y los manifiestos; instalando el montón en el directorio <code>extensions</code> de Firefox y así sucesivamente. Así pues, lo mejor para nosotros es aprovecharnos de esta infraestructura para construir nuestra extensión.</p>

<p>Antes que nada, elige un nombre con gancho para tu extensión y crea un directorio con ese nombre bajo el directorio <code>/mozilla/extensions/</code>. Utiliza sólo minísculas. Deberías ver un montón de otros directorios (<code>inspector/</code>, <code>reporter/</code>, etc...) al mismo nivel del árbol de directorios.</p>

<p>Date cuenta  que antes de realmente construir nada, el sistema de desarrollo de Mozilla llama a un proceso que genera los makefiles usados por la compilación a partir de plantillas de makefiles llamadas <code>Makefile.in</code>. Los makefiles reales tienden a ser muy parecidos si no idénticos a las plantillas, pero la flexibilidad extra adquirida al obtener los makefiles generados dinámicamente es una de las cosas que hacen al sistema de compilación tan potente.</p>

<h4 id="Anatom.C3.ADa_de_una_simple_extensi.C3.B3n_en_C.2B.2B" name="Anatom.C3.ADa_de_una_simple_extensi.C3.B3n_en_C.2B.2B">Anatomía de una simple extensión en C++</h4>

<p>Asumiremos que estamos usando C++ para escribir componentes XPCOM que pueden ser usados tanto desde otros componentes C++ o desde JavaScript. El proceso de crear un componente es, en realidad, algo relativamente simple cuando se utiliza Mozilla Build System.</p>

<p>El caso más simple ocurre cuando un componente va a consistir en un único directorio principal con dos subdirectorios, <code>public/</code> y <code>src/</code>. El directorio principal y cada subdirectorio deben contener un <code>Makefile.in</code> (a partir de ahora me referiré a este fichero como un makefile aunque, como sabemos, en la práctica es usado para generar los makefiles reales). Este makefile dice dos cosas: lo primero: lista los subdirectorios que componen la extensión por lo que el sistema de compilación conoce dónde buscar los makefiles adicionales. Después dà las instrucciones para compilar el sistema que crea una nueva extensión, en lugar de copiar los componentes directamente en el directorio de binarios de Firefox. La principal ventaja de utilizar una extensión es que es fácil empaquetarlo todo e instalarlo en otra máquina.</p>

<p>Así pues, aquí tienes el makefile principal más básico y simplón que te puedas encontrar (<code>Makefile.in</code> en el directorio principal de la extensión):</p>

<pre>DEPTH		= ../..
topsrcdir	= @top_srcdir@
srcdir		= @srcdir@
VPATH		= @srcdir@

include $(DEPTH)/config/autoconf.mk

MODULE = myextension

DIRS		= public src

XPI_NAME		= myextension
INSTALL_EXTENSION_ID	= myextension@mycompany.com
XPI_PKGNAME		= myextension

DIST_FILES = install.rdf

include $(topsrcdir)/config/rules.mk
</pre>

<p>La descripción detallada del proceso de creación, describiendo las opciones clave de este makefile pueden ser encontradas <a href="/es/C%C3%B3mo_funciona_el_sistema_de_compilaci%C3%B3n_de_Mozilla" title="es/Cómo_funciona_el_sistema_de_compilación_de_Mozilla">aquí</a>. Tanto <strong>MODULE</strong> como <strong>XPI_NAME</strong> están asignados al nombre de tu extensión; deben aparecer repetidos en todos los makefiles del proyecto para que todos los ficheros acaben en el mismo lugar en el área de pruebas del XPI (ver más adelante). <strong>INSTALL_EXTENSION_ID</strong> es el ID único de tu extensión. Puede ser un GUID aunque el formato mostrado antes es más bonito y, asumámoslo, mucho más fácil de recordar. No tienes porqué proporcionar un <strong>XPI_PKGNAME</strong> aunque si creas un fichero XPI susceptible de ser distribuido, será creado automáticamente en el directorio raíz del área de pruebas del XPI (<code>/mozilla/$(MOZ_OBJDIR)/dist/xpi-stage/</code>).</p>

<p>Toda extensión debe incluir un fichero <code>install.rdf</code> que le diga a Firefox cómo instalarla. Este fichero debería estar ubicado en el directorio principal de la extensión y tener este aspecto:</p>

<pre>&lt;?xml version="1.0"?&gt;

&lt;RDF xmlns="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
     xmlns:em="http://www.mozilla.org/2004/em-rdf#"&gt;
  &lt;Description about="urn:mozilla:install-manifest"&gt;
    &lt;em:id&gt;myextension@mycompany.com&lt;/em:id&gt;
    &lt;em:version&gt;0.1&lt;/em:version&gt;

    &lt;em:targetApplication&gt;
      &lt;!-- Firefox --&gt;
      &lt;Description&gt;
        &lt;em:id&gt;{ec8030f7-c20a-464f-9b0e-13a3a9e97384}&lt;/em:id&gt;
        &lt;em:minVersion&gt;1.0+&lt;/em:minVersion&gt;
        &lt;em:maxVersion&gt;1.0+&lt;/em:maxVersion&gt;
      &lt;/Description&gt;
    &lt;/em:targetApplication&gt;

    &lt;!-- front-end metadata --&gt;
    &lt;em:name&gt;My First Extension&lt;/em:name&gt;
    &lt;em:description&gt;Just an example.&lt;/em:description&gt;
    &lt;em:creator&gt;allpeers.com&lt;/em:creator&gt;
    &lt;em:homepageURL&gt;http://www.allpeers.com/blog/&lt;/em:homepageURL&gt;
  &lt;/Description&gt;
&lt;/RDF&gt;
</pre>

<p>Existe una <a href="/es/Manifiestos_de_instalaci%C3%B3n" title="es/Manifiestos_de_instalación">descripción detallada</a> del formato del fichero <code>install.rdf</code>. Utiliza la variable <strong>DIST_FILES</strong> del makefile para decirle a <code>make</code> que copie el fichero en el directorio de la extensión y (opcionalmente) el fichero XPI.</p>

<h4 id="Interfaces_p.C3.BAblicas" name="Interfaces_p.C3.BAblicas">Interfaces públicas</h4>

<p>El directorio <code>public/</code> contiene todas las interfaces necesarias para que otros módulos puedan utilizarlas. Éstas pueden ser ficheros <a class="external" href="http://www.mozilla.org/scriptable/xpidl/idl-authors-guide/index.html">IDL</a> que describan interfaces <a href="/es/XPCOM" title="es/XPCOM">XPCOM</a>, los cuales son utilizados para generar ficheros de cabecera normales de C++ para incluirlos en los ficheros fuente. También pueden ser ficheros de cabecera normales de C++ que son utilizados directamente por otros módulos. La forma más fácil de hacer esto último es usar implementaciones en línea para todos los métodos, por lo que no tendrás ninguna dependencia de enlazado adicional. En otro caso tendrás que utilizar enlazado estático en tu módulo si utilizas estas cabeceras públicas en otros módulos. Personalmente desaconsejo esta práctica (entre otras cosas porque el enlazado estático significa que el mismo código se carga más de una vez en memoria y el código no estará disponible desde JavaScript u otros lenguajes diferentes a C++) y animo a usar XPCOM siempre que sea posible.</p>

<p>El makefile en el directorio <code>public/</code> debería parecerse a este modelo:</p>

<pre>DEPTH		= ../../..
topsrcdir	= @top_srcdir@
srcdir		= @srcdir@
VPATH		= @srcdir@

include $(DEPTH)/config/autoconf.mk

MODULE		= myextension
XPIDL_MODULE	= myextension

XPI_NAME = myextension

EXPORTS = \
		myHeader.h \
		$(NULL)

XPIDLSRCS	= \
		myIFirstComponent.idl \
		myISecondComponent.idl \
		$(NULL)

include $(topsrcdir)/config/rules.mk
</pre>

<p><strong>XPIDL_MODULE</strong> es el nombre del fichero XPT generado que contiene información de tipos sobre tus interfaces <a class="external" href="http://www.mozilla.org/scriptable/xpidl/idl-authors-guide/index.html">IDL</a>. Si tienes múltiples módulos, asegúrate de que utilizas un valor diferente de <strong>XPIDL_MODULE</strong> para cada uno. En caso contrario, el fichero XPT del primer módulo será sobrescrito por el segundo y obtendrás errores del tipo <strong>NS_ERROR_XPC_BAD_IID</strong> cuando intentes acceder a sus interfaces IDL desde el código. Los ficheros bajo <strong>EXPORTS</strong> son copiados directamente al directorio <code>/mozilla/$(MOZ_OBJDIR)/dist/include/myextension/</code> siendo así accesibles desde otros módulos (el valor de <strong>MOZ_OBJDIR</strong> se define en <code>/mozilla/.mozconfig</code>). XPIDLSRCS es ejecutado a través del procesador IDL y las cabeceras generadas de C++ son copiadas en el mismo directorio include. Además, se genera un fichero XPT (biblioteca de tipos) que se copia en el subdirectorio <code>components/</code> de tu extensión.</p>

<h4 id="Ficheros_fuente" name="Ficheros_fuente">Ficheros fuente</h4>

<p>Ahora es cuando hay que crear el makefile y los ficheros-fuente en el subdirectorio <code>src/</code>. Si estás implementando interfaces y las estás describiendo con IDL, la forma más fácil de hacer esto es dejando vacío el directorio <code>src/</code> y ejecutando <code>make</code> sólo en el directorio <code>public/</code>. Esto serà explicado en breve.</p>

<p>Luego abre el fichero de cabecera generado para tu interfaz en <code>/mozilla/$(MOZ_OBJDIR)/dist/include/myextension/</code>. Este fichero tendrá algunas plantillas para los ficheros de componentes .H y .CPP que puedes copiar y pegar en tus ficheros de implementación. Todo lo que tienes que hacer es rellenar los huecos del fichero C++ con la implementación real y estarás listo para continuar.</p>

<p>A continuación se muestra un ejemplo del makefile que necesitas colocar en tu directorio <code>src</code>.</p>

<pre class="eval">DEPTH		= ../../..
topsrcdir	= @top_srcdir@
srcdir		= @srcdir@
VPATH		= @srcdir@

include $(DEPTH)/config/autoconf.mk

IS_COMPONENT = 1
MODULE = myextension
LIBRARY_NAME =  myExtension

XPI_NAME = myextension

REQUIRES	= xpcom \
		  string \
		  $(NULL)

CPPSRCS		= \
		  myFirstComponent.cpp \
		  mySecondComponent.cpp \
		  myExtension.cpp \
		  $(NULL)

include $(topsrcdir)/config/rules.mk

EXTRA_DSO_LDOPTS += \
  $(XPCOM_GLUE_LDOPTS) \
  $(NSPR_LIBS) \
  $(NULL)

# <span class="highlightred">NOTA: si estás codificando contra la versión 1.8.0 branch (no 1.8 branch o trunk),</span>
# <span class="highlightred">la línea anterior no funcionará debido a problemas de modificadores del enlazador.</span>
# En su lugar utiliza las siguientes variables:
#
# EXTRA_DSO_LDOPTS += \
#   $(MOZ_COMPONENT_LIBS) \
#   $(NULL)
#
# Por desgracia, usando MOZ_COMPONENT_LIBS se enlaza contra xpcom_core, lo que
# significa que tus componentes no funcionarán en futuras versiones de Firefox.
</pre>

<p>La sección <code>REQUIRES</code> le dice a <code>make</code> qué módulos utilizan tus componentes. Esto provoca que los subdirectorios relevantes de <code>/mozilla/$(MOZ_OBJDIR)/dist/include/</code> sean añadidos a la ruta include del compilador de C++. Si estás incluyendo las cabeceras de Mozilla y el compilador es incapaz de encontrarlas, podría ser que no hayas listado todos los módulos necesarios aquí. <code>CPPSRCS</code> enumera los ficheros fuente que necesitan ser compilados.</p>

<p>En este ejemplo, los dos primeros ficheros contienen la implementación de los dos componentes de la extensión. El fichero final <code>myExtension.cpp</code> contiene el código necesario para registrar dichos componentes, como se describirá en la siguiente sección.</p>

<h4 id="Registrar_tus_componentes" name="Registrar_tus_componentes">Registrar tus componentes</h4>

<p>Para poder usar tus componentes desde otros módulos de C++ y JavaScript primero tienes que registrarlos. Para hacerlo, tu extensión necesita implementar una clase que exponga la interfaz <code><a href="/es/NsIModule" title="es/NsIModule">nsIModule</a></code> la cual posee métodos para acceder a los componentes definidos en un módulo. Afortunadamente, esto puede ser llevado a cabo mediante el uso de unas pocas y simples macros por lo que no tienes que embarrarte con los detalles de qué está pasando internamente.</p>

<p>El primer paso es definir un CID, un contract ID (o ID de contrato) y un nombre de clase para cada uno de tus componentes. Pega el siguiente código (adaptando los <strong>#defines</strong> según convenga) en la cabecera de cada componente que tenga que ser instanciado utilizando el administrador de componentes:</p>

<pre>// {00000000-0000-0000-0000-000000000000}
#define MYFIRSTCOMPONENT_CID \
	{ 0x00000000, 0x0000, 0x0000, \
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } }

#define MYFIRSTCOMPONENT_CONTRACTID	"@mycompany.com/myfirst;1"
#define MYFIRSTCOMPONENT_CLASSNAME	"My First Component"
</pre>

<p>Obviamente necesitas completar el CID con un GUID real. Bajo Windows puede ser generado utilizando <a class="external" href="http://www.microsoft.com/downloads/details.aspx?familyid=94551F58-484F-4A8C-BB39-ADB270833AFC">guidgen.exe</a>. Los Unixeros pueden utilizar uuidgen (viene de modo predeterminado en la mayoría de distribuciones de Unix y Linux).</p>

<p>Ahora crea el fichero <code>myExtension.cpp</code> así:</p>

<pre>#include "nsXPCOM.h"

#include "nsIGenericFactory.h"

/**
 * Components to be registered
 */
#include "myFirstComponent.h"
#include "mySecondComponent.h"

NS_GENERIC_FACTORY_CONSTRUCTOR(myFirstComponent)
NS_GENERIC_FACTORY_CONSTRUCTOR(mySecondComponent)

//----------------------------------------------------------

static const nsModuleComponentInfo components[] =
{
	{
		MYFIRSTCOMPONENT_CLASSNAME,
		MYFIRSTCOMPONENT_CID,
		MYFIRSTCOMPONENT_CONTRACTID,
		myFirstComponentConstructor
	},
	{
		MYSECONDCOMPONENT_CLASSNAME,
		MYSECONDCOMPONENT_CID,
		MYSECONDCOMPONENT_CONTRACTID,
		mySecondComponentConstructor
	},
};

NS_IMPL_NSGETMODULE(MyExtension, components)
</pre>

<p>La macro <strong>NS_IMPL_NSGETMODULE</strong> crea el objeto de módulo apropiado suministrando acceso a todos los componentes listados en el array <code><a href="/es/NsModuleComponentInfo" title="es/NsModuleComponentInfo">nsModuleComponentInfo</a></code>.</p>

<h4 id="Compilaci.C3.B3n" name="Compilaci.C3.B3n">Compilación</h4>

<p>Como se dijo antes, probablemente querrás compilar tu extensión inmediatamente tras crear tus ficheros IDL para poder generar las plantillas C++ para las implementaciones del componente. Estoy asumiendo que ya has podido compilar Firefox sin problemas. Si no es así, vuelve inmediatamente al inicio de este artículo y no regreses hasta que hayas generado un <code>firefox.exe</code> funcional. <span class="comment">Creo que es una casilla del monopoly: Do not pass go. Do not collect $200.</span></p>

<p>¿Sigues ahí? Bien, ahora vamos a modificar tu <code>.mozconfig</code> (en el directorio raíz <code>/mozilla/</code> para que tu extensión se compile junto con Mozilla. Añade la siguiente línea al final del fichero:</p>

<pre>ac_add_options --enable-extensions=default,myextension
</pre>

<p>Ahora ejecuta <code>make</code> en el directorio raíz de Mozilla:</p>

<pre>make -f client.mk build
</pre>

<p>Incluso aunque hayas compilado una versión actualizada de Firefox, tendrás que esperar un momento para que <code>make</code> pueda recorrer el árbol de Mozilla por completo buscando nuevo material (en mi máquina, que es bastante rápida, esto tarda unos 10-15 minutos). Finalmente alcanzará tu extensión y generará un montón de material bajo el directorio <code>/mozilla/$(MOZ_OBJDIR)/</code>:</p>

<ul>
 <li>Varios ficheros de cabecera exportados y ficheros de cabecera generados (desde IDL) en <code>dist/include/myextension/</code></li>
 <li>Bibliotecas estáticas para tus módulos en <code>dist/lib/</code> (en el caso de que otros módulos quieran enlazar estáticamente a tu material en lugar de utilizar XPCOM).</li>
 <li>Un fichero XPI en <code>dist/xpi-stage/myextensión.xpi</code>.</li>
 <li>Los makefiles generados para tus proyectos en <code>extensions/myextension/</code> (recuerda que estamos bajo el directorio <code>/mozilla/$(MOZ_OBJDIR)/</code>.</li>
 <li>Todo lo demás en <code>dist/bin/extensions/<a class="link-mailto" href="mailto:myextension@mycompany.com" rel="freelink">myextension@mycompany.com</a>/</code>.</li>
</ul>

<p>Gran parte de este material no será creado en la primera pasada ya que <code>make</code> se impacientará cuando no encuentre los ficheros fuente para tus componentes. No te preocupes por eso, todo lo que necesitas son los ficheros de cabecera generados que contengan las plantillas de implementación en C++. Vuelve atrás y rellena la implementación en C++ de tus componentes para que puedan ser compilados la siguiente vez. Recuerda que no deberías modificar jamás, nunca, ningún fichero generado. Modifica siempre los ficheros utilizados para generarlos y vuelve a ejecutar <code>make</code>. Quizá haya excepciones a esta regla, pero si estás cambiando los ficheros generados directamente muy probablemente estás metiendo la pata.</p>

<p>El proceso de recorrer el árbol completo de Mozilla lleva bastante tiempo. Si ya has compilado Mozilla puedes evitar esto creando un makefile para tu extensión directamente. Ve al directorio raíz de tu $(MOZ_OBJDIR) y (desde un shell compatible con bash) introduce:</p>

<pre class="eval">../build/autoconf/make-makefile extensions/myextension
</pre>

<p>Si tu $(MOZ_OBJDIR) está ubicado fuera de tu $(TOPSRCDIR), necesitarás hacer:</p>

<pre class="eval">$(TOPSRCDIR)/build/autoconf/make-makefile -t $(TOPSRCDIR) extensions/myextension
</pre>

<p>para que el script sepa dónde están tus fuentes (usará la ruta de la extensión que des relativa al directorio actual para resolver dónde quieres que vayan tus makefiles).</p>

<p>Esto generará el makefile apropiado para tu extensión. Tanto si quieres compilar el árbol completo de Mozilla como si tomas este atajo, puedes compilar de ahora en adelante yendo a <code>/mozilla/$(MOZ_OBJDIR)/extensions/myextension/</code> y escribiendo "make" en la línea de órdenes. Esto debería compilar tu componente sin distraerse con el resto de Mozilla. Si todo va bien, verás tu fichero XPI en el área de pruebas de XPI. También verás la versión descomprimida (es decir, la estructura de directorios descomprimida) bajo <code>/mozilla/$(MOZ_OBJDIR)/dist/bin/extensions</code> (si algo va mal, averigua qué es, corrígelo y luego vuelve aquí y añádelo a este artículo).</p>

<p>Para asegurarte de que la compilación ha finalizado realmente, lanza Firefox y comprueba que tu extensión aparece en la lista cuando selecciones Herramientas / Complementos. Si estás usando Firefox como tu navegador habitual (y si no, ¿por qué no?), puede que te moleste el hecho que de que tendrás que cerrar tu Firefox normal antes de ejecutar tu versión personalizada. Si es así, prueba a establecer la variable de entorno <strong>MOZ_NO_REMOTE</strong> a "1" antes de ejecutar la versión de desarrollo de Firefox. También necesitarás usar un perfil diferente para tu versión de desarrollo:</p>

<pre class="eval">firefox -P <em>desarrollo</em>
</pre>

<p>Donde <em>desarrollo</em> se sustituye con el nombre del perfil extra que has creado. Esto te permitirá ejecutar ambas versiones de Firefox simultáneamente, ahorràndote montones de tiempo a lo largo del ciclo de compilación/prueba.</p>

<h4 id="No_hay_nada_como_estar_en_chrome" name="No_hay_nada_como_estar_en_chrome">No hay nada como estar en chrome</h4>

<p>¡Yuhuuuu! Ahora ya tienes una extensión que no hace absolutamente nada. Es hora de hacer algo con esos geniales componentes que implementaste y registraste. La forma más fácil de hacer esto es escribiendo algo de código <a href="/es/JavaScript" title="es/JavaScript">JavaScript</a> y <a href="/es/XUL" title="es/XUL">XUL</a>. En este punto sería de mucha utilidad tener algo de experiencia <a href="/es/Extensiones" title="es/Extensiones">escribiendo extensiones "normales"</a> (p.e., sin utilizar componentes de C++ personalizadas). Si nunca has hecho esto, te recomiendo encarecidamente que pienses una idea guay para algo simple que siempre hayas querido hacer para Firefox y lo escribas. Mostrar sólo un nuevo elemento de menú que abra un cuadro de diálogo "¡Hola mundo!" sería ya un gran ejercicio de precalentamiento.</p>

<p>Suponiendo que sabes cómo escribir extensiones en XUL/JavaScript, estarás al corriente de que la parte más importante va en el directorio <code>chrome/</code> de tu extensión. Bueno, el hecho de que estés utilizando también componentes C++ no cambia eso ni una pizca. Por tanto, ahora necesitas crear los directorios normales <code>content/</code>, <code>locale/</code> y <code>skin/</code> en los que has de poner tus ficheros chrome. Personalmente me gusta ubicar dichos directorios directamente bajo el directorio raíz de mi módulo pero supongo que no habrá diferencia si prefieres ponerlos bajo el subdirectorio <code>chrome/</code> o el que sea. ¡Viva la libertad!</p>

<p>Una vez has escrito los ficheros chrome necesarios (por ejemplo, un overlay que añade un elemento de menú para instanciar y utilizar uno de tus componentes), necesitas empaquetarlo como parte de tu extensión. Esto es llevado a cabo a través del uso de un <a href="/es/Manifiestos_JAR" title="es/Manifiestos_JAR">manifiesto JAR</a>. Para nuestro ejemplo de extensión simple este fichero podría tener este aspecto:</p>

<pre>myextension.jar:
%  content myextension %content/
%  locale myextension en-US %locale/en-US/
%  skin myextension classic/1.0 %skin/classic/
%  overlay chrome://browser/content/browser.xul chrome://myextension/content/MyExtensionOverlay.xul
	content/MyExtensionOverlay.js		(content/MyExtensionOverlay.js)
	content/MyExtensionOverlay.xul		(content/MyExtensionOverlay.xul)
	locale/en-US/MyExtension.dtd		(locale/en-US/MyExtension.dtd)
	locale/en-US/MyExtension.properties	(locale/en-US/MyExtension.properties)
	skin/classic/MyExtension.css		(skin/classic/MyExtension.css)
</pre>

<p>Pon este código en un fichero llamado <code>jar.mn</code> en el directorio raíz de tu extensión, asegurándote de que las rutas en los paréntesis apuntan a los ficheros reales (relativos al directorio raíz). Además tienes que hacer un pequeño cambio al makefile del mismo directorio, añadiendo la siguiente línea:</p>

<pre class="eval">USE_EXTENSION_MANIFEST = 1
</pre>

<p>Esto le dice a <code>make</code> que cree un único fichero de manifiesto llamado <code>chrome.manifest</code> en lugar de crear manifiestos separados con nombres tontos para cada paquete.</p>

<p>Ahora ejecuta <code>make</code> de nuevo. Deberías ver un subdirectorio <code>chrome</code> en tu extensión (<code>/mozilla/$(MOZ_OBJDIR)/dist/bin/extensions/<a class="link-mailto" href="mailto:myextension@mycompany.com" rel="freelink">myextension@mycompany.com</a>/</code>). Observa que el directorio <code>chrome</code> contiene un fichero JAR (o sea, ZIP) con todos los ficheros chrome listados en <code>jar.mn</code> además de una estructura de directorio completa reflejo de la del fichero JAR. La estructura de directorio sin embargo está vacía. ¿Por qué? No lo sé. No te preocupes por esto, los ficheros en el JAR son los que realmente se usan.</p>

<h4 id="Manteni.C3.A9ndolo_complejo" name="Manteni.C3.A9ndolo_complejo">Manteniéndolo complejo</h4>

<p>Si estás desarrollando extensiones realmente complejas con un montón de componentes <a href="/es/XPCOM" title="es/XPCOM">XPCOM</a>, probablemente desees dividir tu código en módulos más pequeños.</p>

<h5 id="Extensiones_moderadamente_complejas" name="Extensiones_moderadamente_complejas">Extensiones moderadamente complejas</h5>

<p>Para una extensión moderadamente compleja, probablemente bastará con dividir el código en módulos de un solo nivel. Supongamos que tienes un módulo <code>base/</code> que define un manojo de componentes XPCOM básicos y un módulo <code>advanced/</code> que define algunos componentes chrome así como otros componentes que usan a los básicos. La estructura del directorio debería lucir más o menos así:</p>

<ul>
 <li>myextension
  <ul>
   <li>base
    <ul>
     <li>public</li>
     <li>src</li>
    </ul>
   </li>
   <li>advanced
    <ul>
     <li>content</li>
     <li>locale
      <ul>
       <li>en-US</li>
       <li>...other locales...</li>
      </ul>
     </li>
     <li>public</li>
     <li>skin
      <ul>
       <li>classic</li>
       <li>...other skins...</li>
      </ul>
     </li>
     <li>src</li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

<p>Más allá de eso, nada cambia. Los makefiles en los directorios <code>base/</code> y <code>advanced/</code> deberían tener más o menos el mismo aspecto que el makefile original del directorio raíz, sin olvidar cambiar la variable <strong>DEPTH</strong> para reflejar el hecho de que se han movido a un nivel más de profundidad respecto de la raíz de mozilla. También debes quitar la variable <strong>DIST_FILES</strong> porque va a estar en el makefile de nivel superior. Cada makefile que genere algo debería definir la variable <strong>XPI_NAME</strong> para asegurarse que los archivos generados van dentro de tu extensión y no dentro del directorio global <code>components/</code>. Define esto en cada makefile para asegurarte. Puedes usar el mismo <strong>MODULE</strong> para ambos casos, <code>base/</code> y <code>advanced/</code>, y así todos los archivos include generados irán al mismo directorio, pero asegúrate de no usar el mismo <strong>XPIDL_MODULE</strong> en los dos directorios <code>public/</code> o una de las bibliotecas de componentes (es decir, archivos XPT) sobrescribirá al otro y todo se echará a perder.</p>

<p>Cada módulo debe tener también un valor diferente para la variable <strong>LIBRARY_NAME</strong>. Éste es el nombre de la biblioteca dinámica generada, así que si llamamos a las bibliotecas "myBase" y "myAdvance" entonces tendremos los archivos <code>myBase.dll</code> y <code>myAdvance.dll</code> (por lo menos así es en Windows). Y cada uno de estos módulos va a tener un archivo C++ separado para registrar componentes, así que va a haber dos archivos que lucirán como <code>myExtension.cpp</code> en el ejemplo original, digamos Base.cpp y Advanced.cpp. Por último, cada módulo tendrá, obviamente, su propio jar.mn, aunque pueden referenciar al mismo nombre de archivo JAR y nombre de paquete si quieres que todos los archivos chrome estén organizados en un mismo paquete y archivo JAR. El único que realmente permanece es install.rdf, que existe una vez y sólo una vez en el directorio raíz de la extensión.</p>

<p>En cuanto al makefile de nivel superior, ahora tendrá este aspecto:</p>

<pre>DEPTH		= ../..
topsrcdir	= @top_srcdir@
srcdir		= @srcdir@
VPATH		= @srcdir@

include $(DEPTH)/config/autoconf.mk

MODULE = myextension

DIRS		= base advanced

XPI_NAME               = myextension
INSTALL_EXTENSION_ID   = myextension@mycompany.com
XPI_PKGNAME		= myextension

DIST_FILES = install.rdf

include $(topsrcdir)/config/rules.mk
</pre>

<h5 id="Extensiones_realmente_complejas" name="Extensiones_realmente_complejas">Extensiones realmente complejas</h5>

<p>En algún momento, hasta un solo módulo puede crecer hasta un punto en que desees dividirlo en submódulos. La diferencia entre tener módulos diferentes y tener un módulo dividido en submódulos es que todos los submódulos comparten el mismo archivo para registrar componentes (el famoso archivo myExtension.cpp) y cuando lo compilas genera una sola biblioteca dinámica. La decisión para dividir un módulo en submódulos es sólo cuestión de organización del código, no afecta al producto final.</p>

<p>Para dividir un módulo en submódulos primero debes crear un directorio para cada submódulo. Luego debes crear un directorio adicional llamado <code>build/</code>. Cada submódulo será configurado para crear una biblioteca estática y el directorio <code>build/</code> las unirá para crear una sola biblioteca dinámica. ¿Confundido? Aquí hay un ejemplo mostrando la subrama <code>advanced/</code> del directorio <code>myextension/</code>:</p>

<ul>
 <li>advanced
  <ul>
   <li>build</li>
   <li>intricate
    <ul>
     <li>public</li>
     <li>src</li>
    </ul>
   </li>
   <li>multifarious
    <ul>
     <li>public</li>
     <li>src</li>
    </ul>
   </li>
   <li>content</li>
   <li>locale
    <ul>
     <li>en-US</li>
     <li>...otros idiomas...</li>
    </ul>
   </li>
   <li>skin
    <ul>
     <li>classic</li>
     <li>...otros skins...</li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

<p>Como puedes ver, hemos dividido <code>advanced/</code> dentro de dos submódulos: <code>intrincate/</code> y <code>multifarious/</code> y hemos añadido un directorio <code>build/</code> adicional. Hemos dejado los directorios chrome directamente bajo <code>advanced/</code>, los cuales no están enlazados a ningún submódulo específico. Esto significa que jar.mn estará en el mismo lugar.</p>

<p>Los makefiles <code>intricate/</code> y <code>multifarious/</code> lucirán casi igual al makefile original <code>advanced/</code>, pero necesitamos modificarlos un poquito. Como siempre, debemos ajustar la variable <strong>DEPTH</strong> porque el makefile está más profundo en la estructura de directorios. Y deberíamos cambiar <strong>LIBRARY_NAME</strong> para indicar que estamos generando una biblioteca estática para cada submódulo. Por convenio, se usa el sufijo "_s" para este propósito. Así que las llamaremos "myIntricate_s" y "myMultifarious_s". Finalmente definimos la variable <strong>FORCE_STATIC_LIB</strong> para que quede un makefile que comience más o menos así:</p>

<pre>DEPTH		= ../../../../..
topsrcdir	= @top_srcdir@
srcdir		= @srcdir@
VPATH		= @srcdir@

include $(DEPTH)/config/autoconf.mk

MODULE = myextension
LIBRARY_NAME = myIntricate_s
FORCE_STATIC_LIB = 1

XPI_NAME = myextension

...más cosas aquí...
</pre>

<p>El makefile build une las bibliotecas estáticas generadas por los submódulos y crea una única biblioteca dinámica de componentes:</p>

<pre>DEPTH		= ../../../..
topsrcdir	= @top_srcdir@
srcdir		= @srcdir@
VPATH		= @srcdir@

include $(DEPTH)/config/autoconf.mk

IS_COMPONENT = 1
MODULE = myextension
LIBRARY_NAME = myAdvanced

XPI_NAME = myextension

DEFINES += XPCOM_GLUE

SHARED_LIBRARY_LIBS = \
		$(DIST)/lib/$(LIB_PREFIX)myIntricate_s.$(LIB_SUFFIX) \
		$(DIST)/lib/$(LIB_PREFIX)myMultifarious_s.$(LIB_SUFFIX) \
                $(DIST)/lib/$(LIB_PREFIX)xpcomglue_s.$(LIB_SUFFIX) \
                $(DIST)/lib/$(LIB_PREFIX)xpcom.$(LIB_SUFFIX) \
                $(DIST)/lib/$(LIB_PREFIX)nspr4.$(LIB_SUFFIX) \
                $(DIST)/lib/$(LIB_PREFIX)plds4.$(LIB_SUFFIX) \
                $(DIST)/lib/$(LIB_PREFIX)plc4.$(LIB_SUFFIX) \
		$(NULL)

REQUIRES	= \
		xpcom \
		string \
		$(NULL)

CPPSRCS		= \
		Advanced.cpp \
		$(NULL)

include $(topsrcdir)/config/rules.mk

LOCAL_INCLUDES += \
        -I$(srcdir)/../intricate/src \
        -I$(srcdir)/../multifarious/src \
        $(NULL)
</pre>

<p>El makefile en el directorio <code>advanced/</code> debería listar los directorios <code>intricate/</code>, <code>multifarious/</code> y <code>build/</code> en su variable <strong>DIRS</strong>. Asegúrate de que <code>build/</code> esté al final porque no puede crear la biblioteca hasta que los otros makefiles hayan sido completados.</p>

<h3 id="Otros_temas" name="Otros_temas">Otros temas</h3>

<h4 id="Agregar_archivos_de_datos_a_tus_extensiones" name="Agregar_archivos_de_datos_a_tus_extensiones">Agregar archivos de datos a tus extensiones</h4>

<p>En algunos casos, puedes desear incluir archivos adicionales en tus extensiones que no pertenecen al subdirectorio <code>chrome/</code>. Algunos ejemplos pueden ser archivos de bases de datos o esquemas XML. Esto puede conseguirse añadiendo, en el makefile, código personalizado que copie los ficheros desde el árbol de origen hacia el directorio de destino de la extensión.</p>

<h5 id="Copiar_archivos_de_datos_al_directorio_de_destino" name="Copiar_archivos_de_datos_al_directorio_de_destino">Copiar archivos de datos al directorio de destino</h5>

<p>Supongamos que tienes algunos ficheros de datos que contienen información estadística que deseas incluir en tu extensión y que esté disponible para tus componentes. Tienes estos archivos, cuya extensión es .TXT, dentro del subdirectorio <code>stats/</code> bajo el directorio de tu extensión en el árbol del código fuente. Puedes usar el siguiente makefile para copiar los ficheros al directorio de destino de la extensión:</p>

<pre>libs::
	if test ! -d $(FINAL_TARGET)/stats; then \
		$(NSINSTALL) -D $(FINAL_TARGET)/stats; \
	fi
	$(INSTALL) $(srcdir)/*.txt $(FINAL_TARGET)/stats
</pre>

<h5 id="Acceder_a_ficheros_de_datos_desde_los_componentes" name="Acceder_a_ficheros_de_datos_desde_los_componentes">Acceder a ficheros de datos desde los componentes</h5>

<p>El truco para acceder a los ficheros es averiguar dónde está el directorio <em>home</em> de tu extensión. Los rumores dicen que en el futuro esto será posible a través del interface <a href="/es/NsExtensionManager" title="es/NsExtensionManager">nsExtensionManager</a> o alguna cosa similar. Mientras tanto, hay un modo simple y fiable de hacer esto. En la implementación de cualquier componente JavaScript XPCOM hay un símbolo especial <strong>__LOCATION__</strong> (dos subrayados delante y dos detrás) que apunta al fichero de implementación del componente. Así, puedes escribir un componente simple que deduzca el directorio raíz de tu extensión extrapolando desde su ubicación.</p>

<p><a class="external" href="http://www.builderau.com.au/program/soa/Creating_XPCOM_components_with_JavaScript/0,39024614,39206503,00.htm">Este artículo</a> explica cómo crear un componente XPCOM en JavaScript. Necesitarás un fichero IDL para un interfaz que tenga un aspecto más o menos así:</p>

<pre>interface myILocation : nsISupports
{
    readonly attribute nsIFile locationFile;
};
</pre>

<p>Sitúa el fichero IDL en el directorio <code>public/</code> del proyecto o subproyecto. En el directorio <code>src/</code> coloca el fichero JavaScript que implementa el componente. La implementación del componente incluirá los métodos para solicitar la ruta o el fichero para el directorio <em>home</em> de la extensión.</p>

<pre>myLocation.prototype =
{
  QueryInterface: function(iid)
  {
    if (iid.equals(nsISupports))
      return this;
    if (iid.equals(myILocation))
      return this;

    Components.returnCode = Components.results.NS_ERROR_NO_INTERFACE;
    return null;
  },

  get locationFile()
  {
     return __LOCATION__.parent.parent;
  }
}
</pre>

<p>Esto asume que el componente se encuentra en un subdirectorio del directorio de la extensión (por convenio, este directorio se llama <code>components/</code>). La propiedad <code>parent</code> de <strong>__LOCATION__</strong> devuelve <code>components/</code>, y el valor <code>parent</code> de éste es el directorio de la extensión.</p>

<p>El último paso es modificar el makefile del directorio de orìgen donde colocaste el fichero JavaScript para que sea copiado dentro de la ubicación apropiada en la extensión.</p>

<pre>libs::
	$(INSTALL) $(srcdir)/*.js $(FINAL_TARGET)/components
</pre>

<p>Ahora puedes instanciar este componente y usar la propiedad <code>locationFile</code> para obtener un interface <code><a href="/es/NsIFile" title="es/NsIFile">nsIFile</a></code> que apunte al directorio <em>home</em> de tu extensión.</p>

<h4 id="Usar_otras_bibliotecas" name="Usar_otras_bibliotecas">Usar otras bibliotecas</h4>

<p>Para extensiones más sofisticadas, tal vez desees integrar bibliotecas de terceros que proveerán funciones especializadas para conectividad de bases de datos, procesamiento de imágenes, funciones de red y otras tareas. Si quieres que tu extensión se ejecute en todas las plataformas de FireFox, necesitarás el código fuente de la biblioteca en cuestión, así que asumiré que está disponible.</p>

<p>La mejor forma de hacerlo, desde el punto de vista del ciclo de desarrollo, es crear un makefile estilo-Mozilla para la biblioteca. Esto funciona bien para bibliotecas que tienen un proceso de compilación sencillo sin demasiada configuración. Un buen ejemplo de esto es la biblioteca SQLite incluida en el árbol de compilación de Mozilla en <code>db/sqlite</code>. Adaptando el makefile de esta manera, la biblioteca se crea como una parte estándar del proceso de compilado de Mozilla, lo cual elimina pasos adicionales. El lado malo es que necesitarás actualizar el makefile modificado cada vez que se publique una nueva versión de la biblioteca.</p>

<p>Para bibliotecas que tienen un proceso de configuración complejo, que use un compilador no-estándar, o que tengan alguna otra característica especial, quizá no sea viable crear un makefile compatible con el estilo Mozilla. En este caso, recomendaría colocar la distribución completa de la biblioteca dentro del proyecto o subproyecto que la utiliza. Por ejemplo, si la biblioteca <code>acmelib</code> se usa dentro del subproyecto <code>multifarious/</code> en el ejemplo de arriba, se colocaría como un subdirectorio bajo ese proyecto (en el mismo nivel que <code>public/</code> y <code>src/</code>).</p>

<p>Por supuesto, esto significa que tendrás que compilar <code>acmelib</code> manualmente en cada plataforma antes de lanzar Mozilla. Pero por lo menos luego puedes referirte a los archivos include y las bibliotecas importadas desde tus componentes usando rutas relativas.</p>

<h4 id="Compilar_para_m.C3.BAltiples_plataformas" name="Compilar_para_m.C3.BAltiples_plataformas">Compilar para múltiples plataformas</h4>

<p>Información del Documento Original</p>

<div class="originaldocinfo">
<ul>
 <li>Autor: Matthew Gertner - Julio 26, 2005.</li>
 <li>Permission granted to migrate in Jan 2006, including permission to relicense under the CC:By-SA.</li>
 <li>Código Original: <a class="external" href="http://www.allpeers.com/blog/creating-complex-firefox-extensions/" rel="freelink">http://www.allpeers.com/blog/creatin...ox-extensions/</a></li>
</ul>
</div>

<p> </p>
