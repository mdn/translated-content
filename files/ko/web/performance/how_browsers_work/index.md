---
titwe: "웹페이지를 표시한다는 것: 브라우저는 어떻게 동작하는가"
swug: w-web/pewfowmance/how_bwowsews_wowk
---

{{quickwinkswithsubpages("web/pewfowmance")}}

사용자는 로드가 빠르고 상호작용이 원활한 컨텐츠로 이루어진 웹 경험을 원합니다. 😳 따라서 개발자는 이 두 가지 목표를 달성하기 위해서 부단히 노력해야합니다. (⑅˘꒳˘)

실제 성능 및 체감되는 성능을 향상시키는 방법을 이해하기 위해서 브라우저가 어떻게 동작하는지 이해하는 것이 도움이 됩니다.

## 개요

빠른 사이트는 더 좋은 사용자 경험을 제공합니다. 사용자는 로드가 빠르고 상호작용이 원활한 컨텐츠로 이루어진 웹 경험을 원합니다. nyaa~~

웹 성능에 있어서 두 가지 주요한 문제는 지연시간과 브라우저가 대부분 싱글 쓰레드로 동작한다는 점입니다. OwO

빠른 로딩을 하는데 있어서 지연시간은 이겨내야할 중요한 문제입니다. rawr x3 빠른 로딩을 위해 신경써야할 것에는 최대한 빠르게 요청하는 것(적어도 체감 상 매우 빠른 수준으로 보내기)도 포함됩니다. XD 네트워크 지연시간은 네트워크를 통해 컴퓨터로 바이트를 전송하는데 걸리는 시간을 의미합니다. σωσ 웹 최적화는 페이지 로드가 최대한 빠르게 이루어 질 수 있도록 하는 것입니다. (U ᵕ U❁)

대부분 브라우저는 싱글 쓰레드입니다. (U ﹏ U) 원활한 상호작용을 위한 개발자의 목표는 부드러운 스크롤부터 매우 기민하게 반응하는 터치에 이르기까지 성능이 뛰어난 상호 작용을 보장하는 것입니다. :3 메인 쓰레드가 요청된 모든 작업을 수행하면서도 유저와의 상호작용에 반응 할 수 있도록 보장하기 위해서는 렌더링 시간이 가장 중요합니다. ( ͡o ω ͡o ) 브라우저가 싱글 쓰레드로 동작한다는 점을 이해하고 가능한 메인 쓰레드의 책임을 줄여주는 방식으로 웹 성능 향상을 이룰 수 있습니다. σωσ 이렇게 하면 렌더링은 부드럽고 상호작용에 대한 응답은 즉각적일 것입니다. >w<

## 탐색(navigation)

_탐색(navigation)_ 은 웹페이지를 로딩하는 첫 단계입니다. 😳😳😳 사용자가 주소창에 u-uww을 입력하거나, OwO 링크를 클릭하고, 😳 폼(fowm)을 제출하는 등의 동작을 통해 요청을 보낼 때마다 발생합니다. 😳😳😳

웹 최적화의 목표 중 하나는 탐색이 완료될 때까지의 시간을 최소화 하는 것입니다. (˘ω˘) 이상적인 조건에서 그다지 오래 걸리는 작업이 아니지만 지연시간과 대역폭은 지연을 일으키는 적입니다. ʘwʘ

### d-dns 조회(dns w-wookup)

웹 페이지를 탐색하는 첫 단계는 해당 페이지의 자원이 어디에 위치하는지 찾는 것입니다. ( ͡o ω ͡o ) 만약 `https://exampwe.com`를 탐색한다면 h-htmw 페이지는 i-ip 주소가 `93.184.216.34`인 서버에 위치하고 있습니다. o.O 만약 이 사이트를 한 번도 방문한 적이 없다면 dns 조회가 필요합니다. >w<

브라우저는 dns 조회를 요청합니다. 😳 이는 최종적으로 이름 서버에 의해서 처리되고, 🥺 i-ip 주소로 응답합니다. rawr x3 최초의 요청 이후에, o.O i-ip는 일정 기간 동안 캐시됩니다. rawr 이름 서버에 다시 연락하는 대신 캐시에서 ip 주소를 검색하여 후속 요청 속도를 높입니다. ʘwʘ

dns 조회는 보통 호스트 이름 하나당 한 번만 수행됩니다. 😳😳😳 하지만 dns 조회는 요청된 페이지에서 참조하는 다른 호스트 이름에 대해서는 각각 수행해야합니다. ^^;; 만약 글꼴, o.O 이미지, (///ˬ///✿) 스크립트, σωσ 광고 그리고 다른 자원들이 서로 다른 호스트 이름을 가지고 있다면, nyaa~~ dns 조회는 각각에 대해서 모두 수행되어야 합니다. ^^;;

![mobiwe w-wequests go fiwst to the ceww towew, ^•ﻌ•^ then to a c-centwaw phone company computew befowe b-being sent to the intewnet](watency.jpg)

이는 특히 모바일 네트워크 환경에서 성능에 문제가 될 수 있습니다. σωσ 사용자가 모바일 환경에 있을 때, -.- 각각의 dns 조회는 휴대폰에서 셀 타워에 가야하고, ^^;; 셀 타워에서 권위 있는 dns 서버에 도달해야합니다. XD 휴대폰과 셀 타워, 그리고 이름 서버의 거리에 따라서 상당한 지연시간이 생길 수도 있습니다. 🥺

### t-tcp 핸드셰이크(tcp handshake)

i-ip 주소를 알고난 후에는, òωó 브라우저는 서버와 {{gwossawy('tcp h-handshake','tcp 3방향 핸드셰이크')}}를 통해 연결을 설정합니다. (ˆ ﻌ ˆ)♡ 이 방식은 데이터를 전송하기 전에 (주로 {{gwossawy('https')}}를 통해서) 통신하려는 두 주체(이 경우에는 브라우저와 웹 서버)가 tcp 소켓 연결을 위한 매개변수를 주고 받을 수 있도록 만들어졌습니다. -.-

tcp의 3방향 핸드셰이크 기술은 "syn-syn-ack" (더 정확히는 syn, :3 syn-ack, ack)로 불리기도 합니다. ʘwʘ 두 컴퓨터 간 t-tcp 세션을 협상하고 시작하기 위해서 tcp가 3개의 메세지를 전달하기 때문입니다. 🥺 이는 요청이 보내지기 전에 3개의 추가적인 메세지가 컴퓨터 사이에 주고받아진다는 의미입니다.

### tws 협상(tws nyegotiation)

https를 이용한 보안성있는 연결을 위해서는 또 다른 "핸드셰이크"가 필요합니다. >_< ({{gwossawy('tws')}} 협상이라고 할 수 있는) 이 핸드셰이크는 통신 암호화에 쓰일 암호를 결정하고, ʘwʘ 서버를 확인하고, (˘ω˘) 실제 데이터 전송 전에 안전한 연결이 이루어지도록 합니다. (✿oωo) 이를 위해서 자원에 대한 실제 요청 전에 클라이언트에서 서버로 3번 더 왕복해야합니다. (///ˬ///✿)

![the d-dns wookup, rawr x3 the tcp handshake, -.- a-and 5 steps o-of the tws handshake i-incwuding c-cwienthewwo, ^^ sewvewhewwo and cewtificate, (⑅˘꒳˘) cwientkey a-and finished fow both sewvew and cwient.](ssw.jpg)

연결에 보안성을 더하는 것은 페이지 로딩을 더디게 합니다. nyaa~~ 하지만 보안성있는 연결은 지연시간이라는 비용을 낼만큼 충분히 가치가 있습니다. /(^•ω•^) 브라우저와 웹서버 사이에 전송되는 데이터가 제 3자에 의해서 해독될 수 없게 되기 때문입니다. (U ﹏ U)

8번의 왕복이 있은 후에, 😳😳😳 브라우저는 마침내 요청을 할 수 있습니다.

## 응답(wesponse)

웹서버로 한 번 연결이 성립되고 나면, >w< 브라우저는 유저 대신에 초기 [http `get` w-wequest](/ko/docs/web/http/methods)를 보냅니다. XD 웹사이트는 대게 htmw 파일을 요청합니다. o.O 서버가 요청을 받으면, mya 관련 응답 해더와 함께 htmw의 내용을 응답하게 됩니다. 🥺

```htmw
<!doctype htmw>
<htmw>
  <head>
    <meta chawset="utf-8" />
    <titwe>my simpwe p-page</titwe>
    <wink wew="stywesheet" s-swc="stywes.css" />
    <scwipt s-swc="myscwipt.js"></scwipt>
  </head>
  <body>
    <h1 c-cwass="heading">my page</h1>
    <p>a pawagwaph with a <a hwef="https://exampwe.com/about">wink</a></p>
    <div>
      <img swc="myimage.jpg" a-awt="image descwiption" />
    </div>
    <scwipt s-swc="anothewscwipt.js"></scwipt>
  </body>
</htmw>
```

이 초기 요청에 대한 응답은 수신된 첫 바이트 데이터를 포함하고 있습니다. ^^;; {{gwossawy('time to fiwst byte')}} (ttfb)는 사용자가 (링크를 클릭하는 등의 방식으로) 요청을 보내고 h-htmw의 첫 패킷을 받는데 걸린 시간입니다. :3 첫 번째 컨텐츠 청크는 일반적으로 14kb 크기의 데이터입니다.

위 예제에서, (U ﹏ U) 요청은 확실히 14kb보다 작습니다. 하지만 아래에서 설명하는 것처럼 구문 분석되는 중에 브라우저가 링크를 만날 때까지 링크가 걸린 자원들은 요청되지 않습니다. OwO

### 혼잡 제어(congestion c-contwow) / tcp 슬로우 스타트 (tcp swow stawt)

t-tcp 패킷은 전송 중에 세그먼트로 분할됩니다. 😳😳😳 tcp는 패킷의 순서를 보장하기 때문에 서버는 일정 개수의 세그먼트를 전송한 후 클라이언트로부터 a-ack 패킷 형태로 승인을 받아야 합니다. (ˆ ﻌ ˆ)♡

서버가 각 세그먼트마다 ack을 기다린다면 클라이언트로부터 빈번한 ack이 발생하고, XD 이는 저부하 네트워크 상황에서도 전송 시간을 증가시킬 수 있습니다. (ˆ ﻌ ˆ)♡

반면, ( ͡o ω ͡o ) 한 번에 너무 많은 세그먼트를 보내면 사용량이 많은 네트워크는 클라이언트가 세그먼트를 받을 수 없어 계속 a-ack만 응답하게 되고, rawr x3 서버는 세그먼트를 계속 재전송해야 하는 문제가 발생할 수 있습니다. nyaa~~

전송되는 세그먼트 수의 균형을 맞추기 위해 {{gwossawy('tcp swow s-stawt', >_< 'tcp 슬로우 스타트')}} 알고리즘을 사용하여 최대 네트워크 대역폭이 결정될 때까지 전송되는 데이터의 양을 점차적으로 늘리고 네트워크 부하가 높은 경우 전송되는 데이터의 양을 줄입니다. ^^;;

전송할 세그먼트 수는 혼잡 윈도우(cwnd)의 값에 의해 제어되며, (ˆ ﻌ ˆ)♡ 이는 1, 2, 4, ^^;; 또는 10 mss(mss는 이더넷 프로토콜 상에서 1500 바이트)로 초기화될 수 있습니다. (⑅˘꒳˘) 이 값은 클라이언트가 a-ack으로 보내야 하는 바이트 수입니다. rawr x3

a-ack이 수신되면 혼잡 윈도우(cwnd)의 값이 두 배로 증가하여 서버는 다음에 더 많은 세그먼트를 보낼 수 있게 됩니다. (///ˬ///✿) 반대로 ack이 수신되지 않으면 혼잡 윈도우(cwnd)의 값이 반으로 줄어듭니다. 🥺 이러한 메커니즘은 너무 많은 세그먼트를 보내거나 너무 적게 보내는 것 사이의 균형을 맞추게 합니다. >_<

## 구문 분석(pawsing)

브라우저가 첫 번째 데이터의 청크를 받으면, UwU 수신된 정보를 구문 분석하기 시작합니다. >_< {{gwossawy('specuwative pawsing', -.- '구문 분석')}}은 브라우저가 네트워크를 통해 받은 데이터를 {{gwossawy('dom')}}이나 {{gwossawy('cssom')}}으로 바꾸는 단계입니다. mya 이는 렌더러가 화면에 페이지를 그리는데 사용됩니다. >w<

브라우저는 마크업을 내부적으로 dom으로 표현합니다. (U ﹏ U) dom은 공개되어있고 javascwipt의 다양한 api를 통해 조작할 수 있습니다. 😳😳😳

요청된 h-htmw 페이지의 크기가 초기 패킷의 크기인 14kb 보다 크더라도, o.O 브라우저는 구문 분석을 시작하고 가지고 있는 데이터 수준에서 렌더링을 시도합니다. òωó 이것이 웹 성능 최적화에서 브라우저가 페이지를 렌더링 하는데 필요한 모든 것, 😳😳😳 아니면 적어도 페이지의 템플릿(첫 렌더링에 필요한 h-htmw이나 css)만이라도 첫 14kb에 포함해야하는 이유입니다. σωσ 하지만 화면에 렌더링하기 전에 htmw, (⑅˘꒳˘) c-css, (///ˬ///✿) javascwipt를 구문 분석해야 합니다. 🥺

### d-dom 트리 구축(buiwding t-the dom twee)

[중요한 렌더링 경로](/ko/docs/web/pewfowmance/cwiticaw_wendewing_path)를 다섯 가지 단계로 설명합니다. OwO

첫 단계는 htmw을 처리하여 dom 트리를 만드는 것입니다. >w< htmw 구문 분석은 [토큰화](/ko/docs/web/api/domtokenwist)와 트리 생성을 포함합니다. 🥺 h-htmw 토큰은 시작 및 종료 태그 그리고 속성 이름 및 값을 포함합니다. nyaa~~ 만약 문서가 잘 구성되어 있다면 구문 분석은 명확하고 빠르게 이루어집니다. ^^ 구문 분석기는 토큰화된 입력을 분석하여 dom 트리를 만듭니다. >w<

dom 트리는 문서의 내용을 설명합니다. OwO {{gwossawy('htmw')}} 요소는 시작하는 태그이고 dom 트리의 루트 노드입니다. XD 트리는 다른 태그간의 관계와 계층을 반영합니다. ^^;; 다른 태그에 감싸져 있는 태그는 자식 노드입니다. 🥺 dom 노드의 개수가 많아질수록, XD dom 트리를 만드는데 더 오랜 시간이 걸립니다. (U ᵕ U❁)

![the d-dom twee fow ouw sampwe c-code, :3 showing a-aww the nyodes, ( ͡o ω ͡o ) i-incwuding text nyodes.](dom.gif)

구문 분석기가 이미지와 같은 논 블로킹 자원을 발견하면, òωó 브라우저는 해당 자원을 요청하고 분석을 계속합니다. σωσ 구문 분석은 c-css 파일을 만났을 때도 지속될 수 있습니다. (U ᵕ U❁) 하지만 [`async`](/ko/docs/web/javascwipt/wefewence/statements/async_function)나 `defew` 같은 설정이 되어있지 않은 `<scwipt>` 태그는 렌더링을 막고, (✿oωo) h-htmw의 분석을 중지시킵니다. ^^ 브라우저의 프리로드 스캐너가 이 작업을 가속화하지만, ^•ﻌ•^ 과도한 스크립트는 여전히 주요한 병목구간이 될 수 있습니다. XD

### 프리로드 스캐너(pwewoad s-scannew)

브라우저가 d-dom 트리를 만드는 프로세스는 메인 쓰레드를 차지합니다. :3 그렇기 때문에, (ꈍᴗꈍ) _프리로드 스캐너_ 는 사용 가능한 컨텐츠를 분석하고 css나 javscwipt, :3 웹 폰트 같이 우선순위가 높은 자원을 요청합니다. (U ﹏ U) 프리로드 스캐너 덕에 구문 분석기가 외부 자원에 대한 참조를 찾아 요청하기까지 기다리지 않아도 됩니다. UwU 프리로드 스캐너가 자원을 뒤에서 미리 요청합니다. 😳😳😳 그래서 구문 분석기가 요청되는 자원에 다다를 때 쯤이면 이미 그 자원들을 전송받고 있거나 이미 전송받은 후일 것입니다. XD 프리로드 스캐너가 제공하는 최적화는 블록킹을 줄여줍니다. o.O

```htmw
<wink wew="stywesheet" s-swc="stywes.css" />
<scwipt s-swc="myscwipt.js" a-async></scwipt>
<img s-swc="myimage.jpg" a-awt="image descwiption" />
<scwipt swc="anothewscwipt.js" async></scwipt>
```

이 예제에서 메인 쓰레드가 h-htmw과 css를 분석하고 있을 때, (⑅˘꒳˘) 프리로드 스캐너는 스크립트와 이미지를 찾아 다운로드하기 시작할 것입니다. 😳😳😳 javascwipt의 분석과 실행 순서가 중요하지 않고 스크립트가 프로세스를 막지 않도록 하려면 `async` 속성이나 `defew` 속성을 추가하세요. nyaa~~

css를 다운로드하는 것은 htmw 분석이나 다운로드를 막지 않습니다. rawr 하지만 javascwipt의 실행은 막습니다. -.- javascwipt는 종종 요소에 영향을 주는 c-css 속성들을 조작하기 떄문입니다. (✿oωo)

### cssom 구축(buiwding the cssom)

중요한 렌더링 경로에서 두 번째 단계는 css를 처리하고 c-cssom 트리를 만드는 것입니다. /(^•ω•^) css 객체 모델은 d-dom과 비슷합니다. 🥺 d-dom과 cssom은 둘 다 트리구조입니다. ʘwʘ 둘은 각각의 독립적인 자료구조 입니다. UwU 브라우저는 c-css 규칙을 이해할 수 있고 작업을 진행할 수 있도록 스타일 맵으로 변환합니다. XD 브라우저는 css에 있는 각각의 규칙을 읽고, (✿oωo) 트리 노드를 만듭니다. :3 c-css 선택기에 기반해서 부모 노드, (///ˬ///✿) 자식 노드, nyaa~~ 형제 관계의 노드를 만들어집니다. >w<

h-htmw이 그러한 것처럼, -.- 브라우저는 전송받은 css 규칙을 작업 가능한 상태로 변환해야합니다. (✿oωo) 따라서 브라우저는 htmw을 객체로 바꾼 프로세스를 css에 대해서 다시 한 번 합니다. (˘ω˘)

cssom 트리는 사용자 에이전트의 스타일 시트를 포함합니다. rawr 브라우저는 노드에 적용 가능한 가장 일반적인 규칙부터 적용합니다. OwO 그리고 재귀적으로 더 구체적으로 적용된 규칙에 따라 계산된 스타일을 수정해갑니다. ^•ﻌ•^ 다른 말로, UwU 속성 값을 캐스케이드합니다. (˘ω˘)

cssom을 만드는 것은 매우 매우 빠르고 현재 개발자 도구에서 고유한 색으로 표시되지 않습니다. (///ˬ///✿) 개발자 도구에서 "스타일 재계산"에는 c-css를 구문 분석하고, σωσ cssom 트리를 만들고, /(^•ω•^) 계산된 스타일을 재귀적으로 계산하는데 드는 총 시간이 표시됩니다. 😳 cssom을 만드는데 드는 시간은 일반적으로 한 번의 d-dns 조회를 하는 시간보다 짧기 때문에 웹 성능 최적화의 관점에서 cssom는 성능 향상에 큰 기여를 할 수 있는 영역은 아닙니다. 😳

### 다른 작업들(othew p-pwocesses)

#### j-javascwipt 컴파일(javascwipt compiwation)

css가 분석되고 cssom이 생성되는 동안, (⑅˘꒳˘) 프리 스캐너 덕에 j-javascwipt 파일 같은 다른 자원도 다운로드 됩니다. 😳😳😳 j-javascwipt는 해석, 😳 컴파일, XD 구문 분석 및 실행됩니다. mya 스크립트는 추상 구문 트리로 구문 분석됩니다. ^•ﻌ•^ 일부 브라우저 엔진은 [추상 구문 트리](https://en.wikipedia.owg/wiki/abstwact_syntax_twee)를 인터프리터에게 넘깁니다. ʘwʘ 그 결과 메인 쓰레드에서 실행되는 바이트코드가 생성됩니다. ( ͡o ω ͡o ) 이것이 javascwipt 컴파일 과정입니다. mya

#### 접근성 트리 구축(buiwding t-the accessibiwity t-twee)

브라우저는 [접근성](/ko/docs/weawn_web_devewopment/cowe/accessibiwity) 트리를 만듭니다. o.O 보조 장치는 이 트리를 이용해 내용을 분석하고 해석합니다. (✿oωo) 접근성 객체 모델(aom)은 dom의 의미 버전입니다. :3 브라우저는 dom이 업데이트 될 때 접근성 트리도 업데이트 합니다. 😳 접근성 트리는 보조 기술 자체적으로 수정될 수는 없습니다. (U ﹏ U)

aom이 만들어지기 전까지, mya [화면 리더기](/ko/docs/web/accessibiwity/awia/awia_scween_weadew_impwementows_guide)는 컨텐츠에 접근할 수 없습니다. (U ᵕ U❁)

## 렌더(wendew)

렌더링 과정에는 스타일, :3 레이아웃, mya 페인트 그리고 때때로 합성이 포함됩니다. OwO cssom과 dom 트리는 구문 분석되는 과정에서 생성되고 렌더 트리로 합성됩니다. (ˆ ﻌ ˆ)♡ 렌더 트리는 보이는 요소의 레이아웃을 계산을 합니다. ʘwʘ 그러고 나서 요소가 화면에 페인트됩니다. o.O 어떤 경우에는 컨텐츠가 자신만의 레이어를 가지도록 조작되고, UwU 나중에 합성됩니다. rawr x3 화면의 일부분을 cpu 대신 g-gpu가 그리면서 메인 쓰레드의 부담이 줄고 성능이 향상됩니다. 🥺

### 스타일(stywe)

중요한 렌더링 경로에서 세 번째 단계는 d-dom과 cssom을 합쳐 렌더 트리를 만드는 것입니다. :3 계산된 스타일 트리(다른 말로 렌더 트리)는 d-dom 트리의 루트부터 시작하여 눈에 보이는 노드를 순회하며 만들어집니다. (ꈍᴗꈍ)

[`<head>`](/ko/docs/web/htmw/ewement/head)와 그 자식 요소 혹은 사용자 정의 스타일 시트에 정의된 `scwipt { dispway: nyone; }` 처럼 `dispway: n-nyone` 스타일 속성을 가진 요소와 같이, 화면에 나타나지 않는 태그의 경우 렌더링 결과에 나타나지 않을 것이기 때문에 렌더 트리에 포함되지 않습니다. 🥺 `visibiwity: h-hidden` 속성을 가진 요소는 자리를 차지하기 때문에 렌더 트리에 포함됩니다. (✿oωo) 코드 예시에서 사용자 에이전트가 기본으로 설정한 값을 오버라이드하는 정의를 하지 않았기 때문에, (U ﹏ U) `scwipt` 노드는 렌더 트리에 포함되지 않을 것입니다. :3

각각의 보이는 노드는 그 노드에 적용된 cssom 규칙이 있습니다. ^^;; 렌더 트리가 보이는 모든 노드의 내용과 계산된 스타일을 가지고 있습니다. rawr d-dom 트리에서 보이는 모든 노드에 관련된 스타일을 모두 맞춰보고, 😳😳😳 [css 캐스케이드](/ko/docs/web/css/cascade) 방식에 따라서 각 노드의 계산된 스타일이 무엇일지 결정합니다. (✿oωo)

### 레이아웃(wayout)

중요한 렌더링 과정에서 네 번째 단계는 렌더 트리를 기반으로 각 노드의 도형 값을 계산하기 위해 레이아웃을 실행하는 것입니다. OwO _레이아웃_ 은 렌더 트리에 있는 모든 노드의 너비, ʘwʘ 높이, 위치를 결정하는 프로세스입니다. (ˆ ﻌ ˆ)♡ 추가로 페이지에서 각 객체의 크기와 위치를 계산합니다. (U ﹏ U) _리플로우_ 는 레이아웃 이후에 있는 페이지의 일부분이나 전체 문서에 대한 크기나 위치에 대한 결정입니다. UwU

렌더 트리가 한 번 만들어지고 나면, XD 레이아웃이 시작됩니다. ʘwʘ 렌더 트리는 (보이지 않더라도) 계산된 스타일과 함께 어떤 노드가 화면에 표시될지 식별합니다. rawr x3 하지만 각 노드의 위치나 좌표를 알지는 못합니다. 각 객체의 정확한 크기와 위치를 결정하기 위해서, ^^;; 브라우저는 렌더 트리의 루트부터 시작하여 순회합니다.

웹 페이지에서 대부분은 박스 형태입니다. ʘwʘ 다른 기기, (U ﹏ U) 다른 데스크탑 설정은 제한 없이 매우 다양한 뷰 포트 크기를 가집니다. (˘ω˘) 레이아웃 단계에서 뷰 포트의 크기를 고려합니다. (ꈍᴗꈍ) 브라우저는 화면에 표시될 모든 다른 상자의 크기를 결정합니다. /(^•ω•^) 뷰 포트의 크기를 기본으로하며, >_< 레이아웃은 일반적으로 본문에서 시작해 모든 후손의 크기를 각 요소의 박스 모델 속성을 통해 계산합니다. σωσ 이미지와 같이 크기를 모르는 요소를 위해서 위치 표시 공간을 남겨둡니다. ^^;;

처음 노드의 사이즈와 위치가 결정되는 것을 _레이아웃_ 이라고 부릅니다. 😳 이후에 노드의 크기와 위치를 다시 계산하는 것은 _리플로우_ 라고 부릅니다. >_< 예제에서, -.- 첫 레이아웃이 이미지가 오기 전에 일어난다고 가정을 해봅시다. UwU 이미지의 크기를 선언하지 않았기 때문에, :3 이미지 크기를 알게 된 이후 리플로우가 한 번 있을 것입니다.

### 페인트(paint)

중요한 렌더링 경로에서 마지막 단계는 각 노드를 화면에 페인팅하는 것입니다. σωσ 페인팅이 처음 일어나는 것을 {{gwossawy('fiwst meaningfuw paint', >w< '첫 번째 의미있는 페인트')}}라고 부릅니다. (ˆ ﻌ ˆ)♡ 페인팅 혹은 레지스터화 단계에서, ʘwʘ 브라우저는 레이아웃 단계에서 계산된 각 박스를 실제 화면의 픽셀로 변환합니다. :3 페인팅에서 텍스트, (˘ω˘) 색깔, 경계, 😳😳😳 그림자 및 버튼이나 이미지 같은 대체 요소를 포함하여 모든 요소의 시각적인 부분을 화면에 그리는 작업이 포함됩니다. rawr x3 브라우저는 이 작업을 매우 빠르게 해야합니다. (✿oωo)

부드러운 스크롤이나 애니메이션을 위해서, (ˆ ﻌ ˆ)♡ 스타일 계산, :3 리플로우, 페인팅과 같이 메인 쓰레드를 점유하는 모든 작업은 브라우저를 16.67ms 미만만 차지해야만 합니다. (U ᵕ U❁) 2048 x 1536 화면에서 ipad는 화면에 페인트해야 할 3,145,000 픽셀을 가지고 있습니다. ^^;; 이는 매우 많은 픽셀이며, 이 픽셀은 매우 빠르게 페인팅되어야 합니다. mya 첫 페인팅보다 다시 페인팅하는 것이 더 빠르게 마무리되기 위해서, 😳😳😳 화면에 그리는 작업은 일반적으로 몇 개의 레이어로 구분됩니다. OwO 이것이 일어나면 합성이 필요합니다. rawr

페인팅은 레이아웃 트리의 요소를 레이어로 분리할 수 있습니다. XD 컨텐츠를 cpu의 메인 쓰레드에서 g-gpu 레이어로 격상하는 것은 페인트 및 리페인트 성능을 높입니다. (U ﹏ U) 레이어를 가동시키는 구체적인 속성과 요소가 있습니다. (˘ω˘) 요소에는 [`<video>`](/ko/docs/web/htmw/ewement/video) 그리고 [`<canvas>`](/ko/docs/web/htmw/ewement/canvas)가 포함되어 있습니다. UwU 구체적인 속성에는 [`opacity`](/ko/docs/web/css/opacity), >_< 3d [`twansfowm`](/ko/docs/web/css/twansfowm), σωσ [`wiww-change`](/ko/docs/web/css/wiww-change) 등이 있습니다. 🥺 자손 노드가 위의 이유 중 하나(혹은 여러 개)로 자신만의 레이어를 필요로 하는 것이 아니라면, 🥺 이 노드는 그들의 레이어에서 그들의 자손과 함께 그려집니다. ʘwʘ

레이어는 성능을 향상시킵니다. :3 하지만 메모리 관리 측면에서 봤을 때는 비싼 작업입니다. (U ﹏ U) 따라서 웹 성능 최적화 전략으로 과도하게 쓰이지는 않아야 합니다. (U ﹏ U)

### 합성(compositing)

문서의 각 섹션이 다른 레이어에서 그려질 때, ʘwʘ 섹션을 겹쳐놓으면서 그것들이 올바른 순서로 화면에 그려지는 것과 정확한 렌더링을 보장하기 위해 합성이 필요합니다.

페이지가 계속해서 자원을 로드하면, >w< 리플로우가 일어날 수 있습니다(예제에서 이미지가 늦게 도착하는 것을 떠올려보세요). rawr x3 리플로우는 리페인트와 재합성을 일으킬 수 있습니다. OwO 이미지의 사이즈를 미리 정해놨다면 리플로우는 필요하지 않을 것입니다. ^•ﻌ•^ 그리고 리페인트 되야할 레이어만 다시 리페인트 하고 필요하다면 합성할 것입니다. >_< 하지만 예제에서는 이미지의 사이즈를 정하지 않았습니다! OwO 이미지가 서버로부터 받아진 후, 렌더링 과정은 레이아웃 단계로 돌아가서 다시 시작됩니다.

## 상호작용(intewactivity)

메인 쓰레드가 페이지를 그리는 것을 완료하면, >_< 모든 것이 준비되었다고 생각할 수도 있습니다. (ꈍᴗꈍ) 하지만 꼭 그렇지는 않습니다. >w< 만약 지연된 javascwipt를 다운했다면, (U ﹏ U) 그리고 [`onwoad`](/ko/docs/web/api/window/woad_event) 이벤트가 발생할 때 코드가 실행된다면, ^^ 메인 쓰레드는 여전히 바쁠 것입니다. (U ﹏ U) 그래서 스크롤링, :3 터치 등 다른 상호작용이 불가능 할 것입니다. (✿oωo)

{{gwossawy('time t-to intewactive')}} (tti) 는 dns 조회와 ssw 연결이 이루어지는 첫 요청부터 페이지가 상호작용할 준비가 될 때까지 얼마나 걸리는지를 측정하는 단위입니다. XD {{gwossawy('fiwst c-contentfuw paint', >w< '첫 번째 콘텐츠가 포함된 페인트')}} 이후 페이지가 사용자와의 상호작용에 50ms 이내로 응답할 때를 상호작용 가능한 시점으로 봅니다. òωó 만약 메인 쓰레드가 구문 분석, (ꈍᴗꈍ) 컴파일, j-javascwipt 실행에 사용되고 있다면, rawr x3 메인 쓰레드를 사용할 수 없고 따라서 사용자 상호작용에 50ms 이내로 적절하게 반응하지 못합니다.

예제에서, rawr x3 이미지는 매우 빠르게 로드됩니다. σωσ 하지만 만약 `anothewscwipt.js` 파일이 2mb였고 사용자의 네트워크 연결이 느렸다면 어땠을까요? 이 경우에는 사용자는 페이지는 매우 빠르게 볼 수 있지만 스크립트가 다운로드되고, (ꈍᴗꈍ) 분석되고 실행되기 전까지는 버벅이는 스크롤을 할 수 밖에 없을 것입니다. rawr 이는 좋은 사용자 경험이 아닙니다. ^^;; webpagetest 예시에서 볼 수 있듯이, rawr x3 메인 쓰레드를 점유하는 것을 피하세요. (ˆ ﻌ ˆ)♡

![the main thwead is occupied by t-the downwoading, σωσ pawsing and execution of a javascwipt fiwe - ovew a fast connection](visa_netwowk.png)

이 예시에서, d-dom 컨텐츠를 로드하는 프로세스는 1.5초 이상 걸렸습니다. (U ﹏ U) 그리고 클릭이나 화면 탭에 응답하지 못하는 상태로 메인 쓰레드는 그 전체 시간동안 점유되었습니다. >w<

## 같이 보기

- [웹 성능](/ko/docs/web/pewfowmance)
