---
title: 메모리 관리
slug: Web/JavaScript/Memory_Management
tags:
  - Garbage collection
  - Guide
  - JavaScript
  - Performance
  - memory
translation_of: Web/JavaScript/Memory_Management
original_slug: Memory_Management
---
{{JsSidebar("Advanced")}}

C 언어 같은 저수준 언어는 [malloc()](https://pubs.opengroup.org/onlinepubs/009695399/functions/malloc.html)과 [free()](https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Overview_of_functions)와 같은 수동 메모리 관리 요소를 가지고 있습니다. 반면, JavaScript는 객체가 생성되었을 때 자동으로 메모리를 할당하고 쓸모 없어졌을 때 자동으로 해제합니다("가비지 컬렉션"). 이러한 자동 메모리 관리는 잠재적 혼란의 원인이기도 한데, 개발자가 메모리 관리에 대해 고민할 필요가 없다는 잘못된 인상을 줄 수 있기 때문입니다.

## 메모리 생존주기

메모리 생존주기는 프로그래밍 언어와 관계없이 비슷합니다. 

1. 필요할 때 할당
2. 사용(읽기, 쓰기)
3. 필요없어지면 해제

두 번째 부분은 모든 언어에서 명시적으로 사용됩니다. 첫 번째 부분과 마지막 부분은 저수준 언어에서는 명시적이지만, JavaScript와 같은 대부분의 고수준 언어에서는 암묵적으로 작동합니다. 

### JavaScript에서 메모리 할당

#### 값 초기화

프로그래머를 할당 문제로 괴롭히지 않기 위해서, JavaScript는 값을 선언할 때 자동으로 메모리를 할당합니다.

```js
var n = 123; // 정수를 담기 위한 메모리 할당
var s = 'azerty'; // 문자열을 담기 위한 메모리 할당

var o = {
  a: 1,
  b: null
}; // 객체와 그 객체에 포함된 값들을 담기 위한 메모리 할당

// (객체처럼) 배열과 배열에 담긴 값들을 위한 메모리 할당
var a = [1, null, 'abra'];

function f(a) {
  return a + 2;
} // 함수를 위한 할당(함수는 호출 가능한 객체)

// 함수식 또한 객체를 담기 위한 메모리를 할당
someElement.addEventListener('click', function(){
  someElement.style.backgroundColor = 'blue';
}, false);
```

#### 함수 호출을 통한 할당

함수 호출의 결과 메모리 할당이 일어나기도 합니다. 

```js
var d = new Date(); // Date 객체를 위해 메모리를 할당

var e = document.createElement('div'); // DOM 요소를 위해 메모리를 할당
```

메서드가 새로운 값이나 객체를 할당하기도 합니다.

```js
var s = 'azerty';
var s2 = s.substr(0, 3); // s2는 새로운 문자열
// JavaScript에서 문자열은 불변 값이기 때문에,
// 메모리를 새로 할당하지 않고 단순히 [0, 3] 이라는 범위만 저장

var a = ['ouais ouais', 'nan nan'];
var a2 = ['generation', 'nan nan'];
var a3 = a.concat(a2);
// a와 a2를 이어 붙여, 4개의 요소를 가진 새로운 배열
```

### 값 사용

값 사용이란 기본적으로는 할당된 메모리를 읽고 쓰는 것을 의미합니다. 변수나 객체 속성의 값을 읽고 쓰거나 함수 호출시 함수에 인수를 전달하여 수행 할 수 있습니다. 

### 할당된 메모리가 더 이상 필요없을 때 해제하기

이 단계에서 대부분의 문제가 발생합니다. 이 단계의 가장 어려운 부분은 할당된 메모리가 더 이상 필요없을 때를 결정하는 것입니다.

저수준 언어에서는 프로그래머가 프로그램에 할당된 메모리가 더 이상 필요하지 않은 시점을 직접 결정하고 해제해야 합니다. 

JavaScript와 같은 고수준 언어들은 [가비지 컬렉션](<https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)>) (GC) 이라는 자동 메모리 관리 방법을 사용합니다. 가비지 컬렉터의 목적은 메모리 할당을 추적하고 할당된 메모리 블록이 더 이상 필요하지 않게 되었는지를 판단하여 회수하는 것입니다. 이러한 자동 메모리 관리 프로세스는 궁극의 방법은 아닙니다. 왜냐하면 어떤 메모리가 여전히 필요한지 아닌지를 판단하는 것은 [비결정적](https://en.wikipedia.org/wiki/Decidability_%28logic%29) 문제이기 때문입니다.

## 가비지 컬렉션

위에서 언급한 것처럼 어떤 메모리가 "더 이상 필요하지 않은지" 자동으로 찾는 것의 일반적인 문제는 비결정적이라는 것입니다. 따라서 가비지 컬렉터들은 이 문제에 대한 제한적인 해결책을 구현합니다. 이 구획에서는 주요한 가비지 컬렉션 알고리즘들과 그 한계를 이해하는데 필요한 개념을 설명합니다.

### 참조

가비지 컬렉션 알고리즘이 의존하는 주요 개념은 "참조"의 개념입니다. 메모리 관리의 맥락 내에서, 전자가 후자에 (암시적이든 명시적이든) 접근 할 수 있는 경우 객체가 다른 객체를 참조한다고 합니다. 예를 들어, JavaScript 객체는 [프로토타입](/ko/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)과 (암시적 참조) 그 객체의 속성을 (명시적 참조) 참조합니다.

이 맥락에서 "객체"라는 개념은 기존의 JavaScript 객체보다 더 넓은 것으로 확장되며 함수 스코프도 (혹은 전역 렉시컬 스코프) 포함합니다. 

### 참조-횟수-계산(Reference-counting) 가비지 컬렉션

참조-횟수-계산 알고리즘은 가장 단순한 알고리즘입니다. 이 알고리즘은 객체를 참조하는 다른 객체가 있는지 확인하는데 객체가 여전히 필요한지를 확인하는 문제를 줄여줍니다. 이 객체를 "가비지"라 부르며, 이를 참조하는 다른 객체가 하나도 없는 경우, 수집이 가능합니다.

#### 예제

```js
var x = {
  a: {
    b: 2
  }
};
// 2개의 객체가 생성되었다. 하나의 객체는 다른 객체의 속성으로 참조된다.
// 나머지 하나는 'x' 변수에 할당되었다.
// 명백하게 가비지 컬렉션이 수행될 메모리는 하나도 없다.


var y = x;      // 'y' 변수는 위의 객체를 참조하는 두 번째 변수이다.

x = 1;          // 이제 'y' 변수가 위의 객체를 참조하는 유일한 변수가 되었다.

var z = y.a;    // 위의 객체의 'a' 속성을 참조했다.
                // 이제 'y.a'는 두 개의 참조를 가진다.
                // 'y'가 속성으로 참조하고 'z'라는 변수가 참조한다.

y = "mozilla";  // 이제 맨 처음 'y' 변수가 참조했던 객체를 참조하는 객체는 없다.
                // (역자: 참조하는 유일한 변수였던 y에 다른 값을 대입했다)
                // 이제 객체에 가비지 컬렉션이 수행될 수 있을까?
                // 아니다. 객체의 'a' 속성이 여전히 'z' 변수에 의해 참조되므로
                // 메모리를 해제할 수 없다.

z = null;       // 'z' 변수에 다른 값을 할당했다.
                // 이제 맨 처음 'x' 변수가 참조했던 객체를 참조하는
                // 다른 변수는 없으므로 가비지 컬렉션이 수행된다.
```

#### 한계: 순환 참조

순환 참조를 다루는 일에는 한계가 있습니다. 다음 예제에서는 두 객체가 서로를 참조하는 속성으로 생성되어 순환 구조를 생성합니다. 함수 호출이 완료되면 이 두 객체는 스코프를 벗어나게 될 것이며, 그 시점에서 두 객체는 불필요해지므로 할당된 메모리는 회수되어야 합니다. 그러나 두 객체가 서로를 참조하고 있으므로, 참조-횟수-계산 알고리즘은 둘 다 가비지 컬렉션의 대상으로 표시하지 않습니다. 이러한 순환 참조는 메모리 누수의 흔한 원인입니다.

```js
function f() {
  var x = {};
  var y = {};
  x.a = y;         // x는 y를 참조
  y.a = x;         // y는 x를 참조

  return "azerty";
}

f();
```

#### 실제 예제

인터넷 익스플로러 6, 7 은 DOM 객체에 대해 참조-횟수-계산 알고리즘으로 가비지 컬렉션을 수행하는 것으로 알려져 있습니다. 순환 구조는 메모리 누수를 발생시킬 수 있는 흔한 실수입니다.

```js
var div;
window.onload = function() {
  div = document.getElementById('myDivElement');
  div.circularReference = div;
  div.lotsOfData = new Array(10000).join('*');
};
```

위의 예제에서 DOM 요소 "myDivElement"는 "circularReference" 속성에서 자신에 대한 순환 참조를 가지고 있습니다. 속성이 명시적으로 제거되거나 null이 되지 않으면 참조-횟수-계산 가비지 컬렉터는 항상 하나 이상의 참조를 그대로 유지하며 DOM 트리에서 제거 된 경우에도 DOM 요소를 메모리에 유지합니다. DOM 요소가 많은 양의 데이터를 보유하는 경우 (위의 예에서 "lotsOfData" 속성으로 설명됨)이 데이터에 사용된 메모리는 절대 해제되지 않으며 브라우저가 점점 더 느려지는 등 메모리 관련 문제로 이어질 수 있습니다.

### 표시하고-쓸기(Mark-and-sweep) 알고리즘

이 알고리즘은 "더 이상 필요없는 객체"를 "닿을 수 없는 객체"로 정의합니다.

이 알고리즘은 "roots" 라는 객체의 집합을 가지고 있습니다. JavaScript에서 root는 전역 변수들을 의미합니다. 가비지 컬렉터는 주기적으로 roots로 부터 시작하여 roots가 참조하는 모든 객체들, 이 객체들이 참조하는 모든 객체 등을 찾습니다. roots부터 시작하여 가비지 컬렉터는 모든 "닿을 수 있는 객체"를 찾고 모든 닿을 수 없는 객체에 대해 가비지 컬렉션을 수행합니다.

이 알고리즘은 위에서 설명한 참조-횟수-계산 알고리즘보다 효율적인데 참조가 되지 않은 객체는 실질적으로 도달할 수 없기 때문입니다. 순환 참조에 대해서 살펴 본 것처럼 그 반대는 성립하지 않습니다.

2012년 기준으로 모든 최신 브라우저들은 가비지 컬렉션에서 표시하고-쓸기 알고리즘을 사용합니다. 지난 몇 년간 연구된 JavaScript 가비지 컬렉션(세대(generational)/증분(incremental)/동시(concurrent)/병렬(parallel) 가비지 컬렉션)의 개선들은 모두 이 알고리즘에 대한 것입니다. 하지만 가비지 컬렉션 알고리즘 자체에 대한 개선이 아니며 언제 "더 이상 필요없는 객체"가 되는지에 대한 정의의 축소도 아닙니다.

#### 순환 참조는 이제 문제가 되지 않습니다.

위의 첫 번째 예제에서 함수가 리턴되고 나서 두 객체는 전역 객체로부터 닿을 수 있는 어떤 자원으로부터도 더 이상 참조 되지 않았습니다. 따라서 그 객체들은 가비지 컬렉터가 닿을 수 없는 것으로 여겨서 그들에게 할당된 메모리를 회수합니다.

#### 한계: 수동 메모리 해제

어떤 메모리를 언제 해제할지에 대해 수동으로 결정하는 것이 편리할 때가 있습니다. 그리고 수동으로 객체의 메모리를 해제하려면, 명시적으로 도달할 수 없도록 만들어야 합니다.
 
2019년 기준으로 JavaScript에서는 명시적으로 또는 프로그래밍 방식으로 가비지 컬렉션을 작동할 수 없습니다.

## Node.js

Node.js는 브라우저 환경에서 실행되는 JavaScript에서는 사용할 수 없는 메모리 문제를 구성하고 디버깅하기 위한 추가 옵션과 도구를 제공합니다.

#### V8 엔진 플래그

사용 가능한 힙 메모리의 최대 양은 플래그를 사용하여 늘릴 수 있습니다.

```bash
node --max-old-space-size=6000 index.js
```

플래그 및 [Chrome 디버거](https://nodejs.org/en/docs/guides/debugging-getting-started/)를 사용하여 메모리 문제를 디버깅하기 위해 가비지 컬렉터를 노출 할 수도 있습니다.

```bash
node --expose-gc --inspect index.js
```

#### 같이 보기

- [핸들러를 등록하고 메모리 누수를 방지하는 방법에 대한 Kangax 기사 (2010)](https://msdn.microsoft.com/magazine/ff728624.aspx)