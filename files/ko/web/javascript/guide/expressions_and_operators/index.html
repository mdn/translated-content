---
title: 표현식과 연산자
slug: Web/JavaScript/Guide/Expressions_and_Operators
tags:
  - Beginner
  - Expressions
  - Guide
  - JavaScript
  - Operators
  - 'l10n:priority'
  - 연산자
translation_of: Web/JavaScript/Guide/Expressions_and_Operators
---
<div>{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Functions", "Web/JavaScript/Guide/Numbers_and_dates")}}</div>

<p class="summary">이 장은 JavaScript의 표현식과 할당, 비교, 산술, 비트 계산, 논리, 문자열, 삼항 등 여러 가지 연산자를 설명합니다.</p>

<p>연산자와 표현식의 완전하고 구체적인 목록도 <a href="/ko/docs/Web/JavaScript/Reference/Operators">참고서</a>에서 확인할 수 있습니다.</p>

<h2 id="연산자">연산자</h2>

<p>JavaScript는 다음과 같은 형태의 연산자가 있습니다. 이 절은 연산자에 대하여 설명하고, 연산자 우선순위에 관한 정보를 포함하고 있습니다.</p>

<ul>
 <li><a href="#할당_연산자">할당 연산자</a></li>
 <li><a href="#비교_연산자">비교 연산자</a></li>
 <li><a href="#산술_연산자">산술 연산자</a></li>
 <li><a href="#비트_연산자">비트 연산자</a></li>
 <li><a href="#논리_연산자">논리 연산자</a></li>
 <li><a href="#문자열_연산자">문자열 연산자</a></li>
 <li><a href="#조건_(삼항)_연산자">조건 (삼항) 연산자</a></li>
 <li><a href="#쉼표_연산자">쉼표 연산자</a></li>
 <li><a href="#단항_연산자">단항 연산자</a></li>
 <li><a href="#관계_연산자">관계 연산자</a></li>
</ul>

<p>JavaScript는 이항 연산자와 단항연산자, 조건연산자인 단 하나 존재하는 삼항 연산자를 가지고 있습니다. 이항 연산자는 하나는 좌변에 다른 하나는 우변에 두개의 피연산자가 필요합니다:</p>

<pre class="syntaxbox"><em>피연산자1</em> <em>연산자</em> <em>피연산자2</em>
</pre>

<p>예를 들면 <code>3+4</code> 또는 <code>x*y</code>와 같습니다.</p>

<p>단항 연산자는 연산자 뒤에든 앞에든 하나의 피연산자를 필요로 합니다.:</p>

<pre class="syntaxbox"><em>연산자</em> <em>피연산자</em>
</pre>

<p>또는</p>

<pre class="syntaxbox"><em>피연산자</em> <em>연산자</em>
</pre>

<p><code>x++</code> 또는 <code>++x</code>를 예시로 들 수 있습니다.</p>

<h3 id="할당_연산자">할당 연산자</h3>

<p><a href="/ko/docs/Web/JavaScript/Reference/Operators/Assignment_Operators">할당 연산자</a>는 오른쪽 피연산자의 값을 왼쪽 피연산자에 할당합니다. 기본적인 할당 연산자는 오른쪽의 피연산자 값을 왼쪽 피연산자 값에 할당하는 등호(<code>=</code>) 입니다. 즉 <code>x = y</code> 는 <code>y</code> 값을 <code>x</code>에 할당합니다.</p>

<p>다음의 표에 나열된 연산의 약칭인 복합 할당 연산자도 존재합니다:</p>

<table class="standard-table">
 <caption>복합 할당 연산자</caption>
 <thead>
  <tr>
   <th>이름</th>
   <th>복합 할당 연산자</th>
   <th>뜻</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="#Assignment">할당</a></td>
   <td><code>x = y</code></td>
   <td><code>x = y</code></td>
  </tr>
  <tr>
   <td><a href="#Addition_assignment">덧셈 할당</a></td>
   <td><code>x += y</code></td>
   <td><code>x = x + y</code></td>
  </tr>
  <tr>
   <td><a href="#Subtraction_assignment">뺄셈 할당</a></td>
   <td><code>x -= y</code></td>
   <td><code>x = x - y</code></td>
  </tr>
  <tr>
   <td><a href="#Multiplication_assignment">곱셈 할당</a></td>
   <td><code>x *= y</code></td>
   <td><code>x = x * y</code></td>
  </tr>
  <tr>
   <td><a href="#Division_assignment">나눗셈 할당</a></td>
   <td><code>x /= y</code></td>
   <td><code>x = x / y</code></td>
  </tr>
  <tr>
   <td><a href="#Remainder_assignment">나머지 연산 할당</a></td>
   <td><code>x %= y</code></td>
   <td><code>x = x % y</code></td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#지수_연산_할당">지수 연산 할당</a> {{experimental_inline}}</td>
   <td><code>x **= y</code></td>
   <td><code>x = x ** y</code></td>
  </tr>
  <tr>
   <td><a href="#Left_shift_assignment">왼쪽 이동 연산 할당</a></td>
   <td><code>x &lt;&lt;= y</code></td>
   <td><code>x = x &lt;&lt; y</code></td>
  </tr>
  <tr>
   <td><a href="#Right_shift_assignment">오른쪽 이동 연산 할당</a></td>
   <td><code>x &gt;&gt;= y</code></td>
   <td><code>x = x &gt;&gt; y</code></td>
  </tr>
  <tr>
   <td><a href="#Unsigned_right_shift_assignment">부호 없는 오른쪽 이동 연산 할당</a></td>
   <td><code>x &gt;&gt;&gt;= y</code></td>
   <td><code>x = x &gt;&gt;&gt; y</code></td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#비트_AND_할당">비트 AND 할당</a></td>
   <td><code>x &amp;= y</code></td>
   <td><code>x = x &amp; y</code></td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#비트_XOR_할당">비트 XOR 할당</a></td>
   <td><code>x ^= y</code></td>
   <td><code>x = x ^ y</code></td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#비트_OR_할당">비트 OR 할당</a></td>
   <td><code>x |= y</code></td>
   <td><code>x = x | y</code></td>
  </tr>
 </tbody>
</table>

<h4 id="구조_분해">구조 분해</h4>

<p>복잡한 할당 연산에서, <a href="/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">구조 분해 할당</a> 구문은 배열이나 객체의 구조를 반영하여 배열이나 객체에서 데이터를 추출할 수 있게 해주는 JavaScript 표현식입니다.</p>

<pre class="brush: js">var foo = ['one', 'two', 'three'];

// 구조 분해를 활용하지 않은 경우
var one   = foo[0];
var two   = foo[1];
var three = foo[2];

// 구조 분해를 활용한 경우
var [one, two, three] = foo;</pre>

<h3 id="비교_연산자">비교 연산자</h3>

<p><a href="/ko/docs/Web/JavaScript/Reference/Operators/Comparison_Operators">비교 연산자</a>는 피연산자들을 비교하고 비교에 따라 논리 값을 반환합니다. 피연산자들은 숫자, 문자열, 논리형, 객체 를 사용할 수 있습니다. 문자열은 유니코드 값을 사용하여 표준 사전순서를 기반으로 비교합니다. 만약 두 피연산자가 다른 형태일 경우, JavaScript는 대부분 비교를 위해 피연산자를 적절한 타입으로 변환합니다. 이런 행동은 보통 숫자로 피연산자를 숫자로 비교하는 형태로 나타납니다. 형태를 바꾸기의 유일한 예외는 엄격한 비교를 수행하는 <code>===</code> 과 <code>!==</code> 연산이 관련되는 경우입니다. 이런 연산자는 비교를 위해 피연산자의 형태를 적절히 바꾸려고 시도하지 않습니다. 다음 표는 샘플 코드를 통해 비교 연산자에 대하여 설명합니다:</p>

<pre><code>var var1 = 3;
var var2 = 4;</code>
</pre>

<table class="standard-table">
 <caption>비교 연산자</caption>
 <thead>
  <tr>
   <th scope="col">연산자</th>
   <th scope="col">설명</th>
   <th scope="col">참을 반환하는 예제</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality">동등</a> (<code>==</code>)</td>
   <td>피연산자들이 같으면 참을 반환합니다.</td>
   <td><code>3 == var1</code>
    <p><code>"3" == var1</code></p>
    <code>3 == '3'</code></td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality">부등</a> (<code>!=</code>)</td>
   <td>피연산자들이 다르면 참을 반환합니다.</td>
   <td><code>var1 != 4<br>
    var2 != "3"</code></td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity">일치</a> (<code>===</code>)</td>
   <td>피연산자들이 같고 피연산자들의 같은 형태인 경우 참을 반환합니다. {{jsxref("Object.is")}} 와 <a href="/ko/docs/Web/JavaScript/Equality_comparisons_and_sameness" title="/ko/docs/Web/JavaScript/Guide/Sameness">JavaScript에서의 같음</a>을 참고하세요.</td>
   <td><code>3 === var1</code></td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Nonidentity">불일치</a> (<code>!==</code>)</td>
   <td>피연산자들이 다르거나 형태가 다른 경우 참을 반환합니다.</td>
   <td><code>var1 !== "3"<br>
    3 !== '3'</code></td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Greater_than_operator">~보다 큰</a> (<code>&gt;</code>)</td>
   <td>좌변의 피연산자 보다 우변의 피연산자가 크면 참을 반환합니다.</td>
   <td><code>var2 &gt; var1<br>
    "12" &gt; 2</code></td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Greater_than_or_equal_operator">~보다 크거나 같음</a> (<code>&gt;=</code>)</td>
   <td>좌변의 피연산자 보다 우변의 피연산자가 크거나 같으면 참을 반환합니다.</td>
   <td><code>var2 &gt;= var1<br>
    var1 &gt;= 3</code></td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Less_than_operator">~보다 작음</a> (<code>&lt;</code>)</td>
   <td>좌변의 피연산자 보다 우변의 피연산자가 작으면 참을 반환합니다.</td>
   <td><code>var1 &lt; var2<br>
    "2" &lt; 12</code></td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Less_than_or_equal_operator">~보다 작거나 같음</a> (<code>&lt;=</code>)</td>
   <td>좌변의 피연산자 보다 우변의 피연산자가 작거나 같으면 참을 반환합니다.</td>
   <td>
    <p><code>var1 &lt;= var2<br>
     var2 &lt;= 5</code></p>
   </td>
  </tr>
 </tbody>
</table>

<div class="note">
<p><strong>참고: </strong>(<code>=&gt;</code>) 은 연산자가 아니고, 화살표 함수(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow functions</a>)를 나타내는 기호입니다.</p>
</div>

<h3 id="산술_연산자">산술 연산자</h3>

<p><a href="/ko/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators">산술 연산자</a>는 숫자값(리터럴 또는 변수)을 피연산자로 갖고, 하나의 숫자 값을 반환합니다. 기본적인 산술 연산자는 덧셈(<code>+</code>), 뺄셈 (<code>-</code>), 곱셈 (<code>*</code>), 나눗셈 (<code>/</code>)입니다. 이 연산자들은 대부분의 다른 프로그래밍 언어들이 부동소수점 값을 연산하는것처럼 동작합니다. (0 으로 나누는 것은 {{jsxref("Infinity")}} 을 발생시키는 것을 기억하세요) 예를 들면:</p>

<pre class="brush: js">1 / 2; // 0.5
1 / 2 == 1.0 / 2.0; // this is true
</pre>

<p>또한, 표준 산술 연산자 (+, -, *, /) 에 대해 JavaScript는 다음의 표에 나와 있는 산술 연산자를 제공합니다.</p>

<table class="fullwidth-table">
 <caption>산술 연산자</caption>
 <thead>
  <tr>
   <th scope="col">연산자</th>
   <th scope="col">설명</th>
   <th scope="col">예제</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder">나머지 연산자</a> (<code>%</code>)</td>
   <td>이항 연산자입니다. 두 피연산자를 나눈후 나머지를 반환합니다.</td>
   <td>12 % 5 는 2를 반환합니다.</td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Increment">증가 연산자</a> (<code>++</code>)</td>
   <td>단항 연산자입니다. 피연산자에 1을 더합니다. 만약 연산자를 피연산자 앞(<code>++x</code>)에 사용하면, 피연산자에 1을 더한 값을 반환합니다.; 만약 연산자를 피연산자 뒤(<code>x++</code>)에 사용하면, 피연산자에 1을 더하기 전 값을 반환합니다.</td>
   <td><code>x</code> 가 3이면 <code>++x</code> 는 <code>x</code> 를 4로 만들고 4를 반환합니다. 반면 <code>x++</code> 는 3을 반환하고 <code>x</code> 를 4로 만듭니다.</td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Decrement">감소 연산자</a> (<code>--</code>)</td>
   <td>단항 연산자입니다. 피연산자로 부터 1을 뺍니다. 반환값은 증가 연산자와 유사합니다.</td>
   <td><code>x</code> 가 3이면 <code>--x</code> 는 <code>x</code> 를 2로 만들고2를 반환합니다. 반면 <code>x--</code> 는 3을 반환하고 <code>x</code> 를 2로 만듭니다.</td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_negation">단항 부정 연산자</a> (<code>-</code>)</td>
   <td>단항 연산자 입니다. 피연산자의 반대값(부호 바뀐값)을 반환합니다.</td>
   <td> <code>x</code> 가 3이면 <code>-x</code> 는 -3을 반환합니다.</td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_plus">숫자화 연산자</a> (<code>+</code>)</td>
   <td>단항연산자 입니다. 피연산자가 숫자값이 아니라면 피연산자를 숫자로 변환하기를 시도합니다.</td>
   <td><code>+"3"</code> 은 <code>3</code>을 반환합니다.<br>
    <code>+true</code> 는 <code>1.</code> 을 반환합니다.</td>
  </tr>
 </tbody>
</table>

<h3 id="비트_연산자">비트 연산자</h3>

<p><a href="/ko/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">비트 연산자</a>는 피연산자를 10진수, 16진수, 8진수처럼 취급하지 않고 32비트의 집합으로 취급합니다. 예를 들면, 10진수의 9는 2진수의 1001로 나타낼 수 있습니다. 비트 단위 연산자는 이진법으로 연산을 수행하지만, JavaScript의 표준 숫자값을 반환합니다..</p>

<p>다음의 표는 JavaScript의 비트단위 연산자의 요약입니다.</p>

<table class="standard-table">
 <caption>비트 연산자</caption>
 <thead>
  <tr>
   <th scope="col">연산자</th>
   <th scope="col">사용법</th>
   <th scope="col">설명</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_AND">비트단위 논리곱</a></td>
   <td><code>a &amp; b</code></td>
   <td>두 피연산자의 각 자리 비트의 값이 둘다 1일 경우 해당하는 자리에 1을 반환합니다.</td>
  </tr>
  <tr>
   <td><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_OR">비트단위 논리합</a></td>
   <td><code>a | b</code></td>
   <td>두 피연산자의 각 자리 비트의 값이 둘다 0일 경우 해당하는 자리에 0을 반환합니다.</td>
  </tr>
  <tr>
   <td><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_XOR">비트단위 배타적 논리합</a></td>
   <td><code>a ^ b</code></td>
   <td>두 피연산자의 각 자리 비트의 값이 같을 경우 해당하는 자리에 0을 반환합니다.<br>
    [두 피연산자의 각 자리 비트의 값이 다를 경우 해당하는 자리에 1을 반환합니다.]</td>
  </tr>
  <tr>
   <td><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_NOT">비트단위 부정</a></td>
   <td><code>~ a</code></td>
   <td>피연산자의 각 자리의 비트를 뒤집습니다.</td>
  </tr>
  <tr>
   <td><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Left_shift">왼쪽 시프트</a></td>
   <td><code>a &lt;&lt; b</code></td>
   <td>오른쪽에서 0들을 이동시키면서, a의 이진수의 각 비트를 b비트 만큼 왼쪽으로 이동시킨 값을 반환합니다.</td>
  </tr>
  <tr>
   <td><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Right_shift">부호 전파 오른쪽 시프트</a></td>
   <td><code>a &gt;&gt; b</code></td>
   <td>사라지는 비트를 버리면서, a의 이진수의 각 비트를 b비트만큼 이동시킨값을 반환합니다.</td>
  </tr>
  <tr>
   <td><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Unsigned_right_shift">부호 없는 오른쪽 시프트</a></td>
   <td><code>a &gt;&gt;&gt; b</code></td>
   <td>사라지는 비트를 버리고 왼쪽에서 0을 이동시키면서, a의 이진수의 각 비트를 b비트 만큼 이동시킨 값을 반환합니다.</td>
  </tr>
 </tbody>
</table>

<h4 id="Bitwise_Logical_Operators" name="Bitwise_Logical_Operators">비트 논리 연산자</h4>

<p>개념상으로, 비트단위 논리 연산자는 다음과 같이 동작합니다:</p>

<ul>
 <li>피연산자들은 32비트 정수로 변환되고, 비트(0 과 1)의 연속으로 표현됩니다. 숫자는 32비트가 넘는 경우 가장 중요한(왼쪽) 비트부터 제거됩니다. 예를 들면 아래 예처럼 32비트가 넘는 정수는 32비트 정수형으로 변환됩니다:
  <pre><code>변환전: 11100110111110100000000000000110000000000001
변환수:             10100000000000000110000000000001</code></pre>
 </li>
 <li>처음 피연산자의 각 비트는 두번째 피연산자의 해당하는 비트와 짝지어집니다: 첫번째 비트는 첫번째 비트에, 두번째 비트는 두번째 비트에, 이런식으로 쭉.</li>
 <li>연산자는 각 비트 묶음에 적용되고, 결과는 조립된 비트입니다.</li>
</ul>

<p>예를 들면, 9의 이진표현은 1001이고, 15의 이진표현은 1111입니다. 따라서, 비트단위 연산자가 이 값들에 적용될때, 결과는 다음과 같습니다:</p>

<table class="standard-table">
 <caption>비트 연산자 예제</caption>
 <thead>
  <tr>
   <th scope="col">표현</th>
   <th scope="col">결과</th>
   <th scope="col">이진법 설명</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>15 &amp; 9</code></td>
   <td><code>9</code></td>
   <td><code>1111 &amp; 1001 = 1001</code></td>
  </tr>
  <tr>
   <td><code>15 | 9</code></td>
   <td><code>15</code></td>
   <td><code>1111 | 1001 = 1111</code></td>
  </tr>
  <tr>
   <td><code>15 ^ 9</code></td>
   <td><code>6</code></td>
   <td><code>1111 ^ 1001 = 0110</code></td>
  </tr>
  <tr>
   <td><code>~15</code></td>
   <td><code>-16</code></td>
   <td><code>~</code><code>00000000...</code><code>00001111 = </code><code>1111</code><code>1111</code><code>...</code><code>11110000</code></td>
  </tr>
  <tr>
   <td><code>~9</code></td>
   <td><code>-10</code></td>
   <td><code>~</code><code>00000000</code><code>...</code><code>0000</code><code>1001 = </code><code>1111</code><code>1111</code><code>...</code><code>1111</code><code>0110</code></td>
  </tr>
 </tbody>
</table>

<p>모든 32비트가 비트단위 부정연산자를 통해 뒤집히고, 가장 의미있는(가장 왼쪽의) 비트가 1인 값들이 음수(2의 보수 표기법)로 표현되는것에 주목하세요 . ~x 의 평가 값은 -x -1의 평가값과 동일합니다.</p>

<h4 id="Bitwise_Shift_Operators" name="Bitwise_Shift_Operators">비트 시프트 연산자</h4>

<p>비트 단위 연산자는 2개의 피연산자를 가집니다: 첫번째는 이동될 수치이고, 두번째는 첫번째 피연산자가 이동될 비트 자리수를 명시합니다. 비트 이동 연산의 방향은 연산자의 사용에 의해 조종됩니다.</p>

<p>이동 연산자는 피연산자를 32비트의 정수로 변환하고, 왼쪽의 피연산자와 같은 형태를 반환합니다.</p>

<p>이동 연산자는 다음의 표에 나열되었습니다.</p>

<table class="fullwidth-table">
 <caption>비트 시프트 연산자</caption>
 <thead>
  <tr>
   <th scope="col">연산자</th>
   <th scope="col">설명</th>
   <th scope="col">예제</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>왼쪽 시프트<br>
    (<code>&lt;&lt;</code>)</td>
   <td>이 연산자는 첫번째 피연산자를 특정한 수의 비트를 왼쪽으로 이동시킵니다. 왼쪽으로 초과되어 이동되는 비트들은 버려집니다. 오른쪽으로부터 0이 이동됩니다.</td>
   <td><code>9&lt;&lt;2</code> yields 36, because 1001 shifted 2 bits to the left becomes 100100, which is 36.</td>
  </tr>
  <tr>
   <td>부호 전파 오른쪽 시프트(<code>&gt;&gt;</code>)</td>
   <td>이 연산자는 첫번째 피연산자를 특정한 수의 비트를 오른쪽으로 이동시킵니다. 오른쪽으로 초과되어 이동되는 비트들은 버려집니다. 왼쪽으로부터 제일 왼쪽의 비트 값이 이동됩니다.</td>
   <td><code>9&gt;&gt;2</code> yields 2, because 1001 shifted 2 bits to the right becomes 10, which is 2. Likewise, <code>-9&gt;&gt;2</code> yields -3, because the sign is preserved.</td>
  </tr>
  <tr>
   <td>부호 없는 오른쪽 시프트(<code>&gt;&gt;&gt;</code>)</td>
   <td>이 연산자는 첫번째 피연산자를 특정한 수의 비트를 오른쪽으로 이동시킵니다. 오른쪽으로 초과되어 이동되는 비트들은 버려집니다. 왼쪽으로부터 0이 이동됩니다 .</td>
   <td><code>19&gt;&gt;&gt;2</code> yields 4, because 10011 shifted 2 bits to the right becomes 100, which is 4. For non-negative numbers, zero-fill right shift and sign-propagating right shift yield the same result.</td>
  </tr>
 </tbody>
</table>

<h3 id="논리_연산자">논리 연산자</h3>

<p><a href="/ko/docs/Web/JavaScript/Reference/Operators/Logical_Operators">논리 연산자</a>는 보통 부울 값과 사용됩니다; 부울 값들과 사용될때, 연산자는 부울값을 반환합니다. <code>그러나,&amp;&amp; 과 </code><code>||</code> 연산자는 실제로 명시된 피연자들 중 하나를 반환합니다. 따라서, 만약 이 연산자들이 부울 값이 아닌 값들과 함께 쓰였을때, 그들은 부울 값이 아닌 값을 반환할지도 모릅니다. 논리 연산자들은 다음의 표에서 설명됩니다.</p>

<table class="fullwidth-table">
 <caption>논리 연산자</caption>
 <tbody>
  <tr>
   <th>연산자</th>
   <th>구문</th>
   <th>설명</th>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_AND">논리 AND</a> (<code>&amp;&amp;</code>)</td>
   <td><code><em>expr1</em> &amp;&amp; <em>expr2</em></code></td>
   <td><code>expr1</code>을 <font face="consolas, Liberation Mono, courier, monospace"><span style="background-color: rgba(220, 220, 220, 0.5);">true</span></font>로 변환할 수 있는 경우 <code>expr2</code>을 반환하고, 그렇지 않으면 <code>expr1</code>을 반환합니다.</td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_OR">논리 OR</a> (<code>||</code>)</td>
   <td><code><em>expr1</em> || <em>expr2</em></code></td>
   <td>
    <p><code>expr1</code>을 <code>true</code>로 변환할 수 있으면 <code>expr1</code>을 반환하고, 그렇지 않으면 <code>expr2</code>를 반환합니다.</p>
   </td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_NOT">논리 NOT</a> (<code>!</code>)</td>
   <td><code>!<em>expr</em></code></td>
   <td>단일 피연산자를 <code>true</code>로 변환할 수 있으면 <code>false</code>를 반환합니다. 그렇지 않으면 <code>true</code>를 반환합니다.</td>
  </tr>
 </tbody>
</table>

<p><code>false</code>로 변환될 수 있는 표현 예제들은 null, 0, NaN, 빈 문자열 (""), 또는 정의되지 않음 으로 평가될 수 있습니다.</p>

<p>다음의 코드는 <code>&amp;&amp;</code> (논리 곱) 연산자의 예제를 보여주고 있습니다.</p>

<pre class="brush: js">var a1 =  true &amp;&amp; true;     // t &amp;&amp; t returns true
var a2 =  true &amp;&amp; false;    // t &amp;&amp; f returns false
var a3 = false &amp;&amp; true;     // f &amp;&amp; t returns false
var a4 = false &amp;&amp; (3 == 4); // f &amp;&amp; f returns false
var a5 = "Cat" &amp;&amp; "Dog";    // t &amp;&amp; t returns Dog
var a6 = false &amp;&amp; "Cat";    // f &amp;&amp; t returns false
var a7 = "Cat" &amp;&amp; false;    // t &amp;&amp; f returns false
</pre>

<p>다음의 코드는 || (논리 합) 연산자의 예제를 보여주고 있습니다.</p>

<pre class="brush: js">var o1 =  true || true;     // t || t returns true
var o2 = false || true;     // f || t returns true
var o3 =  true || false;    // t || f returns true
var o4 = false || (3 == 4); // f || f returns false
var o5 = "Cat" || "Dog";    // t || t returns Cat
var o6 = false || "Cat";    // f || t returns Cat
var o7 = "Cat" || false;    // t || f returns Cat
</pre>

<p>다음의 코드는 ! (논리 부정) 연산자의 예제를 보여주고 있습니다.</p>

<pre class="brush: js">var n1 = !true;  // !t returns false
var n2 = !false; // !f returns true
var n3 = !"Cat"; // !t returns false
</pre>

<h4 id="Short-Circuit_Evaluation" name="Short-Circuit_Evaluation">단락 평가</h4>

<p>논리 연산자가 왼쪽에서 오른쪽으로 평가될때, 논리연산자는 다음의 규칙을 따라서 "단축 계산"으로 검사됩니다:</p>

<ul>
 <li><code>false</code> &amp;&amp; <em>anything</em> 는 false로 단축 계산됩니다.</li>
 <li><code>true</code> || <em>anything</em> 는 true로 단축 계산됩니다.</li>
</ul>

<p>이 논리 규칙들은 이러한 평가가 언제나 정확하다고 보증합니다. <em>위에서 anything</em> 부분은 평가되지 않았고, 어떤 부작용도 아무런 효과를 미치지 못한다는 것에 주목하세요.</p>

<h3 id="문자열_연산자">문자열 연산자</h3>

<p>문자열 값으로 사용될 수 있는 비교 연산자에 덧붙여서, 연결 연산자 (+)는 두 문자열 값을 연결하고,두 문자열이 합쳐진 새로운 문자열을 반환합니다.</p>

<p>예를 들어,</p>

<pre class="brush: js"><code>console.log("my " + "string");</code> // console logs the string <code>"my string"</code>.</pre>

<p>복합 할당 연산자인 += 또한 문자열을 연결하는데 사용할 수 있습니다.</p>

<p>예를 들어,</p>

<pre class="brush: js">var <code>mystring</code> = "alpha";
<code>mystring += "bet"; // </code>evaluates to "alphabet" and assigns this value to <code>mystring</code>.</pre>

<h3 id="조건_삼항_연산자">조건 (삼항) 연산자</h3>

<p><a href="/ko/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">조건 연산자</a> 는 JavaScript에서 3개의 항을 사용하는 유일한 연산자 입니다. 조건 연산자는 조건에 따라 2개의 값중 하나를 가질 수 있습니다. 문법은 다음과 같습니다:</p>

<pre class="syntaxbox"><em>조건</em> ? <em>값1</em> : <em>값2</em>
</pre>

<p><code>만약 조건이 참이라면, 조건 연산자는 값1을 값으로 갖습니다</code>.<code> 그렇지 않은 경우 조건 연산자는 값2을 값으로 갖습니다</code>. 표준 연산자를 사용하는 어디든 조건연산자를 사용할 수 있습니다.</p>

<p>에들 들어,</p>

<pre class="brush: js">var status = (age &gt;= 18) ? "adult" : "minor";
</pre>

<p>이 구문은 age 변수가 18보다 같거나 클때 "adult" 값을 <code>status 변수에 할당합니다</code>. 그렇지 않은 경우, 이 구문은 "minor"값을<code> status</code>변수에 할당합니다.</p>

<h3 id="쉼표_연산자">쉼표 연산자</h3>

<p><a href="/ko/docs/Web/JavaScript/Reference/Operators/Comma_Operator">쉼표 연산자</a> (<code>,</code>)는 두 피연산자를 평가하고, 마지막 피연산자의 값을 반환합니다. 이 연산자는 주로 <code>for</code> 반복문 안에서 각각의 시간에 복수의 변수들을 갱신하기 위하여 사용합니다.</p>

<p>예를 들어, a는 각 변에 10개의 원소가 있는 2차원 배열일때, 다음의 코드는 콤마 연산자를 두 변수를 한번에 증가 시키기 위하여 사용하였습니다. 이 코드는 배열의 대각선에 위치한 원소를 출력합니다:</p>

<pre><code>var x = [0,1,2,3,4,5,6,7,8,9]
var a = [x, x, x, x, x];

for (var i = 0, j = 9; i &lt;= j; i++, j--)
  console.log('a[' + i + '][' + j + ']= ' + a[i][j]);</code></pre>

<h3 id="단항_연산자">단항 연산자</h3>

<p>단항 연산자는 오직 하나의 피연산자를 가지고 연산을합니다.</p>

<h4 id="delete" name="delete"><code>delete</code></h4>

<p><code><a href="/ko/docs/Web/JavaScript/Reference/Operators/delete">delete</a></code>연산자는 객체, 객체의 속성 또는 배열의 특정한 위치에 있는 객체를 삭제합니다. 문법은 다음과 같습니다:</p>

<pre class="brush: js">delete objectName;
delete objectName.property;
delete objectName[index];
delete property; // legal only within a with statement
</pre>

<p><code>objectName</code>은 객체의 이름이고, <code>property</code>는 객체에 존재하는 속성이고,<code>index</code>는 배열의 위치를 나타내는 정수입니다.</p>

<p>네번째 형태의 경우,객체의 속성을 삭제하기 위하여 <code><a href="/ko/docs/Web/JavaScript/Reference/Statements/with">with</a></code> 구문이 있어야만 동작합니다.</p>

<p><code>delete</code> 연산자를 <code>var</code> 구문을 사용하지 않고 묵시적으로 만들어진 변수를 삭제할 때 사용할 수 있습니다.</p>

<p>만약 <code>delete</code>연산자의 동작이 성공했다면, delete 연산자는 속성이나, 원소를 <code>undefined</code> 로 설정합니다. <code>delete</code> 연산자는 연산이 수행 가능할때 true값을 반환합니다; 수행이 불가능 할 경우 <code>false</code> 값을 반환합니다.</p>

<pre class="brush: js">x = 42;
var y = 43;
myobj = new Number();
myobj.h = 4;    // create property h
delete x;       // returns true (can delete if declared implicitly)
delete y;       // returns false (cannot delete if declared with var)
delete Math.PI; // returns false (cannot delete predefined properties)
delete myobj.h; // returns true (can delete user-defined properties)
delete myobj;   // returns true (can delete if declared implicitly)
</pre>

<h5 id="배열의_원소를_삭제하기">배열의 원소를 삭제하기</h5>

<p>배열의 원소를 삭제할때, 배열의 길이에는 영향을 주지 못합니다. 예를 들어, 만약 <code>a[3]</code>, <code>a[4]를 삭제 했다면</code> <code>a[4]</code> 와 <code>a[3]는 undefined(정의되지 않음)상태로 되어 있습니다</code>.</p>

<p><code>delete</code> 연산자가 배열의 한 원소를 삭제하였을때, 그 원소는 배열에 존재하지 않습니다. 다음의 예제에서, <code>trees[3]</code>는 <code>delete 연산자에 의해 제거되었습니다</code>.그러나, <code>trees[3]</code> 는 아직도 다룰수 있고 <code>undefined</code>(정의 되지 않음) 을 반환합니다.</p>

<pre class="brush: js">var trees = ["redwood", "bay", "cedar", "oak", "maple"];
delete trees[3];
if (3 in trees) {
  // this does not get executed
}
</pre>

<p>만약 배열의 원소가 존재하지만 undefined(정의 되지 않음)값을 가지고 싶으면,<code> delete 연산자 대신 undefined</code> 키워드를 사용하세요. 다음의 예제에서, <code>trees[3]</code> 은 <code>undefined값을 할당받습니다</code>,그러나 배열의 원소는 아직도 존재합니다:</p>

<pre class="brush: js">var trees = ["redwood", "bay", "cedar", "oak", "maple"];
trees[3] = undefined;
if (3 in trees) {
  // this gets executed
}
</pre>

<h4 id="typeof" name="typeof"><code>typeof</code></h4>

<p><a href="/ko/docs/Web/JavaScript/Reference/Operators/typeof"><code>typeof</code> 연산자</a>는 다음과 같은 방법으로 사용됩니다:</p>

<pre class="syntaxbox">typeof 피연산자
typeof (피연산자)
</pre>

<p><code>typeof</code> 연산자 피연산자의 타입을 나타내는 문자열을 반환합니다. <code>피연산자</code> 는 어떤 타입인지 반환될 문자열, 변수, 키워드,또는 객체입니다 . 괄호 표현은 선택사항입니다.</p>

<p>다음의 변수를 정의했다고 가정하세요:</p>

<pre class="brush: js">var myFun = new Function("5 + 2");
var shape = "round";
var size = 1;
var foo = ['Apple', 'Mango', 'Orange'];
var today = new Date();
</pre>

<p><code>typeof</code> 연산자는 이 변수들에 대하여 다음과 같은 값을 반환합니다:</p>

<pre class="brush: js">typeof myFun;     // returns "function"
typeof shape;     // returns "string"
typeof size;      // returns "number"
typeof foo;       // returns "object"
typeof today;     // returns "object"
typeof dontExist; // returns "undefined"
</pre>

<p><code>typeof</code> 연산자는 키워드<code>true</code> 와 <code>null</code>에 대하여 다음과 같은 결과를 반환합니다:</p>

<pre class="brush: js">typeof true; // returns "boolean"
typeof null; // returns "object"
</pre>

<p>typeof 연산자는 숫자와 문자열에 대하여 다음과 같은 결과를 반환합니다:</p>

<pre class="brush: js">typeof 62;            // returns "number"
typeof 'Hello world'; // returns "string"
</pre>

<p><code>typeof</code> 연산자는 객체의 속성에 대하여 속성이 갖고있는 타입의 값을 반환합니다.</p>

<pre class="brush: js">typeof document.lastModified; // returns "string"
typeof window.length;         // returns "number"
typeof Math.LN2;              // returns "number"
</pre>

<p><code>typeof</code> 연산자는 메소드와 함수들에 대하여 다음과 같은 결과를 반환합니다:</p>

<pre class="brush: js">typeof blur;        // returns "function"
typeof eval;        // returns "function"
typeof parseInt;    // returns "function"
typeof shape.split; // returns "function"
</pre>

<p><code>typeof 연산자는</code> 미리 정의된 객체에 대하여 다음과 같은 결과를 반환합니다:</p>

<pre class="brush: js">typeof Date;     // returns "function"
typeof Function; // returns "function"
typeof Math;     // returns "object"
typeof Option;   // returns "function"
typeof String;   // returns "function"
</pre>

<h4 id="void" name="void"><code>void</code></h4>

<p><a href="/ko/docs/Web/JavaScript/Reference/Operators/void"><code>void</code> 연산자</a> 는 다음과 같은 방법들로 사용됩니다:</p>

<pre class="syntaxbox">void (식)
void 식
</pre>

<p><code>void</code> 연산자는 값을 반환하지 않고 평가되도록 명시합니다. <code>식</code>은 JavaScript의 평가될 표현 입니다. 괄호 로 둘러싸는것은 선택사항이지만, 괄호로 둘러싸는게 좋은 사용방법입니다.</p>

<p><code>void</code> 연산자를 표현을 하이퍼링크 에서 명시할때 사용할 수 있습니다 . 구문은 실행이 되나, 현재의 문서에는 로드되지 않습니다.</p>

<p>다음의 코드는 사용자가 클릭을 하였을때 아무 일도 안하는 하이퍼링크를 생성합니다. 사용자가 클릭을 했을때, <code>void(0)</code>는<code> JavaScript에서 아무런 영향을 줄 수 없는 undefined(정의 되지않음)</code>으로 평가됩니다.</p>

<pre class="brush: html">&lt;a href="javascript:void(0)"&gt;Click here to do nothing&lt;/a&gt;
</pre>

<p>다음의 코드는 사용자가 클릭을 하였을때, 폼을 제출하는 하이퍼링크를 생성합니다.</p>

<pre class="brush: html">&lt;a href="javascript:void(document.form.submit())"&gt;
Click here to submit&lt;/a&gt;</pre>

<h3 id="관계_연산자">관계 연산자</h3>

<p>관계 연산자는 피연산자들을 비교하고 <code>,비교의 참 여부에 기반하여 부울 값을 반환합니다</code>.</p>

<h4 id="in"><code>in</code></h4>

<p><a href="/ko/docs/Web/JavaScript/Reference/Operators/in"><code>in</code> 연산자</a>는 객체에 특정한 속성이 있는경우 true를 반환합니다. 구문은 다음과 같습니다:</p>

<pre class="brush: js">propNameOrNumber in objectName
</pre>

<p><code>propNameOrNumber</code>는 속성의 이름을 나타내는 문자열 또는 배열의 인덱스를 나타내는 숫자이고, <code>objectName은 객체의 이름입니다</code>.</p>

<p>다음의 예제는 <code>in</code> 연산자의 사용 예를 보여줍니다.</p>

<pre class="brush: js">// Arrays
var trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees;        // returns true
3 in trees;        // returns true
6 in trees;        // returns false
"bay" in trees;    // returns false (you must specify the index number,
                   // not the value at that index)
"length" in trees; // returns true (length is an Array property)

// built-in objects
"PI" in Math;          // returns true
var myString = new String("coral");
"length" in myString;  // returns true

// Custom objects
var mycar = { make: "Honda", model: "Accord", year: 1998 };
"make" in mycar;  // returns true
"model" in mycar; // returns true
</pre>

<h4 id="instanceof" name="instanceof"><code>instanceof</code></h4>

<p><a href="/ko/docs/Web/JavaScript/Reference/Operators/instanceof"><code>instanceof</code> 연산자</a>는 명시된 객체가 명시된 객체형인 경우 true를 반환합니다. 구문은 다음과 같습니다:</p>

<pre class="syntaxbox">objectName instanceof objectType
</pre>

<p><code>objectName은 objectType 과 비교할 객체의 이름이고</code>, <code>objectType</code> 은 {{jsxref("Date")}} 또는 {{jsxref("Array")}}과 같은 객체형 입니다.</p>

<p><code>instanceof</code> 연산자를 동작시간에 객체의 형태를 확인할 필요가 있을때 사용하세요. 예를 들어, 예외가 발생하였을때, 던저진 예외의 형태에 따라 예외를 처리하는 코드로 나뉘게 할 수 있습니다.</p>

<p>예를 들어, 다음의 코드는<code>instanceof</code> 연산자를<code>theDay 객체가</code> <code>Date</code> 형의 객체인지 알아내는 코드입니다. <code>theDay</code>객체는 <code>Date</code> 형의 객체이기 때문에, <code>if</code> 문 안의 명령문들은 실행됩니다.</p>

<pre class="brush: js">var theDay = new Date(1995, 12, 17);
if (theDay instanceof Date) {
  // statements to execute
}
</pre>

<h3 id="연산자_우선순위">연산자 우선순위</h3>

<p>연산자의 우선순위는 구문을 수행할 때 수행될 순서를 결정합니다. 괄호를 통하여 우선순위를 재정의 할 수 있습니다.</p>

<p>다음의 표는 우선순위가 높은 순서부터 낮은 순서까지, 연산자의 우선순위에 대하여 설명하고 있습니다.</p>

<table class="standard-table">
 <caption>연산자 우선순위</caption>
 <thead>
  <tr>
   <th scope="col">Operator type</th>
   <th scope="col">Individual operators</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>맴버 연산자</td>
   <td><code>. []</code></td>
  </tr>
  <tr>
   <td>객체 호출/생성 연산자</td>
   <td><code>() new</code></td>
  </tr>
  <tr>
   <td>부정/증가 연산자</td>
   <td><code>! ~ - + ++ -- typeof void delete</code></td>
  </tr>
  <tr>
   <td>곱셈/나눗셈 연산자</td>
   <td><code>* / %</code></td>
  </tr>
  <tr>
   <td>덧셈/뺄셈 연산자</td>
   <td><code>+ -</code></td>
  </tr>
  <tr>
   <td>비트단위 시프트 연산자</td>
   <td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td>
  </tr>
  <tr>
   <td>관계 연산자</td>
   <td><code>&lt; &lt;= &gt; &gt;= in instanceof</code></td>
  </tr>
  <tr>
   <td>같음 비교 연산자</td>
   <td><code>== != === !==</code></td>
  </tr>
  <tr>
   <td>비트 단위 논리곱 연산자</td>
   <td><code>&amp;</code></td>
  </tr>
  <tr>
   <td>비트단위 배타적 논리합 연산자</td>
   <td><code>^</code></td>
  </tr>
  <tr>
   <td>비트단위 논리합 연산자</td>
   <td><code>|</code></td>
  </tr>
  <tr>
   <td>논리 곱 연산자</td>
   <td><code>&amp;&amp;</code></td>
  </tr>
  <tr>
   <td>논리 합 연산자</td>
   <td><code>||</code></td>
  </tr>
  <tr>
   <td>조건 연산자</td>
   <td><code>?:</code></td>
  </tr>
  <tr>
   <td>할당 연산자</td>
   <td><code>= += -= *= /= %= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= ^= |=</code></td>
  </tr>
  <tr>
   <td>콤마 연산자</td>
   <td><code>,</code></td>
  </tr>
 </tbody>
</table>

<p>각 각의 연산자에 대한 추가적인 상세사항에 대해 연결된, 더 자세한 표를 보고 싶으면, <a href="/ko/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">JavaScript Reference</a>에서 보실 수 있습니다.</p>

<h2 id="표현식">표현식</h2>

<p><span>코드 값으로 확인된 표현은 그 어떤 타당한 단위입니다.</span></p>

<p>개념적으로, 2가지의 유형이 있습니다. 첫번째는, 변수에 값을 할당시키는 것, 두번째는 단순히 값을 갖는것이 있습니다.</p>

<p>x = 7이란 표현은 첫번째 유형입니다. 이 표현은 x에다가 7을 할당시키기위해 =연산자를 사용합니다. 그 표현자체 7로 계산됩니다.</p>

<p>3 + 4란 코드는 두번째 표현방식의 예입니다. 이 표현은 7이라는 결과로 할당하는것없이 3과 4를 더하기위해 +연산자를 사용합니다.</p>

<p>JavaScript는 아래 표현범주를 따릅니다.</p>

<ul>
 <li>산수 : 예를 들어 3.14159를 숫자로 평가합니다. (일반적으로 <a href="#산술_연산자">산술 연산자</a>를 사용합니다.)</li>
 <li>문자열 : 예를 들어 "Fred"나 "234"를 문자열로 평가합니다. (일반적으로 <a href="#문자열_연산자">문자열 연산자</a>를 사용합니다.)</li>
 <li>논리 : 참이나 거짓으로 평가합니다. (종종 <a href="#논리_연산자">논리 연산자</a>를 수반합니다.)</li>
 <li>일차식 : JavaScript에서 기본핵심어와 일반적인 표현입니다.</li>
 <li>좌변식 : 좌변값들이 배치의 목적입니다.</li>
</ul>

<h3 id="중요한_표현식">중요한 표현식</h3>

<p>JavaScript에서의 기본적인 키워드와 일반적인 표현식입니다.</p>

<h4 id="this"><code>this</code></h4>

<p>현재 객체를 참조하는 데 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this"><code>this</code> 키워드</a>를 사용합니다. 일반적으로, this는 메소드에서 호출하는 객체를 참조합니다. 점(.)이나 괄호([])로 접근할 수 있습니다.</p>

<pre class="syntaxbox">this["propertyName"]
this.propertyName
</pre>

<p>어떤 객체의 최솟값 최댓값에 대하여, value 프로퍼티가 유효범위에 속하는지를 평가하는 validate 함수를 호출했다고 가정해봅시다.</p>

<pre class="brush: js">function validate(obj, lowval, hival){
  if ((obj.value &lt; lowval) || (obj.value &gt; hival))
    console.log("Invalid Value!");
}
</pre>

<p>다음과 같이 각 form 요소의 onChange 이벤트 처리기에서 validate 함수를 호출할 수 있습니다. this 일차식을 사용하여 form 요소(element)를 전달할 수 있습니다:</p>

<pre class="brush: html">&lt;p&gt;Enter a number between 18 and 99:&lt;/p&gt;
&lt;input type="text" name="age" size=3 onChange="validate(this, 18, 99);"&gt;
</pre>

<h4 id="그룹_연산자">그룹 연산자</h4>

<p>그룹연산자 ()는 표현식 평가의 우선순위를 조절합니다. 예를 들어, 곱셈과 나눗셈 연산을 무시하고, 우선 덧셈 뺄셈 연산을 먼저 수행할 수도 있습니다.</p>

<pre class="brush:js">var a = 1;
var b = 2;
var c = 3;

// default precedence
a + b * c     // 7
// evaluated by default like this
a + (b * c)   // 7

// now overriding precedence
// addition before multiplication
(a + b) * c   // 9

// which is equivalent to
a * c + b * c // 9
</pre>

<h3 id="좌변식">좌변식</h3>

<p>좌측값들이 좌변식의 목적입니다.</p>

<h4 id="new" name="new"><code>new</code></h4>

<p><span>당신은 사용자 정의 객체 형식 또는 한 내장된 객체 형식의 인스턴스를 만드는 데는 </span><code><a href="/ko/docs/Web/JavaScript/Reference/Operators/new">new 연산자</a>를 </code><span>사용할 수 있습니다.</span> new는 아래와 같이 사용할 수 있습니다:</p>

<pre class="brush: js">var objectName = new objectType([param1, param2, ..., paramN]);
</pre>

<h4 id="super">super</h4>

<p><a href="/ko/docs/Web/JavaScript/Reference/Operators/super">Super 키워드</a>는<span>개체의 부모에 함수를 호출하는 데 사용됩니다. 예를 들어 이것은 부모생성자를 부르는 </span> <a href="/ko/docs/Web/JavaScript/Reference/Classes">클래스들</a><span>과 함께 유용합니다 </span></p>

<pre class="syntaxbox">super([arguments]); // calls the parent constructor.
super.functionOnParent([arguments]);
</pre>

<h4 id="확산연산자">확산연산자</h4>

<p><a href="/ko/docs/Web/JavaScript/Reference/Operators/Spread_operator">확산연산자</a>는 다중인수(함수호출)또는 다중요소(문자배열)들이 예상되는 곳에서 확장될 수 있는 표현을 하게합니다.</p>

<p><strong>Example:</strong> 만약 하나의 배열에 다른 하나의 배열을 추가하고 싶을 때에는 Array 리터럴 구문이 더이상 충분하지않으므로 <code>push</code>, <code>splice</code>, <code>concat</code>과 같은 함수를 사용하는 것이 좋습니다. 하지만 확산연산자를 사용할 경우 좀 더 간결한 구문으로 구현할 수 있습니다. </p>

<pre class="brush: js">var parts = ['shoulder', 'knees'];
var lyrics = ['head', ...parts, 'and', 'toes'];

//[ 'head', 'shoulders', 'knees', 'and', 'toes' ]
</pre>

<p><span>위와 같이, 확산연산자의 함수 호출은 다음과 같이 사용합니다.</span></p>

<pre class="brush: js">function f(x, y, z) { }
var args = [0, 1, 2];
f(...args);</pre>

<div>{{PreviousNext("Web/JavaScript/Guide/Functions", "Web/JavaScript/Guide/Numbers_and_dates")}}</div>
