---
title: Array.prototype.slice()
slug: Web/JavaScript/Reference/Global_Objects/Array/slice
tags:
  - Array
  - JavaScript
  - Method
  - Prototype
  - Reference
translation_of: Web/JavaScript/Reference/Global_Objects/Array/slice
---
<div>{{JSRef}}</div>

<p><code><strong>slice()</strong></code><strong> </strong>메서드는 어떤 배열의 <code>begin</code>부터 <code>end</code>까지(<code>end</code> 미포함)에 대한 얕은 복사본을 새로운 배열 객체로 반환합니다. 원본 배열은 바뀌지 않습니다.</p>

<div>{{EmbedInteractiveExample("pages/js/array-slice.html")}}</div>

<h2 id="구문">구문</h2>

<pre class="syntaxbox"><var>arr</var>.slice([<em>begin</em>[, <em>end</em>]])
</pre>

<h3 id="매개변수">매개변수</h3>

<dl>
 <dt><code>begin</code> {{optional_inline}}</dt>
 <dd>0을 시작으로 하는 추출 시작점에 대한 인덱스를 의미합니다.</dd>
 <dd>음수 인덱스는 배열의 끝에서부터의 길이를 나타냅니다. <code>slice(-2)</code> 는 배열에서 마지막 두 개의 엘리먼트를 추출합니다.</dd>
 <dd><code>begin</code>이 <code>undefined</code>인 경우에는, 0번 인덱스부터 <code>slice</code> 합니다.</dd>
 <dd><code>begin</code>이 배열의 길이보다 큰 경우에는, 빈 배열을 반환합니다.</dd>
 <dt><code>end</code> {{optional_inline}}</dt>
 <dd>추출을 종료 할 0 기준 인덱스입니다. <code>slice</code> 는 <code>end</code> 인덱스를 제외하고 추출합니다.</dd>
 <dd>예를 들어, <code>slice(1,4)</code>는 두번째 요소부터 네번째 요소까지 (1, 2 및 3을 인덱스로 하는 요소) 추출합니다.</dd>
 <dd>음수 인덱스는 배열의 끝에서부터의 길이를 나타냅니다. 예를들어 <code>slice(2,-1)</code> 는 세번째부터 끝에서 두번째 요소까지 추출합니다.</dd>
 <dd><code>end</code>가 생략되면 <code>slice()</code>는 배열의 끝까지(<code>arr.length</code>) 추출합니다.</dd>
</dl>

<p>     만약 <code>end</code> 값이 배열의 길이보다 크다면, <code>slice()</code>는 배열의 끝까지(<code>arr.length</code>) 추출합니다.</p>

<dl>
 <dt>
 <h3 id="반환_값">반환 값</h3>
 </dt>
</dl>

<p>추출한 요소를 포함한 새로운 배열.</p>

<h2 id="설명">설명</h2>

<p><code>slice()</code>는 원본을 대체하지 않습니다. 원본 배열에서 요소의 얕은 복사본을 반환합니다. 원본 배열의 요소는 다음과 같이 반환 된 배열에 복사됩니다:</p>

<ul>
 <li>객체 참조(및 실제 객체가 아님)의 경우, <code>slice()</code>는 객체 참조를 새 배열로 복사합니다. 원본 배열과 새 배열은 모두 동일한 객체를 참조합니다. 참조 된 객체가 변경되면 변경 내용은 새 배열과 원래 배열 모두에서 볼 수 있습니다.</li>
 <li>{{jsxref ("String")}} 및 {{jsxref("Number")}} 객체가 아닌 문자열과 숫자의 경우 <code>slice()</code>는 문자열과 숫자를 새 배열에 복사합니다. 한 배열에서 문자열이나 숫자를 변경해도 다른 배열에는 영향을 주지 않습니다.</li>
</ul>

<p>새 요소를 두 배열 중 하나에 추가해도 다른 배열은 영향을 받지 않습니다.</p>

<h2 id="예제">예제</h2>

<h3 id="기존_배열의_일부_반환">기존 배열의 일부 반환</h3>

<pre class="brush: js">let fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']
let citrus = fruits.slice(1, 3)

// fruits contains ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']
// citrus contains ['Orange','Lemon']</pre>

<h3 id="slice_사용하기"><code>slice</code> 사용하기</h3>

<p>다음 예제에서 <code>slice()</code>는 <code>myCar</code>에서 <code>newCar</code>라는 새 배열을 만듭니다. 두 가지 모두 <code>myHonda</code> 객체에 대한 참조를 포함합니다. <code>myHonda</code>의 색상이 자주색으로 변경되면 두 배열 모두 변경 사항을 반영합니다.</p>

<pre class="brush: js">// Using slice, create newCar from myCar.
let myHonda = { color: 'red', wheels: 4, engine: { cylinders: 4, size: 2.2 } }
let myCar = [myHonda, 2, 'cherry condition', 'purchased 1997']
let newCar = myCar.slice(0, 2)

// Display the values of myCar, newCar, and the color of myHonda
//  referenced from both arrays.
console.log('myCar = ' + JSON.stringify(myCar))
console.log('newCar = ' + JSON.stringify(newCar))
console.log('myCar[0].color = ' + myCar[0].color)
console.log('newCar[0].color = ' + newCar[0].color)

// Change the color of myHonda.
myHonda.color = 'purple'
console.log('The new color of my Honda is ' + myHonda.color)

// Display the color of myHonda referenced from both arrays.
console.log('myCar[0].color = ' + myCar[0].color)
console.log('newCar[0].color = ' + newCar[0].color)</pre>

<p>스크립트를 실행하면 다음과 같은 기록을 남깁니다.</p>

<pre>myCar = [{color: 'red', wheels: 4, engine: {cylinders: 4, size: 2.2}}, 2,
         'cherry condition', 'purchased 1997']
newCar = [{color: 'red', wheels: 4, engine: {cylinders: 4, size: 2.2}}, 2]
myCar[0].color = red
newCar[0].color = red
The new color of my Honda is purple
myCar[0].color = purple
newCar[0].color = purple</pre>

<h3 id="배열형_객체">배열형 객체</h3>

<p><code>slice()</code> 메서드를 호출하여 배열형 객체와 콜렉션을 새로운 <code>Array</code>로 변환할 수 있습니다. 단순히 {{jsxref("Function.prototype.bind()")}}를 사용해 객체에 <code>slice()</code>를 바인딩 하면 됩니다. 대표적인 "배열형 객체"의 예시는 함수 내의 {{jsxref("Functions/arguments", "arguments")}}입니다.</p>

<pre class="brush: js">function list() {
  return Array.prototype.slice.call(arguments);
}

let list1 = list(1, 2, 3); // [1, 2, 3]
</pre>

<p>{{jsxref("Function.prototype.call()")}} 메서드를 사용해서도 바인딩을 할 수 있으며, <code>Array.prototype.slice.call</code> 대신 더 짧게 <code>[].slice.call</code>로 작성할 수도 있습니다.</p>

<p>아무튼, 다음과 같이 {{jsxref("Function.prototype.bind", "bind()")}}를 사용해 줄일 수 있습니다.</p>

<pre class="brush: js">let unboundSlice = Array.prototype.slice
let slice = Function.prototype.call.bind(unboundSlice)

function list() {
  return slice(arguments)
}

let list1 = list(1, 2, 3) // [1, 2, 3]</pre>

<h2 id="명세">명세</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-array.prototype.slice', 'Array.prototype.slice')}}</td>
  </tr>
 </tbody>
</table>

<h2 id="브라우저_호환성">브라우저 호환성</h2>



<p>{{Compat("javascript.builtins.Array.slice")}}</p>

<h2 id="같이_보기">같이 보기</h2>

<ul>
 <li>{{jsxref("Array.prototype.splice()")}}</li>
 <li>{{jsxref("Function.prototype.call()")}}</li>
 <li>{{jsxref("Function.prototype.bind()")}}</li>
</ul>
