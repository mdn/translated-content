---
title: parseInt()
slug: Web/JavaScript/Reference/Global_Objects/parseInt
tags:
  - JavaScript
  - Reference
translation_of: Web/JavaScript/Reference/Global_Objects/parseInt
---
<div>{{jsSidebar("Objects")}}</div>

<p><code><strong>parseInt()</strong></code> 함수는 문자열 인자를 구문분석하여 특정 진수(수의 진법 체계에 기준이 되는 값)의 정수를 반환합니다.</p>

<div>{{EmbedInteractiveExample("pages/js/globalprops-parseint.html")}}</div>



<h2 id="구문">구문</h2>

<pre class="syntaxbox notranslate">parseInt(<em>string</em>, <em>radix</em>);</pre>

<h3 id="매개변수">매개변수</h3>

<dl>
 <dt><code>string</code></dt>
 <dd>분석할 값. 만약 <code>string</code>이 문자열이 아니면 문자열로 변환(<code><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-tostring">ToString</a></code> 추상 연산을 사용)합니다. 문자열의 선행 공백은 무시합니다.</dd>
</dl>

<dl>
 <dt><code>radix</code>{{optional_inline}}</dt>
 <dd><code>string</code>이 표현하는 정수를 나타내는 2와 36 사이의 진수(수의 진법 체계에 기준이 되는 값). 주의하세요-기본값이 10이 아닙니다!</dd>
 <dt></dt>
 <dt>
 <div class="blockIndicator warning">
 <p><a href="#설명">아래의 설명</a>은 radix가 제공되지 않았을때 무엇이 발생하는지 상세하게 설명하고 있습니다.</p>
 </div>
 </dt>
</dl>

<h3 id="반환_값">반환 값</h3>

<p>주어진 <code>string</code>로부터 분석한 정수.</p>

<p>또는 아래의 경우에는 {{jsxref("NaN")}}을 반환합니다</p>

<ul>
 <li><code>radix</code>가 2보다 작거나 36보다 큰 경우</li>
 <li>첫번째 non-whitespace 문자가 숫자로 변환되지 않는 경우</li>
</ul>

<h2 id="설명_2"><a id="설명" name="설명">설명</a></h2>

<p><code>parseInt</code> 함수는 첫 번째 인자를 문자열로 변환하고 파싱하고,  그 문자열을 파싱하여 정수나 <code>NaN</code>을 리턴합니다.</p>

<p>만약 <code>NaN</code>이 아니면, 첫번째 인자를 특정 <code><var>radix</var></code>(진수) 값으로 표현한 정수가 반환됩니다. (예를 들면, <code><var>radix</var></code>가 <code>10</code>인 경우 십진수로 변환하며, <code>8</code>인 경우는 8진수로, <code>16</code>인 경우 16진수 등등으로  변환합니다.)</p>

<p><code>radix </code>가 <code>10</code> 이상인 경우, <code>9</code>보다 큰 숫자들은 알파벳 문자로 나타내집니다. 예를 들면, 16 진수의 경우, A부터 F가 사용됩니다.</p>

<p>만약 <code>parseInt</code> 함수가 특정 진수를 나타내는 숫자가 아닌 글자를 마주치게 되면, 이 글자와 계속되는 글자들은 전부 무시되며, 파싱된 정수값을 리턴합니다. <code>parseInt</code> 함수는 정수값으로 숫자를 잘라버립니다. 맨 앞의 공백과 그 뒤의 공백들은 허용됩니다.</p>

<p>일부 숫자들은 문자열 표현에 e 문자를 사용하기 때문에(예: 6.022 × 10^23의 경우 <code>6.022e23</code> ) 숫자를 자르기 위하여 <code>parseInt</code>를 사용하는 것은 매우 크거나 매우 작은 숫자에 사용하는 경우 예기치 않은 결과가 발생합니다. <code>parseInt</code>는 {{jsxref("Math.floor()")}}의 대체품으로 사용해서는 안 됩니다.</p>

<p><code>parseInt</code>는 양수를 의미하는 <code>+ </code>기호와 음수를 나타내는 <code>-</code> 기호를 정확히 이해합니다(ECMAScript 1 이후). 공백이 제거된 후 구문 분석의 초기 단계로 수행됩니다. 기호를 찾을 수 없으면 알고리즘이 다음 단계로 이동하고, 그렇지 않으면 기호를 제거하고 문자열의 나머지 부분에서 숫자 파싱을 실행합니다.</p>

<p>만약 <var>radix</var> 가 <code>undefined</code> 이거나 0이라면, (또는 없다면), JavaScript 는 아래와 같이 임의 처리합니다. :</p>

<ol>
 <li>인풋 값 <code>string</code> 이 "0x" 나 "0X"로 시작한다면, <var>radix</var> 는 16(16진)이며, 나머지 문자열은 파싱됩니다.</li>
 <li>인풋 값 <code>string</code> 이 "0"으로 시작한다면, <var>radix</var> 는 8(8진)이거나, 10(십진)입니다. 정확히 이 선택된 radix 는 구현 의존적적입니다. ECMAScript 5 는 10(십진)이 사용되는 것을 명시하지만, 모든 브라우저가 아직 이렇게 되지 않습니다. 이러한 이유로 <strong>항상 <code>parseInt</code>를 사용할 때는 radix 값을 명시해야 합니다.</strong></li>
 <li>인풋 값 <code>string</code> 이 다른 값으로 시작 된다면, radix 는 10(십진)입니다.</li>
</ol>

<p>첫 번째 글자가 숫자로 변환될 수 없다면, <code>parseInt</code> 는 <code>NaN</code>을 리턴할 것입니다.</p>

<p>연산의 경우, <code>NaN</code> 값은 어떠한 radix 숫자도 아닙니다. <code>parseInt</code> 값이 <code>NaN</code>인지 알아내기 위해 {{jsxref("isNaN")}} 함수를 호출할 수 있습니다. 만약 <code>NaN</code>이 산술 연산으로 넘겨진다면, 이 연산의 결과 또한 NaN이 될 것입니다.</p>

<p>특정 진수의 스트링 리터럴로 숫자를 변환하는 것은 <code>intValue.toString(radix)</code>를 사용합니다.</p>

<div class="blockIndicator warning">
<p>{{jsxref("BigInt")}} 주의: <code>parseInt</code>는 {{jsxref("BigInt")}}를 {{jsxref("Number")}}으로 변환하여 정확성을 떨어뜨립니다. 이는 "n"을 포함한 숫자가 아닌 값은 삭제되기 때문입니다.</p>
</div>

<h2 id="radix가_없는_8진_해석">radix가 없는 8진 해석</h2>

<p>비록 ECMAScript 3 에서 권장되지 않고, ECMAScript 5 에서 금지되었지만, 많은 구현들은 <code>0</code>으로 시작하는 8진수 문자열을 해석합니다. 다음의 코드는 8진 결과를 가질 수도 있으며, 10진의 결과를 가질 수도 있습니다. <strong>항상 이러한 명확하지 않은 표현은 피하고 <code>radix</code>를 명시하도록 합니다.</strong></p>

<pre class="brush: js notranslate">parseInt("0e0"); // 0
parseInt("08"); // 0, '8' 은 8진수가 아니다.
</pre>

<h3 id="ECMAScript_5는_8진수_해석을_삭제하였습니다.">ECMAScript 5는 8진수 해석을 삭제하였습니다.</h3>

<p>ECMAScript 5의 <code>parseInt</code> 함수 스펙은 더 이상 <code>0</code> 으로 시작하는 8진수 값의 문자열을 다루는 구현을 허용하지 않습니다. ECMAScript 5는 다음을 발표했습니다. :</p>

<p><code>parseInt</code> 함수는 특정 radix(진수)값에 따라 문자열 아규먼트 내용의 해석을 하고, 그 영향을 받은 정수 값을 생성합니다. 문자열 내에서 시작되는 부분에 위치한 공백은 무시됩니다. 만약 radix 값이 정의되지 않거나, <code>0</code>이라면, 이것은 10진수로 여겨집니다. <code>0x</code> 이나 <code>0X</code> 으로 시작되는 숫자 일 때는 16진수로 여겨집니다.</p>

<p>ECMAScript 3 와의 차이는 8진수의 해석을 허용하고 있느냐의 차이입니다.</p>

<p>많은 구현들이 2013부터 이 방식을 채택하고 있지 않아 왔습니다. 오래된 브라우저는 지원되어야 하기 때문에 <strong>항상 radix 값을 명시 해야합니다. </strong></p>

<h2 id="더_엄격한_파싱_함수">더 엄격한 파싱 함수</h2>

<p>가끔은 int 값을 파싱할 때 더 엄격한 방식을 이용하는 것이유용합니다. 정규 표현식이 도움이 될 것입니다. :</p>

<pre class="brush: js notranslate">filterInt = function (value) {
  if(/^(\-|\+)?([0-9]+|Infinity)$/.test(value))
    return Number(value);
  return NaN;
}

console.log(filterInt('421'));               // 421
console.log(filterInt('-421'));              // -421
console.log(filterInt('+421'));              // 421
console.log(filterInt('Infinity'));          // Infinity
console.log(filterInt('421e+0'));            // NaN
console.log(filterInt('421hop'));            // NaN
console.log(filterInt('hop1.61803398875'));  // NaN
console.log(filterInt('1.61803398875'));     // NaN
</pre>

<h2 id="예제">예제</h2>

<h3 id="parseInt_사용하기"><code>parseInt()</code> 사용하기</h3>

<p>다음의 예제는 모두 <code>15</code>를 리턴합니다.</p>

<pre class="brush: js notranslate">parseInt(" 0xF", 16);
parseInt(" F", 16);
parseInt("17", 8);
parseInt(021, 8);
parseInt("015", 10);   // parseInt(015, 10);  13이 리턴될 것입니다.
parseInt(15.99, 10);
parseInt("15,123", 10);
parseInt("FXX123", 16);
parseInt("1111", 2);
parseInt("15*3", 10);
parseInt("15e2", 10);
parseInt("15px", 10);
parseInt("12", 13);
</pre>

<p>다음의 예제는 모두 <code>NaN</code>을 리턴합니다.</p>

<pre class="brush: js notranslate">parseInt("Hello", 8); // 전부 숫자가 아님.
parseInt("546", 2);   // 숫자는 2진법 표현이 불가능함.
</pre>

<p>다음의 예제는 모두 <code>-15</code>을 리턴합니다. :</p>

<pre class="brush: js notranslate">parseInt("-F", 16);
parseInt("-0F", 16);
parseInt("-0XF", 16);
parseInt(-15.1, 10)
parseInt(" -17", 8);
parseInt(" -15", 10);
parseInt("-1111", 2);
parseInt("-15e1", 10);
parseInt("-12", 13);
</pre>

<p>다음의 예제는 모두 <code>4</code>를 리턴합니다.</p>

<pre class="notranslate">parseInt(4.7, 10)
parseInt(4.7 * 1e22, 10)        // 매우 큰 숫자가 4가 됨
parseInt(0.00000000000434, 10)  // 매우 작은 숫자가 4가 됨
</pre>

<p>만약 숫자가 <code>1e+21</code>과 같거나 큰 경우, 또는 <code>1e-7</code>과 같거나 작은 경우, <code>1</code>을 리턴합니다.(radix가 <code>10</code>인 경우)</p>

<pre class="notranslate">parseInt(0.0000001,10);
parseInt(0.000000123,10);
parseInt(1e-7,10);
parseInt(1000000000000000000000,10);
parseInt(123000000000000000000000,10);
parseInt(1e+21,10);
</pre>

<p>다음의 예제는 모두 <strong><code>224</code></strong>를 리턴합니다.</p>

<pre class="brush: js notranslate">parseInt("0e0", 16);
</pre>

<p>{{jsxref("BigInt")}} 는 정확성을 잃습니다.</p>

<pre class="notranslate">parseInt('900719925474099267n')
// 900719925474099300</pre>

<p><code>parseInt</code> 는 숫자구분자와 같이 작동하지 않습니다.</p>

<pre class="notranslate">parseInt('123_456')
// 123</pre>

<h2 id="명세">명세</h2>

<table>
 <thead>
  <tr>
   <th scope="col">Specification</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-parseint-string-radix', 'parseInt')}}</td>
  </tr>
 </tbody>
</table>

<h2 id="브라우저_호환성">브라우저 호환성</h2>

<div id="compat-mobile">{{Compat("javascript.builtins.parseInt")}}</div>

<h2 id="같이_보기">같이 보기</h2>

<ul>
 <li>{{jsxref("Global_Objects/parseFloat", "parseFloat()")}}</li>
 <li>{{jsxref("Number.parseFloat()")}}</li>
 <li>{{jsxref("Number.parseInt()")}}</li>
 <li>{{jsxref("Global_Objects/isNaN", "isNaN()")}}</li>
 <li>{{jsxref("Number.toString()")}}</li>
 <li>{{jsxref("Object.valueOf")}}</li>
</ul>
