---
title: RegExp() constructor
slug: Web/JavaScript/Reference/Global_Objects/RegExp/RegExp
tags:
  - Constructor
  - JavaScript
  - Reference
  - RegExp
translation_of: Web/JavaScript/Reference/Global_Objects/RegExp/RegExp
---
<div>{{JSRef}}</div>

<p><strong><code>RegExp</code></strong> 생성자는 패턴을 사용해 텍스트를 판별할 때 사용하는 정규 표현식 객체를 생성합니다.</p>

<p>정규 표현식에 대한 소개는 <a href="/ko/docs/Web/JavaScript/Guide/Regular_Expressions">JavaScript 안내서의 정규 표현식 장</a>을 참고하세요.</p>

<div>{{EmbedInteractiveExample("pages/js/regexp-constructor.html")}}</div>



<h2 id="구문">구문</h2>

<p>리터럴, 생성자, 팩토리 표기법이 가능합니다.</p>

<pre class="syntaxbox ">/<var>pattern</var>/<var>flags</var>
new RegExp(<var>pattern</var>[, <var>flags</var>])
RegExp(<var>pattern</var>[, <var>flags</var>])
</pre>

<h3 id="매개변수">매개변수</h3>

<dl>
 <dt><code><var>pattern</var></code></dt>
 <dd>정규 표현식을 나타내는 텍스트.</dd>
 <dd>ES5부터는, 생성자 표기법에 한정하여 다른 <code>RegExp</code> 객체 혹은 리터럴을 사용할 수 있습니다. 패턴은 <a href="/ko/docs/Web/JavaScript/Guide/정규식#특수_문자_사용하기">특수 문자</a>를 포함할 수 있어서 일반적인 문자열 리터럴보다 더 넓은 범위의 값을 판별할 수 있습니다.</dd>
 <dt><code><var>flags</var></code></dt>
 <dd>
 <p>정규 표현식에 추가할 플래그.</p>

 <p>정규 표현식 객체를 패턴으로 제공한 경우 <code><var>flags</var></code> 문자열은 제공한 객체의 플래그를 모두 대체하며 <code>lastIndex</code>를 <code>0</code>으로 초기화합니다. (ES2015 이후)</p>

 <p><code><var>flags</var></code>를 지정하지 않았으면서 정규 표현식 객체를 제공한 경우, 해당 객체의 플래그와 <code>lastIndex</code>를 복제합니다.</p>

 <p><code>flags</code>는 다음 문자를 조합하여 지정할 수 있습니다.</p>

 <dl>
  <dt><code>g</code> (global, 전역 판별)</dt>
  <dd>처음 일치에서 중단하지 않고, 문자열 전체를 판별합니다.</dd>
  <dt><code>i</code> (ignore case, 대소문자 무시)</dt>
  <dd><code>u</code> 플래그까지 활성화된 경우, Unicode 대소문자 폴딩을 사용합니다.</dd>
  <dt><code>m</code> (multiline, 여러 줄)</dt>
  <dd>시작과 끝 문자(<code>^</code>과 <code>$</code>)가 여러 줄에 걸쳐 동작합니다. 즉, 전체 입력 문자열의 맨 처음과 맨 끝 뿐만 아니라 (<code>\n</code>이나 <code>\r</code>로 구분되는) <u>각각의</u> 줄의 처음과 끝도 일치합니다.</dd>
  <dt><code>s</code> ("dotAll")</dt>
  <dd><code>.</code>이 줄 바꿈에도 일치합니다.</dd>
  <dt><code>u</code> (unicode)</dt>
  <dd><code><var>pattern</var></code>을 Unicode 코드 포인트 시퀀스로 처리합니다. (<a href="/ko/docs/Web/API/DOMString/Binary">이진 문자열</a> 참고)</dd>
  <dt><code>y</code> (sticky, 접착)</dt>
  <dd>이 정규 표현식의 <code>lastIndex</code> 속성에 명시된 인덱스에서만 판별하고, 이전/이후 인덱스에서 판별을 시도하지 않습니다.</dd>
 </dl>
 </dd>
</dl>

<h2 id="예제">예제</h2>

<h3 id="리터럴_표기법과_생성자">리터럴 표기법과 생성자</h3>

<p><code>RegExp</code> 객체는 리터럴 표기법과 생성자로써 생성할 수 있습니다.</p>

<ul>
 <li><strong>리터럴 표기법</strong>의 매개변수는 두 빗금으로 감싸야 하며 따옴표를 사용하지 않습니다.</li>
 <li><strong>생성자 함수</strong>의 매개변수는 빗금으로 감싸지 않으나 따옴표를 사용합니다.</li>
</ul>

<p>다음의 세 표현식은 모두 같은 정규 표현식을 생성합니다.</p>

<pre class="brush: js ">/ab+c/i
new RegExp(/ab+c/, 'i') // 리터럴
new RegExp('ab+c', 'i') // 생성자
</pre>

<p>리터럴 표기법은 표현식을 평가할 때 정규 표현식을 컴파일합니다. 정규 표현식이 변하지 않으면 리터럴 표기법을 사용하세요. 예를 들어, 반복문 안에서 사용할 정규 표현식을 리터럴 표기법으로 생성하면 정규 표현식을 매번 다시 컴파일하지 않습니다.</p>

<p>정규 표현식 객체의 생성자(<code>new RegExp('ab+c')</code>)를 사용하면 정규 표현식이 런타임에 컴파일됩니다. 패턴이 변할 가능성이 있거나, 사용자 입력과 같이 알 수 없는 외부 소스에서 가져오는 정규 표현식의 경우 생성자 함수를 사용하세요.</p>

<h2 id="명세">명세</h2>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Specification</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-regexp-constructor', 'RegExp constructor')}}</td>
  </tr>
 </tbody>
</table>

<h2 id="브라우저_호환성">브라우저 호환성</h2>

<div>


<p>{{Compat("javascript.builtins.RegExp.RegExp")}}</p>
</div>

<h2 id="같이_보기">같이 보기</h2>

<ul>
 <li><a href="/ko/docs/Web/JavaScript/Guide/Regular_Expressions">JavaScript 안내서의 정규 표현식 장</a></li>
 <li>{{jsxref("String.prototype.match()")}}</li>
 <li>{{jsxref("String.prototype.replace()")}}</li>
</ul>
