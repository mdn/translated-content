---
title: isNaN()
slug: Web/JavaScript/Reference/Global_Objects/isNaN
tags:
  - JavaScript
  - Method
  - Reference
browser-compat: javascript.builtins.isNaN
translation_of: Web/JavaScript/Reference/Global_Objects/isNaN
---
<div>{{jsSidebar("Objects")}}</div>

<p><code><strong>isNaN()</strong></code> 함수는 어떤 값이 {{jsxref("NaN")}}인지 판별합니다. <code>isNaN</code> 함수는 몇몇 <a href="special-behavior">혼란스러운 케이스</a>을 가지고 있으므로, ECMAScript 2015에서 추가한 {{jsxref("Number.isNaN()")}}으로 바꾸는 편이 좋을 수도 있습니다.</p>

<p>{{EmbedInteractiveExample("pages/js/globalprops-isnan.html")}}</p>

<h2 id="구문">구문</h2>

<pre class="syntaxbox"><code>isNaN(<em>value</em>)</code></pre>

<h3 id="매개변수">매개변수</h3>

<dl>
 <dt><code>value</code></dt>
 <dd>테스트되는 값.</dd>
</dl>

<h3 id="반환_값">반환 값</h3>

<p>주어진 값이 {{jsxref("NaN")}}이면 <code>true</code>, 아니면 <code>false</code>.</p>

<h2 id="설명">설명</h2>

<h3 id="isNaN_함수의_필요성"><code>isNaN</code> 함수의 필요성</h3>

<p>JavaScript의 다른 모든 값과 달리, {{jsxref("NaN")}}은 같음 연산(<code>==</code>, <code>===</code>)을 사용해 판별할 수 없습니다. <code>NaN == NaN</code>, <code>NaN === NaN</code>이기 때문입니다. 그래서 <code>NaN</code>을 판별하는 함수가 필요합니다.</p>

<h3 id="NaN_값의_기원"><code>NaN</code> 값의 기원</h3>

<p><code>NaN</code> 값은 산술 연산이 <strong>정의되지 않은</strong> 결과 또는 <strong>표현할 수 없는</strong> 결과를 도출하면 생성되며, 반드시 오버플로 조건을 나타내는 것은 아닙니다. 숫자가 아닌 값의 변환을 시도했으나 알맞은 원시 숫자 값이 없는 경우의 결과도 <code>NaN</code>입니다.</p>

<p>예를 들어 0을 0으로 나누면 <code>NaN</code>이지만, 다른 수를 0으로 나누면 그렇지 않습니다.</p>

<h3 id="혼란스러운_특별_케이스_행동"><a  name="special-behavior"></a>혼란스러운 특별 케이스 행동</h3>

<p><code>isNaN</code> 함수 스펙의 아주 초기 버전 이후로, 숫자 아닌 인수를 위한 행동이 혼란스럽습니다. <code>isNaN</code> 함수의 인수가 <a href="http://es5.github.com/#x8.5">Number</a> 형이 아닌 경우, 그 값은 먼저 숫자로 강제됩니다. 결과값은 그 뒤에 {{jsxref("NaN")}}인지 결정하기 위해 테스트됩니다. 따라서 숫자 형으로 강제된 결과 유효한 비 NaN 숫자값(특히 강제될 때 숫자값이 0 또는 1을 주는 빈 문자열 및 불린 원시형)이 되는 비 숫자의 경우, "false" 반환값은 예기치 않을 수 있습니다; 예를 들어 빈 문자열은 분명히 "not a number"입니다. 혼란(confusion)은 용어 "not a number"가 IEEE-754 부동 소수점 값으로 표현된 숫자에 특정 의미가 있다는 사실에서 생깁니다. 함수는 "이 값이, 숫자값으로 강제되는 경우, IEEE-754 'Not A Number' 값인가?"라는 질문에 답하는 것으로 해석되어야 합니다.</p>

<p>ECMAScript (ES2015) 최근 버전은 {{jsxref("Number.isNaN()")}} 함수를 포함합니다. <code>Number.isNaN(x)</code>는 <code>x</code>가 <code>NaN</code>인지 아닌지 테스트하는 믿을 수 있는 방법이 됩니다. 그러나 <code>Number.isNaN</code>으로도, <code>NaN</code>의 의미는 정확한 숫자 의미로 남아있고 단순히 "not a number"는 아닙니다. 그 대신에, <code>Number.isNaN</code>이 없을 경우에, 식 <code>(x != x)</code>은 변수 <code>x</code>가 <code>NaN</code>인지 아닌지 테스트하는 더 믿을 수 있는 방법입니다, 그 결과는 <code>isNaN</code>을 믿을 수 없게 하는 오탐(false positive)의 대상이 아니기에.</p>

<p>당신은 isNaN을 다음과 같이 생각할 수 있습니다:</p>

<pre class="brush: js">isNaN = function(value) {
    Number.isNaN(Number(value));
}</pre>

<h2 id="예제">예제</h2>

<pre class="brush: js">isNaN(NaN);       // 참
isNaN(undefined); // 참
isNaN({});        // 참

isNaN(true);      // 거짓
isNaN(null);      // 거짓
isNaN(37);        // 거짓

// 문자열
isNaN("37");      // 거짓: "37"은 NaN이 아닌 숫자 37로 변환됩니다
isNaN("37.37");   // 거짓: "37.37"은 NaN이 아닌 숫자 37.37로 변환됩니다
isNaN("123ABC");  // 참: parseInt("123ABC")는 123이지만 Number("123ABC")는 NaN입니다
isNaN("");        // 거짓: 빈 문자열은 NaN이 아닌 0으로 변환됩니다
isNaN(" ");       // 거짓: 공백이 있는 문자열은 NaN이 아닌 0으로 변환됩니다

// dates
isNaN(new Date());                // 거짓
isNaN(new Date().toString());     // 참

// 이것이 허위 양성이고 isNaN이 완전히 신뢰할 수 없는 이유이다.
isNaN("blabla")   // 참: "blabla"는 숫자로 변환됩니다.
                  // 이것을 숫자롯 parsing 하는 것을 실패하고 NaN을 반환한다.
</pre>

<h3 id="유용한_특별_케이스_행동">유용한 특별 케이스 행동</h3>

<p><code>isNaN()</code>을 고려한 더 용도 중심 방법이 있습니다: <code>isNaN(x)</code>가 <code>false</code>를 반환하면, 그 식이 <code>NaN</code>을 반환하게 하지 않고 산술 식에 <code>x</code>를 쓸 수 있습니다. <code>true</code>를 반환하는 경우, <code>x</code>는 모든 산술 식이 <code>NaN</code>을 반환하게 합니다. 이는 JavaScript에서, <code>isNaN(x) == true</code>가 <code>NaN</code>을 반환하는 <code>x - 0</code>과 동일함(JavaScript에서 <code>x - 0 == NaN</code>가 항상 거짓을 반환하여 그것을 테스트할 수 없지만)을 뜻합니다. 실제로, <code>isNaN(x)</code>, <code>isNaN(x - 0)</code>, <code>isNaN(Number(x))</code>, <code>Number.isNaN(x - 0)</code> 및 <code>Number.isNaN(Number(x))</code>는 항상 같은 값을 반환하며 JavaScript에서 <code>isNaN(x)</code>는 그저 이러한 각각의 조건(terms)을 표현하는 가장 짧은 형태입니다.</p>

<p>예를 들어 함수에 인수가 산술 처리 가능한(숫자 "처럼" 쓸 수 있는)지를 테스트하기 위해 사용할 수 있습니다, 그렇지 않은 경우 기본 값 또는 다른 무언가를 제공해야 합니다. 이런 식으로 문맥에 따라 암시적인 값 변환을 제공하는 JavaScript의 다양성(versatility) 전체를 이용케 하는 함수를 가질 수 있습니다.</p>

<h2 id="예시">예시</h2>

<pre class="brush: js">function increment(x) {
  if (isNaN(x)) x = 0;
  return x + 1;
};

// Number.isNaN()과 같은 효과:
function increment(x) {
  if (Number.isNaN(Number(x))) x = 0;
  return x + 1;
};

// 함수의 인수 x에 대해 다음 경우에,
// isNaN(x)는 항상 거짓, x가 실제 숫자가 아닐지라도
// 하지만 산술 식에 그대로
// 사용될 수 있습니다
increment("");            // 1: ""는 0으로 변환됩니다
increment(new String());  // 1: 빈 문자열을 나타내는 String 객체는 0으로 변환됩니다
increment([]);            // 1: []는 0으로 변환됩니다
increment(new Array());   // 1: 빈 배열을 나타내는 Array 객체는 0으로 변환됩니다
increment("0");           // 1: "0"은 0으로 변환됩니다
increment("1");           // 2: "1"은 1로 변환됩니다
increment("0.1");         // 1.1: "0.1"은 0.1로 변환됩니다
increment("Infinity");    // Infinity: "Infinity"는 Infinity로 변환됩니다
increment(null);          // 1: null은 0으로 변환됩니다
increment(false);         // 1: false는 0으로 변환됩니다
increment(true);          // 2: true는 1로 변환됩니다
increment(new Date());    // 밀리초로 현재 date/time + 1을 반환합니다

// 함수의 인수 x에 대해 다음 경우에,
// isNaN(x)는 항상 거짓이고 x는 실제로 숫자입니다
increment(-1);            // 0
increment(-0.1);          // 0.9
increment(0);             // 1
increment(1);             // 2
increment(2);             // 3
// ... 등등 ...
increment(Infinity);      // Infinity

// 함수의 인수 x에 대해 다음 경우에,
// isNaN(x)는 항상 참이고 x는 실제로 숫자가 아닙니다,
// 따라서 함수는 인수를 0으로 대체하고 1을 반환합니다
increment(String);            // 1
increment(Array);             // 1
increment("blabla");          // 1
increment("-blabla");         // 1
increment(0/0);               // 1
increment("0/0");             // 1
increment(Infinity/Infinity); // 1
increment(NaN);               // 1
increment(undefined);         // 1
increment();                  // 1

// isNaN(x)는 항상 isNaN(Number(x))과 같지만,
// x의 존재는 여기서 필수입니다!
isNaN(x) == isNaN(Number(x)) // x == undefined 포함 x의 어떤 값도 참,
                             // isNaN(undefined) == true 및 Number(undefined)가 NaN을 반환하기에,
                             // 하지만 ...
isNaN() == isNaN(Number())   // 거짓, isNaN() == true 및 Number() == 0 때문에
</pre>

<h2 id="명세">명세</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">명세</th>
   <th scope="col">상태</th>
   <th scope="col">설명</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>초기 정의.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-15.1.2.4', 'isNaN')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td></td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-isnan-number', 'isNaN')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td></td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-isnan-number', 'isNaN')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="브라우저_호환성">브라우저 호환성</h2>

<div>{{Compat}}</div>

<h2 id="같이_보기">같이 보기</h2>

<ul>
 <li>{{jsxref("NaN")}}</li>
 <li>{{jsxref("Number.isNaN()")}}</li>
</ul>
