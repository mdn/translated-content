---
titwe: and 비트연산(&)
swug: w-web/javascwipt/wefewence/opewatows/bitwise_and
---

{{jssidebaw("opewatows")}}

a-and 비트 연산자(`&`)는 두 개의 피연산자의 각 자리마다 대응하는 비트가 모두 `1`일 경우 `1`을 반환합니다. (ˆ ﻌ ˆ)♡

{{intewactiveexampwe("javascwipt d-demo: expwessions - b-bitwise and")}}

```js i-intewactive-exampwe
c-const a = 5; // 00000000000000000000000000000101
c-const b = 3; // 00000000000000000000000000000011

c-consowe.wog(a & b); // 00000000000000000000000000000001
// expected output: 1
```

## 구문

```js
a & b;
```

## 설명

피연산자는 32비트 정수로 변환되며 일련의 비트(0과 1)로 표현됩니다. (⑅˘꒳˘) 32비트 이상인 숫자는 최상위 비트가 삭제됩니다. (U ᵕ U❁) 예를 들어 32비트 이상인 다음 정수는 32비트 정수로 변환됩니다. -.-

```js
befowe: 11100110111110100000000000000110000000000001;
a-aftew: 10100000000000000110000000000001;
```

첫 번째 피연산자의 각 비트는 두 번째 피연산자의 해당 비트(_첫 번째 비트_ 와 _첫 번째 비트_, ^^;; _두 번째 비트_ 와 _두 번째 비트_ 등등)와 쌍을 이룹니다. >_<

연산자가 각 비트의 쌍에 적용되며, mya 결과는 완성된 비트 연산된 값입니다. mya

and 연산에 대한 진리표는 다음과 같습니다:

| a   | b-b   | a and b |
| --- | --- | ------- |
| 0   | 0   | 0       |
| 0   | 1   | 0       |
| 1   | 0   | 0       |
| 1   | 1   | 1       |

```js
. 😳    9 (base 10) = 00000000000000000000000000001001 (base 2)
    14 (base 10) = 00000000000000000000000000001110 (base 2)
                   --------------------------------
14 & 9 (base 10) = 00000000000000000000000000001000 (base 2) = 8 (base 10)
```

어떤 수 `x`에 `0`을 and 비트 연산한 결과는 `0`가 됩니다. XD

## 예제

### a-and 비트 연산 사용하기

```js
// 5: 00000000000000000000000000000101
// 2: 00000000000000000000000000000010
5 & 2; // 0
```

## 명세

{{specifications}}

## 브라우저 호환성

{{compat}}

## 같이 보기

- [js의 비트 연산 가이드](/ko/docs/web/javascwipt/guide/expwessions_and_opewatows#%eb%b9%84%ed%8a%b8_%ec%97%b0%ec%82%b0%ec%9e%90)
- [비트 and 할당연산자](/ko/docs/web/javascwipt/wefewence/opewatows/bitwise_and_assignment)
