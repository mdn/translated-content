---
title: 오른쪽 시프트 (>>)
slug: Web/JavaScript/Reference/Operators/Right_shift
l10n:
  sourceCommit: fad67be4431d8e6c2a89ac880735233aa76c41d4
---

{{jsSidebar("Operators")}}

**오른쪽 시프트 (`>>`)** 연산자는 첫 번째 피연산자의 이진 표현을 지정된 비트 수만큼 오른쪽으로 이동시킨 숫자나 BigInt를 반환합니다. 오른쪽으로 밀려나간 초과 비트들은 버려지고, 왼쪽 끝 비트의 복사본이 왼쪽에서부터 채워집니다. 이 연산은 "부호 전파 오른쪽 시프트" 또는 "산술적 오른쪽 시프트"라고도 불리는데, 그 이유는 결과값의 부호가 첫 번째 피연산자의 부호와 같기 때문입니다.

{{InteractiveExample("JavaScript Demo: Right shift (>>) operator")}}

```js interactive-example
const a = 5; //  00000000000000000000000000000101
const b = 2; //  00000000000000000000000000000010
const c = -5; //  11111111111111111111111111111011

console.log(a >> b); //  00000000000000000000000000000001
// Expected output: 1

console.log(c >> b); //  11111111111111111111111111111110
// Expected output: -2
```

## 구문

```js-nolint
x >> y
```

## 설명

`>>` 연산자는 두 가지 타입의 피연산자에 대해 오버로드되어 있습니다. number와 [BigInt](/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt). 숫자의 경우 연산 결과는 32비트 정수이며, BigInt의 경우 BigInt를 반환합니다. 이 연산자는 먼저 [두 피연산자를 숫자형으로 강제 변환](/ko/docs/Web/JavaScript/Guide/Data_structures#숫자_강제_변환)한 뒤, 각각의 타입을 검사합니다. 두 피연산자가 모두 BigInt가 되면 BigInt 우측 시프트를 수행하고, 그렇지 않으면 두 피연산자를 [32비트 정수](/ko/docs/Web/JavaScript/Reference/Global_Objects)로 변환한 후 숫자 우측 시프트를 수행합니다. 한쪽은 BigInt로, 다른 한쪽은 number로 변환될 경우 {{jsxref("TypeError")}}가 발생합니다.

새로운 최상위 비트가 이전 최상위 비트와 같은 값을 가지므로, 부호 비트(최상위 비트)는 변경되지 않습니다. 따라서 "부호 전파"라는 이름이 붙었습니다.

이 연산자는 왼쪽 피연산자의 비트 표현을 [2의 보수](https://en.wikipedia.org/wiki/Two's_complement)로 처리합니다. 10진수(기수 10) 숫자 `9`와 `-9`의 32비트 이진 표현을 고려합니다.

```plain
     9 (기수 10): 00000000000000000000000000001001 (기수 2)
    -9 (기수 10): 11111111111111111111111111110111 (기수 2)
```

음의 10진수 숫자 `-9`의 2의 보수 이진 표현은 그 반대 숫자인 `9`(`00000000000000000000000000001001`)의 모든 비트를 반전시키고 `1`을 더해 형성됩니다.

두 경우 모두 이진수의 부호는 가장 왼쪽 비트로 결정됩니다. 양의 10진수 숫자 `9`의 경우 이진 표현의 가장 왼쪽 비트는 `0`이고, 음의 10진수 숫자 `-9`의 경우 이진 표현의 가장 왼쪽 비트는 `1`입니다.

앞서 제시한 10진수(기수 10) 숫자 `9`와 `-9`의 이진 표현을 기준으로 합니다.

`9 >> 2`의 결과는 2:

```plain
     9 (기수 10): 00000000000000000000000000001001 (기수 2)
                  --------------------------------
9 >> 2 (기수 10): 00000000000000000000000000000010 (기수 2) = 2 (기수 10)
```

오른쪽 끝 두 비트 `01`가 밀려 나간 것을 확인할 수 있으며, 왼쪽에서 최상위 비트 `0` 두 개가 복사되어 들어온 것을 알 수 있습니다.

`-9 >> 2`의 결과는 `-3`:

```plain
     -9 (기수 10): 11111111111111111111111111110111 (기수 2)
                   --------------------------------
-9 >> 2 (기수 10): 11111111111111111111111111111101 (기수 2) = -3 (기수 10)
```

오른쪽 끝 두 비트 `11`가 밀려 나간 것을 확인할 수 있습니다. 그러나 최상위 비트를 보면, 이 경우 최상위 비트는 `1`입니다. 따라서 그 최상위 `1` 비트 두 개가 왼쪽에서 밀려 들어와 음수 부호가 유지됩니다.

이진 표현 `11111111111111111111111111111101`는 음의 10진수 숫자 `-3`과 같습니다. 모든 음수 정수는 [2의 보수](https://en.wikipedia.org/wiki/Two's_complement)로 저장되며, 이 값은 양의 10진수 숫자 `3`(`00000000000000000000000000000011`)의 이진 표현을 모든 비트를 반전시키고 1을 더하여 계산할 수 있습니다.

만약 왼쪽 피연산자가 32비트를 초과하는 숫자라면, 최상위 비트가 버려집니다. 예를 들어, 다음과 같이 32비트를 초과하는 정수는 32비트 정수로 변환됩니다.

```plain
변환 전: 11100110111110100000000000000110000000000001
변환 후:             10100000000000000110000000000001
```

오른쪽 피연산자는 부호 없는 32비트 정수로 변환된 후 32로 나눈 나머지를 취하게 되므로, 실제 시프트 오프셋은 항상 0에서 31 사이의 양의 정수가 됩니다. 예를 들어, `100 >> 32`는 `100 >> 0`과 같으며 결과는 `100`이 됩니다. 이는 32를 32로 나눈 나머지가 0이기 때문입니다.

> [!WARNING]
> 사람들이 숫자를 정수로 잘라내기 위해 `>> 0`을 사용하는 것을 볼 수 있습니다. 어떤 숫자 `x`를 0만큼 오른쪽 시프트하면 `x`가 32비트 정수로 변환되며, -2147483648에서 2147483647 범위를 벗어나는 숫자의 최상위 비트가 제거됩니다. 대신 [`Math.trunc()`](/ko/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#비트_연산_no-ops을_사용하여_숫자_잘라내기)를 사용하세요.

BigInt의 경우 잘림이 없습니다. 개념적으로, 양의 BigInt는 무한히 많은 선행 `0` 비트를 가진 것으로 이해하고, 음의 BigInt는 무한히 많은 선행 `1` 비트를 가진 것으로 이해하면 됩니다.

## 예제

### 오른쪽 시프트 사용하기

```js
9 >> 2; // 2
-9 >> 2; // -3

9n >> 2n; // 2n
```

## 명세서

{{Specifications}}

## 브라우저 호환성

{{Compat}}

## 같이 보기

- [JavaScript에서 비트 연산자 가이드](/ko/docs/Web/JavaScript/Guide/Expressions_and_operators#%eb%b9%84%ed%8a%b8_%ec%97%b0%ec%82%b0%ec%9e%90)
- [Right shift assignment (>>=)](/ko/docs/Web/JavaScript/Reference/Operators/Right_shift_assignment)
- [Unsigned right shift (>>>)](/ko/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift)
