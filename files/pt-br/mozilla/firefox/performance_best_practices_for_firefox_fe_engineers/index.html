---
title: Performance best practices for Firefox front-end engineers
slug: Mozilla/Firefox/Performance_best_practices_for_Firefox_fe_engineers
translation_of: Mozilla/Firefox/Performance_best_practices_for_Firefox_fe_engineers
---
<div>{{FirefoxSidebar}}</div>

<p>This guide will help Firefox developers working on front-end code produce code which is as performant as possible—not just on its own, but in terms of its impact on other parts of Firefox. Always keep in mind the side effects your changes may have, from blocking other tasks, to interfering with other user interface elements.</p>

<h2 id="Avoid_the_main_thread_where_possible">Avoid the main thread where possible</h2>

<p>The main thread is where we process user events and do painting. It's also important to note that most of our JavaScript runs on the main thread, so it's easy for script to cause delays in event processing or painting. That means that the more code we can get off of the main thread, the more that thread can respond to user events, paint, and generally be responsive to the user.</p>

<p>You might want to consider using a {{domxref("Worker")}} if you need to do some computation that can be done off of the main thread. If you need more elevated privileges than a standard worker allows, consider using a {{domxref("ChromeWorker")}}, which is a Firefox-only API which lets you create workers with more elevated privileges.</p>

<h2 id="Use_requestIdleCallback">Use requestIdleCallback()</h2>

<p>If you simply cannot avoid doing some kind of long job on the main thread, try to break it up into smaller pieces that you can run when the browser has a free moment to spare, and the user isn't doing anything. You can do that using {{domxref("Window.requestIdleCallback", "requestIdleCallback()")}} and the <a href="/en-US/docs/Web/API/Background_Tasks_API">Cooperative Scheduling of Background Tasks API</a>, and doing it only when we have a free second where presumably the user isn’t doing something.</p>

<p>See also the blog post <a href="https://hacks.mozilla.org/2016/11/cooperative-scheduling-with-requestidlecallback/">Collective scheduling with requestIdleCallback</a>.</p>

<p>As of {{bug(1353206)}}, you can also schedule idle events in non-DOM contexts by using <code>Services.tm.idleDispatchToMainThread.</code> See the <code>nsIThreadManager.idl</code> file for more details.</p>

<h2 id="Hide_your_panels">Hide your panels</h2>

<p>If you’re adding a new XUL {{XULElem("popup")}} or {{XULElem("panel")}} to a document, set the {{XULAttr("hidden")}} attribute to <code>true</code> by default. By doing so, you cause the binding applied on demand rather than at load time, which makes initial construction of the XUL document faster.</p>

<h2 id="Get_familiar_with_the_pipeline_that_gets_pixels_to_the_screen">Get familiar with the pipeline that gets pixels to the screen</h2>

<p>Learn how pixels you draw make their way to the screen. Knowing the path they will take through the various layers of the browser engine will help you optimize your code to avoid pitfalls.</p>

<p>The rendering process goes through the following steps:<img alt="This is the pipeline that a browser uses to get pixels to the screen." src="https://mdn.mozillademos.org/files/14995/pasted%20image%200.png" style="height: 167px; width: 1093px;"></p>

<div class="note">
<p>The above image is used under <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>, courtesy of <a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing">this page</a> from our friends at Google, which itself is well worth the read.</p>
</div>

<div class="note">
<p>For a very down-to-earth explanation of the Style, Layout, Paint and Composite steps of the pipeline, <a href="https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/">this Hacks blog post</a> does a great job of explaining it.</p>
</div>

<p>To achieve a 60 FPS frame rate, all of the above has to happen in 16 milliseconds or less, every frame.</p>

<p>Note that {{domxref("Window.requestAnimationFrame", "requestAnimationFrame()")}} lets you queue up JavaScript to <strong>run right before the style flush occurs</strong>. This allows you to put all of your DOM writes (most importantly, anything that could change the size or position of things in the DOM) just before the style and layout steps of the pipeline, combining all the style and layout calculations into a single batch so it all happens once, in a single frame tick, instead of across multiple frames. See {{anch("Detecting and avoiding synchronous reflow")}} below for more information.</p>

<p>This also means that {{domxref("Window.requestAnimationFrame", "requestAnimationFrame()")}} is <strong>not a good place</strong> to put queries for layout or style information.</p>

<h2 id="Detecting_and_avoiding_synchronous_style_flushes">Detecting and avoiding synchronous style flushes</h2>

<h3 id="What_are_style_flushes">What are style flushes?</h3>

<p>When CSS is applied to a document (HTML or XUL, it doesn’t matter), the browser does calculations to figure out which CSS styles will apply to each element. This happens the first time the page loads and the CSS is initially applied, but can happen again if JavaScript modifies the DOM.</p>

<p>JavaScript code might, for example, change DOM node attributes (either directly or by adding or removing classes from elements), and can also add, remove, or delete DOM nodes. Because styles are normally scoped to the entire document, the cost of doing these style calculations is proportional to the number of DOM nodes in the document (and the number of styles being applied).</p>

<p>It is expected that over time, script will update the DOM, requiring us to recalculate styles. Normally, the changes to the DOM just result in the standard style calculation occurring immediately after the JavaScript has finished running during the 16ms window, inside the "Style" step. That's the ideal scenario.</p>

<p>However, it's possible for script to do things that force multiple style calculations (or <strong>style flushes</strong>) to occur synchronously during the JavaScript part of the 16 ms window. The more of them there are, the more likely they'll exceed the 16ms frame budget. If that happens, some of them will be postponed until the next frame (or possibly multiple frames, if necessary), this skipping of frames is called <strong>jank</strong>.</p>

<p>Generally speaking, you force a synchronous style flush any time you query for style information after the DOM has changed within the same frame tick. Depending on whether or not <a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a">the style information you’re asking for has something to do with size or position</a>, you may also cause a layout recalculation (also referred to as <strong>layout flush</strong> or <strong>reflow</strong>), which is also an expensive step (see {{anch("Detecting and avoiding synchronous reflow")}} below).</p>

<p>To avoid this: avoid reading style information if you can. If you <em>must</em> read style information, do so at the very beginning of the frame, before any changes have been made to the DOM since the last time a style flush occurred.</p>

<p>Historically, there hasn't been an easy way of doing this - however, {{bug(1434376)}} has recently landed some ChromeOnly helpers to the window binding to make this simpler.</p>

<p>If you want to queue up some JavaScript to run after the next "natural" style and layout flush, try:</p>

<pre class="brush: js">// Suppose we want to get the computed "display" style of some node without
// causing a style flush. We could do it this way:
async function nodeIsDisplayNone(node) {
  let display = await window.promiseDocumentFlushed(() =&gt; {
    // Do _not_ under any circumstances write to the DOM in one of these
    // callbacks!
    return window.getComputedStyle(node).display;
  });

  return display == "none";
}
</pre>

<div class="note">
<p>See {{anch("Detecting and avoiding synchronous reflow")}} for a more advanced example of getting layout information, and then setting it safely, without causing flushes.</p>
</div>

<p><code>promiseDocumentFlushed</code> is only available to priviledged script, and should be called on the inner window of a top-level frame. Calling it on the outer window of a subframe is not supported, and calling it from within the inner window of a subframe might cause the callback to fire even though a style and layout flush will still be required. These gotchas should be fixed by {{bug(1441173)}}.</p>

<p>For now, it is up to you as the consumer of this API to not accidentally write to the DOM within the <code>promiseDocumentFlushed</code> callback. Doing so might cause flushes to occur for other <code>promiseDocumentFlushed</code> callbacks that are scheduled to fire in the same tick of the refresh driver. {{bug(1441168)}} tracks work to make it impossible to modify the DOM within a <code>promiseDocumentFlushed</code> callback.</p>

<h3 id="Writing_tests_to_ensure_you_don’t_add_more_synchronous_style_flushes">Writing tests to ensure you don’t add more synchronous style flushes</h3>

<p>Unlike reflow, there isn’t a “observer” mechanism for style recalculations. However, as of Firefox 49, the {{ifattribute("nsIDOMWindowUtils", "elementsRestyled")}} attribute records a count of how many style calculations have occurred for a particular DOM window.</p>

<p>It should be possible to write a test that gets the <code>nsIDOMWindowUtils</code> for a browser window, records the number of styleFlushes, then <strong>synchronously calls the function</strong> that you want to test, and immediately after checks the styleFlushes attribute again. If the value went up, your code caused synchronous style flushes to occur.</p>

<p>Note that your test and function <em>must be called synchronously</em> in order for this test to be accurate. If you ever go back to the event loop (by yielding, waiting for an event, etc), style flushes unrelated to your code are likely to run, and your test will give you a false positive.</p>

<h2 id="Detecting_and_avoiding_synchronous_reflow">Detecting and avoiding synchronous reflow</h2>

<div class="note">
<p>This is also sometimes called “sync layout”, "sync layout flushes" or “sync layout calculations”</p>
</div>

<p><strong>Sync reflow</strong> is a term bandied about a lot, and has negative connotations. It's not unusual for an engineer to have only the vaguest sense of what it is—and to only know to avoid it. This section will attempt to demystify things.</p>

<p>The first time a document (XUL or HTML) loads, we parse the markup, and then apply styles. Once the styles have been calculated, we then need to calculate where things are going to be placed on the page. This layout step can be seen in the “16ms” pipeline graphic above, and occurs just before we paint things to be composited for the user to see.</p>

<p>It is expected that over time, script will update the DOM, requiring us to recalculate styles, and then update layout. Normally, however, the changes to the DOM just result in the standard style calculation that occurs immediately after the JavaScript has finished running during the 16ms window.</p>

<h3 id="Interruptible_reflow">Interruptible reflow</h3>

<p>Since <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=67752">the early days</a>, Gecko has had the notion of interruptible reflow. This is a special type of <strong>content-only</strong> reflow that checks at particular points whether or not it should be interrupted (usually to respond to user events).</p>

<p>Because <strong>interruptible reflows can only be interrupted when laying out content, and not chrome UI</strong>, the rest of this section is offered only as context.</p>

<p>When an interruptible reflow is interrupted, what really happens is that certain layout operations can be skipped in order to paint and process user events sooner.</p>

<p>When an interruptible reflow is interrupted, the best-case scenario is that all layout is skipped, and the layout operation ends.</p>

<p>The worst-case scenario is that none of the layout can be skipped despite being interrupted, and the entire layout calculation occurs.</p>

<p>Reflows that are triggered "naturally" by the 16ms tick are all considered interruptible. Despite not actually being interuptible when laying out chrome UI, striving for interruptible layout is always good practice because uninterruptible layout has the potential to be much worse (see next section).</p>

<p><strong>To repeat, only interruptible reflows in web content can be interrupted.</strong></p>

<h3 id="Uninterruptible_reflow">Uninterruptible reflow</h3>

<p>Uninterruptible reflow is what we want to <strong>avoid at all costs</strong>. Uninterruptible reflow occurs when some DOM node’s styles have changed such that the size or position of one or more nodes in the document will need to be updated, and then <strong>JavaScript asks for the size or position of anything</strong>. Since everything is pending a reflow, the answer isn't available, so everything stalls until the reflow is complete and the script can be given an answer. Flushing layout also means that styles must be flushed to calculate the most up-to-date state of things, so it's a double-whammy.</p>

<p>Here’s a simple example, cribbed from <a href="http://paulrouget.com/e/fxoshud">this blog post by Paul Rouget</a>:</p>

<pre class="brush: js">div1.style.margin = "200px";        // Line 1
var height1 = div1.clientHeight;    // Line 2
div2.classList.add("foobar");       // Line 3
var height2 = div2.clientHeight;    // Line 4
doSomething(height1, height2);      // Line 5</pre>

<p>At line 1, we’re setting some style information on a DOM node that’s going to result in a reflow - but (at just line 1) it’s okay, because that reflow will happen after the style calculation.</p>

<p>Note line 2 though - we’re asking for the height of some DOM node. This means that Gecko needs to synchronously calculate layout (and styles) using an uninterruptible reflow in order to answer the question that JavaScript is asking (“What is the <code>clientHeight</code> of <code>div1</code>?”).</p>

<p>It’s possible for our example to avoid this synchronous, uninterruptible reflow by moving lines 2 and 4 above line 1. Assuming there weren’t any style changes requiring size or position recalculation above line 1, the <code>clientHeight</code> information should be cached since the last reflow, and will not result in a new layout calculation.</p>

<p>If you can avoid querying for the size or position of things in JavaScript, that’s the safest option—especially because it’s always possible that something earlier in this tick of JavaScript execution caused a style change in the DOM without you knowing it.</p>

<p>Note that given the same changes to the DOM of a chrome UI document, a single synchronous uninterruptible reflow is no more computationally expensive than an interruptible reflow triggered by the 16ms tick. It is, however, advantageous to strive for reflow to only occur in the one place (the layout step of the 16ms tick) as opposed to multiple times during the 16ms tick (which has a higher probability of running through the 16ms budget).</p>

<h3 id="How_do_I_avoid_triggering_uninterruptible_reflow">How do I avoid triggering uninterruptible reflow?</h3>

<p>Here's a <a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a">list of things that JavaScript can ask for that can cause uninterruptible reflow</a>, to help you think about the problem. Note that some items in the list may be browser-specific or subject to change, and that an item not occurring explicitly in the list doesn't mean it doesn't cause reflow. For instance, at time of writing accessing <code>event.rangeOffset</code> <a href="https://searchfox.org/mozilla-central/rev/6bfadf95b4a6aaa8bb3b2a166d6c3545983e179a/dom/events/UIEvent.cpp#215-226">triggers reflow</a> in Gecko, and does not occur in the earlier link. If you're unsure whether something causes reflow, check!</p>

<p>Note how abundant the properties in that first list are. This means that when enumerating properties on DOM objects (e.g. elements/nodes, events, windows, etc.) <strong>accessing the value of each enumerated property will almost certainly (accidentally) cause uninterruptible reflow</strong>, because a lot of DOM objects have one or even several properties that do so.</p>

<p>If you require size or position information, you have a few options.</p>

<p>{{bug(1434376)}} has recently landed a helper in the window binding to make it easier for priviledged code to queue up JavaScript to run when we know that the DOM is not dirty, and size, position, and style information is cheap to query for.</p>

<p>Here's an example:</p>

<pre class="brush: js">async function matchWidth(elem, otherElem) {
  let width = await window.promiseDocumentFlushed(() =&gt; {
    // Do _not_ under any circumstances write to the DOM in one of these
    // callbacks!
    return elem.clientWidth;
  });

  requestAnimationFrame(() =&gt; {
    otherElem.style.width = `${width}px`;
  });
}</pre>

<p>Please see the section on <code>promiseDocumentFlushed</code> in {{anch("Detecting and avoiding synchronous style flushes")}} for more information on how to use the API.</p>

<p>Note that queries for size and position information are only expensive if the DOM has been written to. Otherwise, we're doing a cheap look-up of cached information. If we work hard to move all DOM writes into <code>requestAnimationFrame()</code>, then we can be sure that all size and position queries are cheap.</p>

<p>It's also possible (though less infallible than <code>promiseDocumentFlushed</code>) to queue JavaScript to run very soon after the frame has been painted, where the likelihood is highest that the DOM has not been written to, and layout and style information queries are still cheap. This can be done by using a <code>setTimeout</code> or dispatching a runnable inside a <code>requestAnimationFrame</code> callback, for example:</p>

<pre class="brush: js">requestAnimationFrame(() =&gt; {
  setTimeout(() =&gt; {
    // This code will be run ASAP after Style and Layout information have
    // been calculated and the paint has occurred. Unless something else
    // has dirtied the DOM very early, querying for style and layout information
    // here should be cheap.
  }, 0);
});

// Or, if you are running in privileged JavaScript and want to avoid the timer overhead,
// you could also use:

requestAnimationFrame(() =&gt; {
  Services.tm.dispatchToMainThread(() =&gt; {
    // Same-ish as above.
  });
});</pre>

<div class="note">
<p>This also implies that<strong> </strong><em>querying for size and position information</em> in <code>requestAnimationFrame()</code> has a high probability of causing a synchronous reflow.</p>
</div>

<h3 id="Other_useful_methods">Other useful methods</h3>

<p>Below you'll find some suggestions for other methods which may come in handy when you need to do things without incurring synchronous reflow. These methods generally return the most-recently-calculated value for the requested value, which means the value may no longer be current, but may still be "close enough" for your needs. Unless you need precisely accurate information, they can be valuable tools in your performance toolbox.</p>

<h4 id="nsIDOMWindowUtils.getBoundsWithoutFlushing">nsIDOMWindowUtils.getBoundsWithoutFlushing()</h4>

<p><code>getBoundsWithoutFlushing()</code> does exactly what its name suggests: it allows you to get the bounds rectangle for a DOM node contained in a window without flushing layout. This means that the information you get is potentially out-of-date, but allows you to avoid a sync reflow. If you can make do with information that may not be quite current, this can be helpful.</p>

<h4 id="nsIDOMWindowUtils.getRootBounds">nsIDOMWindowUtils.getRootBounds()</h4>

<p>Like <code>getBoundsWithoutFlushing()</code>, <code>getRootBounds()</code> lets you get the dimensions of the window without risking a synchronous reflow.</p>

<h4 id="nsIDOMWindowUtils.getScrollXY">nsIDOMWindowUtils.getScrollXY()</h4>

<p>Returns the window's scroll offsets without taking the chance of causing a sync reflow.</p>

<h3 id="Writing_tests_to_ensure_you_don’t_add_more_unintentional_reflow">Writing tests to ensure you don’t add more unintentional reflow</h3>

<p>The interface {{source("docshell/base/nsIReflowObserver.idl", "nsIReflowObserver")}} lets us detect both interruptible and uninterruptible reflows. A number of tests have been written that exercise various functions of the browser (<a href="http://searchfox.org/mozilla-central/rev/78cefe75fb43195e7f5aee1d8042b8d8fc79fc70/browser/base/content/test/general/browser_tabopen_reflows.js">opening tabs</a>, <a href="http://searchfox.org/mozilla-central/source/browser/base/content/test/general/browser_windowopen_reflows.js">opening windows</a>) and ensure that we don’t add new uninterruptible reflows accidentally while those actions occur.</p>

<p>You should add tests like this for your feature if you happen to be touching the DOM.</p>

<h3 id="Detecting_over-painting_with_paint_flashing">Detecting over-painting with paint flashing</h3>

<p>Painting is, in general, cheaper than both style calculation and layout calculation; still, the more you can avoid, the better. Generally speaking, the larger an area that needs to be repainted, the longer it takes. Similarly, the more things that need to be repainted, the longer it takes.</p>

<p>Our graphics team has added a handy feature to help you detect when and where paints are occurring. This feature is called “paint flashing,” and it can be activated for both web content and the browser chrome. Paint flashing tints each region being painted with a randomly selected color so that it’s more easy to see what on the screen is being painted.</p>

<ul>
 <li>You can activate paint flashing for browser chrome by setting <code>nglayout.debug.paint_flashing_chrome</code> to <code>true</code>.</li>
 <li>You can activate paint flashing for web content by setting <code>nglayout.debug.paint_flashing</code> to <code>true</code>.</li>
</ul>

<p>After enabling these, exercise your function and see what’s painting. See a lot of flashing / colors? That means a lot of painting is going on. The worst case is called <strong>over-painting</strong>. This is when you draw multiple times over the same space. Unless transparency is involved, all but the last painting will be overwritten, becoming unnecessary. If you can find ways to avoid doing this, you can save substantial time.</p>

<p>Keep in mind that painting occurs on the main thread. Remember, too, that the goal is to have as little happen on the main thread as possible. That means that finding and removing (when possible) over-painting is a good place to start reducing your burden on the main thread, which will in turn improve performance.</p>

<p>Perhaps you’re animating something that requires a repaint? For example, transitioning the {{cssxref("background-color")}} of a DOM node from red to blue will result in a repaint for every frame of the animation, and paint flashing will reveal that. Consider using a different animation that can be accelerated by the GPU. These GPU-accelerated animations occur off of the main thread, and have a much higher probability of running at 60 FPS (see the section below called {{anch("Use the compositor for animations")}} for further details).</p>

<p>Perhaps you’re touching some DOM nodes in such a way that unexpected repaints are occurring in an area that don’t need it. Best to investigate and try to remove those as best you can. Sometimes, our graphics layer invalidates regions in ways that might not be clear to you, and a section outside of the thing that just repainted will also repaint. Sometimes this can be addressed by ensuring that the thing changing is on its own layer (though this comes at a memory cost). You can put something on its own layer by setting its {{cssxref("z-index")}}, or by setting the {{cssxref("will-change")}} on the node, though this should be used sparingly.</p>

<p>If you’re unsure why something is repainting, consider talking to our always helpful graphics team in the <a href="https://chat.mozilla.org/#/room/#gfx:mozilla.org">gfx room</a> on <a href="https://wiki.mozilla.org/Matrix">Matrix</a>, and they can probably advise you. Note that a significant number of the graphics team members are in the US Eastern Time zone (UTC-5 or UTC-4 during Daylight Saving Time), so let that information guide your timing when you ask questions in the <a href="https://chat.mozilla.org/#/room/#gfx:mozilla.org">gfx room</a> .</p>

<h2 id="Adding_nodes_using_DocumentFragments">Adding nodes using DocumentFragments</h2>

<p>Sometimes you need to add several DOM nodes as part of an existing DOM tree. For example, when using XUL {{XULElem("menupopup")}}s, you often have script which dynamically inserts {{XULElem("menuitem")}}s. Inserting items into the DOM has a cost. If you're adding a number of children to a DOM node in a loop, it's often more efficient to batch them into a single insertion by creating a {{domxref("DocumentFragment")}}, adding the new nodes to that, then inserting the <code>DocumentFragment</code> as a child of the desired node.</p>

<p>A <code>DocumentFragment</code> is maintained in memory outside the DOM itself, so changes don't cause reflow. The API is straightforward:</p>

<ol>
 <li>Create the <code>DocumentFragment</code> by calling {{domxref("Document.createDocumentFragment()")}}.</li>
 <li>Create each child element (by calling {{domxref("Document.createElement()")}} for example), and add each one to the fragment by calling {{domxref("Node.appendChild", "DocumentFragment.appendChild()")}}.</li>
 <li>Once the fragment is populated, append the fragment to the DOM by calling {{domxref("Node.appendChild", "appendChild()")}} on the parent element for the new elements.</li>
</ol>

<p>This example has been cribbed from <a href="https://davidwalsh.name/documentfragment">davidwalsh’s blog post</a>:</p>

<pre class="brush: js">// Create the fragment

var frag = document.createDocumentFragment();

// Create numerous list items, add to fragment

for(var x = 0; x &lt; 10; x++) {
    var li = document.createElement("li");
    li.innerHTML = "List item " + x;
    frag.appendChild(li);
}

// Mass-add the fragment nodes to the list

listNode.appendChild(frag);
</pre>

<p>The above is strictly cheaper than individually adding each node to the DOM.</p>

<h2 id="The_Gecko_profiler_add-on_is_your_friend">The Gecko profiler add-on is your friend</h2>

<p>The Gecko profiler is your best friend when diagnosing performance problems and looking for bottlenecks. There’s plenty of excellent documentation on MDN about the Gecko profiler:</p>

<ul>
 <li><a href="/en-US/docs/Mozilla/Performance/Reporting_a_Performance_Problem">Basic instructions for gathering and sharing a performance profile</a></li>
 <li><a href="/en-US/docs/Mozilla/Performance/Profiling_with_the_Built-in_Profiler">Advanced profile analysis</a></li>
</ul>

<h2 id="Don’t_guess—measure.">Don’t guess—measure.</h2>

<p>If you’re working on a performance improvement, this should go without saying: ensure that what you care about is actually improving by measuring before and after.</p>

<p>Landing a speculative performance enhancement is the same thing as landing speculative bug fixes—these things need to be tested. Even if that means instrumenting a function with a {{jsxref("Date.now()")}} recording at the entrance, and another <code>Date.now()</code> at the exit points in order to measure processing time changes.</p>

<p>Prove to yourself that you’ve actually improved something by measuring before and after.</p>

<h3 id="Use_the_performance_API">Use the performance API</h3>

<p>The <a href="/en-US/docs/Web/API/Performance_API">performance API</a> is very useful for taking high-resolution measurements. This is usually much better than using your own hand-rolled timers to measure how long things take. You access the API through {{domxref("Window.performance")}}.</p>

<p>Also, the Gecko profiler back-end is in the process of being modified to expose things like markers (from {{domxref("Performance.mark", "window.performance.mark()")}}).</p>

<h2 id="Use_the_compositor_for_animations">Use the compositor for animations</h2>

<p>Performing animations on the main thread should be treated as <strong>deprecated</strong>. Avoid doing it. Instead, animate using {{domxref("Element.animate()")}}. See the article <a href="https://hacks.mozilla.org/2016/08/animating-like-you-just-dont-care-with-element-animate/">Animating like you just don't care</a> for more information on how to do this.</p>

<h2 id="Explicitly_define_start_and_end_animation_values">Explicitly define start and end animation values</h2>

<p>Some optimizations in the animation code of Gecko are based on an expectation that the <code>from</code> (0%) and the <code>to</code> (100%) values will be explicitly defined in the <code>@keyframes</code> definition. Even though these values may be inferred through the use of initial values or the cascade, the offscreen animation optimizations are dependent on the explicit definition. See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1419096#c18">this comment</a> and a few previous comments on that bug for more information.</p>

<h2 id="Use_IndexedDB_for_storage">Use IndexedDB for storage</h2>

<p><a href="en-US/docs/Web/HTML/Using_the_application_cache">AppCache</a> and <a href="/en-US/docs/Web/API/Storage/LocalStorage">LocalStorage</a> are synchronous storage APIs that will block the main thread when you use them. Avoid them at all costs!</p>

<p><a href="/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB">IndexedDB</a> is preferable, as the API is asynchronous (all disk operations occur off of the main thread), and can be accessed from web workers.</p>

<p>IndexedDB is also arguably better than storing and retrieving JSON from a file—particularly if the JSON encoding or decoding is occurring on the main thread. IndexedDB will do JavaScript object serialization and deserialization for you using the <a href="/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">structured clone algorithm</a>, meaning that you can stash <a href="/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#Supported_types">things like maps, sets, dates, blobs, and more</a>, without having to do conversions for JSON compatibility.</p>

<p>A Promise-based wrapper for IndexedDB, <a href="http://searchfox.org/mozilla-central/source/toolkit/modules/IndexedDB.jsm">IndexedDB.jsm</a>, is available for chrome code.</p>

<h2 id="Test_on_weak_hardware">Test on weak hardware</h2>

<p>For the folks paid to work on Firefox, we tend to have pretty powerful hardware for development. This is great, because it reduces build times, and means we can do our work faster.</p>

<p>We should remind ourselves that the majority of our user base is unlikely to have similar hardware. Look at the <a href="https://metrics.mozilla.com/firefox-hardware-survey/">Firefox Hardware Report</a> to get a sense of what our users are working with. Test on slower machines to make it more obvious to yourself if what you’ve written impacts the performance of the browser.</p>

<h2 id="Consider_loading_scripts_with_the_subscript_loader_asynchronously">Consider loading scripts with the subscript loader asynchronously</h2>

<p>If you've ever used the subscript loader, you might not know that it can load scripts asynchronously, and return a Promise once they're loaded. For example:</p>

<pre class="brush: js">Services.scriptloader.loadSubScriptWithOptions(myScriptURL, { async: true }).then(() =&gt; {
  console.log("Script at " + myScriptURL + " loaded asynchronously!");
});</pre>
