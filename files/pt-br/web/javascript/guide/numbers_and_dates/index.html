---
title: Números e datas
slug: Web/JavaScript/Guide/Numbers_and_dates
translation_of: Web/JavaScript/Guide/Numbers_and_dates
original_slug: Web/JavaScript/Guide/Numeros_e_datas
---
<div>{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Expressions_and_Operators", "Web/JavaScript/Guide/Text_formatting")}}</div>

<p class="summary">Este capítulo apresenta como utilizar números e datas em JavaScript.</p>

<h2 id="Números">Números</h2>

<p>Em Javascript, todos os números são implementados em <a class="external external-icon" href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">double-precision 64-bit binary format IEEE 754</a> (Por exemplo, um número entre -(2<sup>53</sup> -1) e 2<sup>53</sup> -1). <strong>Não havendo especificação de tipo Integer</strong>. Além de ser capaz de representar números de ponto flutuante, o tipo de número tem três valores simbólicos: <code>+</code>{{jsxref("Infinity")}}, <code>-</code>{{jsxref("Infinity")}}, and {{jsxref("NaN")}} (not-a-number).  Veja também <a href="/en-US/docs/Web/JavaScript/Data_structures">Estruturas e Tipos de Dados em Javascript</a> em contexto com outros tipos primitivos em JavaScript.</p>

<p>Você pode usar quatro tipos de números literais: decimal, binário, octal, e hexadecimal.</p>

<h3 id="Números_Decimais">Números Decimais</h3>

<pre class="brush: js notranslate">1234567890
42

// Cuidado quando usar zeros à esquerda:

0888 // 888 interpretado como decimal
0777 // interpretado como octal  em modo no-strict (511 em decimal)
</pre>

<p>Note que literais decimais podem começar com zero (<code>0</code>)  seguido por outro digito decimal, porém se o próximo dígito depois do primeiro zero for menor do que 8, o número será analisado como um número octal.</p>

<h3 id="Números_Binários">Números Binários</h3>

<p>A sintaxe para números Binários, usa um zero à esquerda seguido de uma letra minúscula ou maiúscula "B" (<code>0b</code> or <code>0B</code>). Se os dígitos depois de 0b não forem 0 ou 1, a seguinte exceção <code><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError">SyntaxError</a></code> é lançada: "Missing binary digits after 0b".</p>

<pre class="brush: js notranslate">var FLT_SIGNBIT  = 0b10000000000000000000000000000000; // 2147483648
var FLT_EXPONENT = 0b01111111100000000000000000000000; // 2139095040
var FLT_MANTISSA = 0B00000000011111111111111111111111; // 8388607</pre>

<h3 id="Números_octais">Números octais</h3>

<p>A sintaxe dos números octais usa um zero na frente. Se os dígitos depois do 0 estiverem fora do alcance 0 a 7, o número será interpretado como um número decimal.</p>

<pre class="brush: js notranslate">var n = 0755; // 493
var m = 0644; // 420
</pre>

<p>Modo estrito no ECMAScript 5 proíbe a sintaxe octal. A sintaxe Octal não é parte do ECMAScript 5, mas é suportada por todos os navegadores prefixando o número octal com zero: <code>0644 === 420</code> e <code>"\045" === "%"</code>. Em ECMAScript 6 números Octais são suportados prefixando o número com "<code>0</code>o" isto é.</p>

<pre class="brush: js notranslate">var a = 0o10; // ES6: Octal
</pre>

<h3 id="Numeros_hexadecimais">Numeros hexadecimais</h3>

<p>A sintaxe numérica Hexadecimal usa um 0 na frente seguido por uma letra "X" maiúscula ou minúscula (<code>0x</code> ou <code>0X)</code>. Se os dígidos depois do 0x estiverem fora do alcance (0123456789ABCDF), o seguinte erro de sintaxe (<code><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError">SyntaxError</a></code>) ocorrerá: "Identifier starts immediately after numeric literal" (O identificador começa imediatamente depois do literal numérico).</p>

<pre class="brush: js notranslate">0xFFFFFFFFFFFFFFFFF // 295147905179352830000
0x123456789ABCDEF   // 81985529216486900
0XA                 // 10
</pre>

<h3 id="Exponenciação">Exponenciação</h3>

<pre class="brush: js notranslate">1E3   // 1000
2e6   // 2000000
0.1e2 // 10</pre>

<h2 id="Objeto_Number"><code>Objeto Number</code></h2>

<p>Um objeto built-in {{jsxref("Number")}} tem propriedades para constantes numéricas, tais como valor máximo, não número e infinito. Você não pode alterar os valores dessas propriedades e elas são usadas assim:</p>

<pre class="brush: js notranslate">var maiorNum = Number.MAX_VALUE; //Valor máximo
var menorNum = Number.MIN_VALUE; //Valor mínimo
var infiniteNum = Number.POSITIVE_INFINITY; //Infinito positivo
var negInfiniteNum = Number.NEGATIVE_INFINITY; //Infinito negativo
var notANum = Number.NaN; //Não é numeral
</pre>

<p>Você sempre se refere a uma propriedade do objeto predefinido <code>Number</code> como mostrado acima, e não como uma propriedade de um objeto <code>Number que você mesmo criou.</code></p>

<p>A tabela à seguir sumariza as propriedades do objeto <code>Number.</code></p>

<table class="standard-table">
 <caption>Propriedades de <code>Number</code></caption>
 <thead>
  <tr>
   <th scope="col">Propriedade</th>
   <th scope="col">Descrição</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{jsxref("Number.MAX_VALUE")}}</td>
   <td>O maior número representável.</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.MIN_VALUE")}}</td>
   <td>O menor número representável.</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.NaN")}}</td>
   <td>Valor "not a number" especial</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.NEGATIVE_INFINITY")}}</td>
   <td>Valor especial infinito negativo; retornado em overflow</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.POSITIVE_INFINITY")}}</td>
   <td>Valor especial infinito positivo; retornado em overflow</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.EPSILON")}}</td>
   <td>Diferença entre um e o menor valor maior do que um que pode ser representado como um {{jsxref("Number")}}.</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.MIN_SAFE_INTEGER")}}</td>
   <td>Mínimo safe integer em JavaScript.</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.MAX_SAFE_INTEGER")}}</td>
   <td>Máximo safe integer em JavaScript.</td>
  </tr>
 </tbody>
</table>

<table class="standard-table">
 <caption>Métodos de <code>Number</code></caption>
 <thead>
  <tr>
   <th>Método</th>
   <th>Descrição</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{jsxref("Number.parseFloat()")}}</td>
   <td>Analisa um argumento string e retorna um número float.<br>
    O mesmo que a função global {{jsxref("parseFloat", "parseFloat()")}}.</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.parseInt()")}}</td>
   <td>Analisa um argumento string e retorna um inteiro da raiz ou base especificada.<br>
    O mesmo que a função global{{jsxref("parseInt", "parseInt()")}}.</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.isFinite()")}}</td>
   <td>Determina se o valor passado é um número finito.</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.isInteger()")}}</td>
   <td>Determina se o valor passado é um inteiro.</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.isNaN()")}}</td>
   <td>Determina se o valor passado é {{jsxref("Global_Objects/NaN", "NaN")}}. A versão mais robusta da original {{jsxref("Global_Objects/isNaN", "isNaN()")}}.</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.isSafeInteger()")}}</td>
   <td>Determina se o valor passado é um safe integer.</td>
  </tr>
 </tbody>
</table>

<p>O protótipo <code>Number</code> provê métodos para resgatar informações de objetos <code>Number </code>em vários formatos. A tabela a seguir sumariza os métodos de<code> Number.prototype</code>.</p>

<table class="standard-table">
 <caption>Métodos de <code>Number.prototype</code></caption>
 <thead>
  <tr>
   <th scope="col">Método</th>
   <th scope="col">Descrição</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{jsxref("Number.toExponential", "toExponential()")}}</td>
   <td>Retorna uma string representando o número em uma notação exponencial.</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.toFixed", "toFixed()")}}</td>
   <td>Retorna uma string representando o número em notação com ponto-fíxo.</td>
  </tr>
  <tr>
   <td>{{jsxref("Number.toPrecision", "toPrecision()")}}</td>
   <td>Retorna uma string representando o número em uma precisão especificada na notação de ponto-fíxo.</td>
  </tr>
 </tbody>
</table>

<h2 id="Objeto_Math"><code>Objeto Math</code></h2>

<p>O objeto {{jsxref("Math")}} tem propriedades e métodos para constantes matemáticas e funções. Por exemplo, o <code>PI do objeto</code> Math tem o valor de pi (3,141...), que você usaria em uma aplicação como</p>

<pre class="brush: js notranslate">Math.PI
</pre>

<p>Similarmente, funções matemáticas padrão são métodos do Math. Isto inclui funções trigonométricas, logarítmicas, exponenciais, e outras funções. Por exemplo, se você quiser usar a função trigonométrica seno, basta escrever</p>

<pre class="brush: js notranslate">Math.sin(1.56)
</pre>

<p>Note que todos os métodos trigonométricos pegam argumentos em radianos.</p>

<p>A tabela a seguir sumariza os métodos do objeto Math.</p>

<table class="standard-table">
 <caption><code>Métodos de Math</code></caption>
 <thead>
  <tr>
   <th scope="col">Método</th>
   <th scope="col">Descrição</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{jsxref("Math.abs", "abs()")}}</td>
   <td>Valor absoluto</td>
  </tr>
  <tr>
   <td>{{jsxref("Math.sin", "sin()")}}, {{jsxref("Math.cos", "cos()")}}, {{jsxref("Math.tan", "tan()")}}</td>
   <td>Funções trigonométricas padrão; Argumentos em radianos</td>
  </tr>
  <tr>
   <td>{{jsxref("Math.asin", "asin()")}}, {{jsxref("Math.acos", "acos()")}}, {{jsxref("Math.atan", "atan()")}}, {{jsxref("Math.atan2", "atan2()")}}</td>
   <td>Funções trigonométricas inversas; retorna valores em radianos</td>
  </tr>
  <tr>
   <td>{{jsxref("Math.sinh", "sinh()")}}, {{jsxref("Math.cosh", "cosh()")}}, {{jsxref("Math.tanh", "tanh()")}}</td>
   <td>Funções trigonométricas hiperbólicas; retorna valores em radianos.</td>
  </tr>
  <tr>
   <td>{{jsxref("Math.asinh", "asinh()")}}, {{jsxref("Math.acosh", "acosh()")}}, {{jsxref("Math.atanh", "atanh()")}}</td>
   <td>Funções trigonométricas hiperbólicas inversas; retorna valores em radianos.</td>
  </tr>
  <tr>
   <td>
    <p>{{jsxref("Math.pow", "pow()")}}, {{jsxref("Math.exp", "exp()")}}, {{jsxref("Math.expm1", "expm1()")}}, {{jsxref("Math.log10", "log10()")}}, {{jsxref("Math.log1p", "log1p()")}}, {{jsxref("Math.log2", "log2()")}}</p>
   </td>
   <td>Funções exponenciais e logarítmicas.</td>
  </tr>
  <tr>
   <td>{{jsxref("Math.floor", "floor()")}}, {{jsxref("Math.ceil", "ceil()")}}</td>
   <td>Retorna o maior/menor inteiro que é menor/maior inteiro que ou igual ao argumento.</td>
  </tr>
  <tr>
   <td>{{jsxref("Math.min", "min()")}}, {{jsxref("Math.max", "max()")}}</td>
   <td>Retorna menor ou maior (respectivamente) de uma lista separada por vírgula de argumentos numéricos</td>
  </tr>
  <tr>
   <td>{{jsxref("Math.random", "random()")}}</td>
   <td>Retorna um número aleatório entre 0 e 1.</td>
  </tr>
  <tr>
   <td>{{jsxref("Math.round", "round()")}}, {{jsxref("Math.fround", "fround()")}}, {{jsxref("Math.trunc", "trunc()")}},</td>
   <td>Funções de arredondamento e truncamento.</td>
  </tr>
  <tr>
   <td>{{jsxref("Math.sqrt", "sqrt()")}}, {{jsxref("Math.cbrt", "cbrt()")}}, {{jsxref("Math.hypot", "hypot()")}}</td>
   <td>Raiz quadrada, raiz cúbica, raiz quadrada da soma de argumentos ao quadrado.</td>
  </tr>
  <tr>
   <td>{{jsxref("Math.sign", "sign()")}}</td>
   <td>O sinal de um número, indicando se o número é positivo, negativo ou zero.</td>
  </tr>
  <tr>
   <td>{{jsxref("Math.clz32", "clz32()")}},<br>
    {{jsxref("Math.imul", "imul()")}}</td>
   <td>Número de zeros à esquerda na representação binária de 32-bits.<br>
    The result of the C-like 32-bit multiplication of the two arguments.</td>
  </tr>
 </tbody>
</table>

<p>Diferentemente de muitos outros objetos, você nunca cria um objeto Math por conta própria. Você sempre deve utilizar o objeto Math nativo.</p>

<h2 id="Objeto_Date"><code>Objeto Date</code></h2>

<p>JavaScript não possui dados do tipo data. No entanto, você pode usar o objeto {{jsxref("Date")}} e seus métodos para trabalhar com datas e horas nas suas aplicações. O objeto Date tem um grande número de métodos para setar, recuperar e manipular datas. Ele não tem nenhuma propriedade.</p>

<p>JavaScript manipula datas de maneira semelhante ao Java. As duas linguagens tem muitos dos mesmos métodos para lidar com datas e ambas armazenam datas como números em milisegundos, desde 1 de janeiro de 1970, às 00:00:00 ( January 1, 1970, 00:00:00).</p>

<p>A abrangência do objeto Date é de -100,000,000 dias até 100,000,000 dias relativos a 01 de janeiro de 1970 UTC.</p>

<p>Para criar um objeto Date:</p>

<pre class="brush: js notranslate">var dateObjectName = new Date([parameters]);
</pre>

<p>onde <code>dateObjectName </code>é o nome do objeto Date que está sendo criado; ele pode ser um novo objeto ou uma propriedade de um objeto existente.</p>

<p>A chamada de Date sem a palavra reservada <code>new</code>, simplesmente converte a data para uma representação dela como string.</p>

<p>Os <code>parâmetros </code>do código acima podem ser qualquer um a seguir:</p>

<ul>
 <li>Nada: cria a data e hora de hoje. Por exemplo, <code>today = new Date();.</code></li>
 <li>Uma string representando uma data da seguinte forma: "Mês dia, ano, horas:minutos:segundos". Por exemplo, <code>Xmas95 = new Date("25 de dezembro de 1995, 13:30:00")</code>. Se você omitir as horas, minutos ou segundos, o valor será setado para zero.</li>
 <li>Um conjunto de valores inteiros para ano, mês e dia. Por exemplo, <code>var Xmas95 = new Date(1995, 11, 25)</code>.</li>
 <li>Um conjunto de valores inteiros par ano, mês, dia, hora, minuto e segundos. Por exemplo, <code>var Xmas95 = new Date(1995, 11, 25, 9, 30, 0);</code>.</li>
</ul>

<h3 id="Métodos_do_objeto_Date">Métodos do objeto Date</h3>

<p>Os métodos do objeto Date para manipular data e hora pertencem às seguintes categorias:</p>

<ul>
 <li>Métodos "set", para setar valores de data e hora em objetos Date.</li>
 <li>Métodos "get", para recuperar valores de data e hora de objetos Date.</li>
 <li>Métodos "to", para retornar valores de string de objetos Date.</li>
 <li>Métodos parse e UTC, para parsear string de Data.</li>
</ul>

<p>Com os métods "get" e "set", você pode recuperar e setar segundos, minutos, horas, dia e mês, dia da semana, meses e anos, separadamente. Existe um método <code>getDay </code>que retorna o dia da semana, mas não existe um método <code>setDay </code>correspondente, porque o dia da semana é setado automaticamente. Estes métodos utilizam números inteiros para representar estes valores da seguinte maneira:</p>

<ul>
 <li>Segundos e minutos: de 0 a 59</li>
 <li>Horas: de 0 a 23</li>
 <li>Dia: 0 (Domingo) a 6 (Sábado)</li>
 <li>Data: 1 a 31 (dia do mês)</li>
 <li>Meses: 0 (Janeiro) a 11 (Dezembro)</li>
 <li>Ano: anos desde 1900</li>
</ul>

<p>Por exemplo, suponha que você queira definir a seguinite data:</p>

<pre class="brush: js notranslate">var Xmas95 = new Date("December 25, 1995");
</pre>

<p>Então <code>Xmas95.getMonth() </code>retorna 11<code> e Xmas95.getFullYear()</code> retorna 1995.</p>

<p>Os métodos <code>getTime</code> e <code>setTime </code>são úteis para comparar datas. O método <code>getTime</code> retorna o número dos milisegundos desde 1 de janeiro de 1970, às 00:00:00 para um objeto Date.</p>

<p>Por exemplo, o código a seguir mostra os números dos dias que ainda faltam do ano vigente:</p>

<pre class="brush: js notranslate">var hoje = new Date();
var fimAno = new Date(1995, 11, 31, 23, 59, 59, 999); // Seta dia e mês
fimAno.setFullYear(hoje.getFullYear()); // Seta o ano para esse ano
var msPorDia = 24 * 60 * 60 * 1000; // Quantidade de milisegundos por dia
var diasRestantes = (fimAno.getTime() - hoje.getTime()) / msPorDia;
var diasRestantes = Math.round(diasRestantes); //retorna os dias restantes no ano
</pre>

<p>Este exemplo cria um objeto Date chamado <code>hoje </code>que contém a data de hoje. Ele, então, cria o objeto Date chamado <code>fimAno </code>e seta o ano para o ano vigente. Então, usando o número de milisegundos por dia, ele computa o número de dias entre hoje e <code>fimAno, </code>usando <code>getTime </code>e arredondando os números de dias.</p>

<p>O método <code>parse </code>é útil para associar valores de strings de data para objetos Date existentes. Por exemplo, o código a seguir usa <code>parse</code> e <code>setTime</code> para associar um valor de data ao objeto <code>IPOdate:</code></p>

<pre class="brush: js notranslate">var IPOdate = new Date();
IPOdate.setTime(Date.parse("Aug 9, 1995"));
</pre>

<p>No exemplo a seguir, a função  <code>JSClock() </code>retorna o tempo no formato de um relógio digital.</p>

<pre class="brush: js notranslate">function JSClock() {
  var tempo = new Date();
  var hora = tempo.getHours();
  var minuto = tempo.getMinutes();
  var segundo = tempo.getSeconds();
  var temp = "" + ((hora &gt; 12) ? hora - 12 : hora);
  if (hora == 0)
    temp = "12";
  temp += ((minuto &lt; 10) ? ":0" : ":") + minuto;
  temp += ((segundo &lt; 10) ? ":0" : ":") + segundo;
  temp += (hora &gt;= 12) ? " P.M." : " A.M.";
  return temp;
}
</pre>

<p>A função <code>JSClock </code>primeiro cria um objeto new <code>Date </code>chamado tempo; já que nenhum argumento é passado, <code>tempo</code> é criado com data e hora atuais. Ela então chama os métodos <code>getHours</code>, <code>getMinutes</code> e <code>getSeconds </code>e associa o valor à hora, minuto e segundo atuais à hora, minuto e segundo.</p>

<p>As próximas quatro declarações constroem uma string baseada em time. A primeira declaração cria uma variável <code>temp</code>, associando um valor utilizando uma expressão condicional; se hora é maior que 12, (hora - 12), senão simplesmente hora, a não ser que hora seja 0 que, nesse caso, será 12.</p>

<p>A próxima declaração anexa um valor <code>minuto</code> a <code>temp</code>. Se o valor de minuto for menos que 10, a expressão condicional acrescenta uma string com um 0 na frente; senão ela acrescenta uma string com dois pontos. Então a declaração anexa um valor <code>segundo </code>a <code>temp</code> do mesmo jeito.</p>

<p>Finalmente, a expressão condicional anexa "P.M." a <code>temp</code> se <code>hora</code> for 12 ou maior; senão ela anexa "A.M." a <code>temp</code>.</p>

<p>{{PreviousNext("Web/JavaScript/Guide/Expressions_and_Operators", "Web/JavaScript/Guide/Text_formatting")}}</p>
