---
title: Detalhes do modelo de objeto
slug: conflicting/Web/JavaScript/Inheritance_and_the_prototype_chain
tags:
  - Entidade
  - Modelo
  - Objeto
  - Orientação á Objeto
translation_of: Web/JavaScript/Guide/Details_of_the_Object_Model
original_slug: Web/JavaScript/Guide/Details_of_the_Object_Model
---
<p class="summary"><span id="result_box" lang="pt"><span class="hps">JavaScript</span> <span class="hps">é uma linguagem</span> orientada a <span class="hps">objetos</span> <span class="hps">com base em</span> <span class="hps">protótipos,</span> <span class="hps">em vez de ser</span> <span class="hps">baseada em classes</span><span>.</span> <span class="hps">Devido a essa</span> <span class="hps">base diferente</span><span>, pode ser</span> <span class="hps">menos evidente </span><span class="hps">como</span> o <span class="hps">JavaScript</span> <span class="hps">permite criar</span> <span class="hps">hierarquias de</span> <span class="hps">objetos</span> <span class="hps">e</span> <span class="hps">ter</span> <span class="hps">herança de</span> <span class="hps">propriedades e seus valores</span><span>.</span> <span class="hps">Este capítulo</span> <span class="hps">tenta</span> <span class="hps">esclarecer essa situação.</span></span></p>

<div class="almost_half_cell" id="gt-res-content">
<div dir="ltr" style="zoom: 1;"><span id="result_box" lang="pt"><span class="hps">Este capítulo assume que</span> <span class="hps">você já está</span> <span class="hps">um pouco familiarizado com</span> <span class="hps">JavaScript</span> <span class="hps">e</span> <span class="alt-edited hps">que você já tenha usado</span> <span class="hps">funções JavaScript</span> <span class="hps">para criar </span></span><span id="result_box" lang="pt"><span class="hps">simples </span></span><span id="result_box" lang="pt"><span class="hps">objetos</span><span class="hps">.</span></span></div>

<div dir="ltr" style="zoom: 1;"></div>
</div>

<h2 id="Linguagens_baseada_em_classe_vs._baseada_em_protótipo">Linguagens baseada em classe vs. baseada em protótipo</h2>

<p><span id="result_box" lang="pt"><span class="hps">Linguagens orientadas a objetos</span> <span class="hps">baseadas em classe</span><span>, como</span> <span class="hps">Java</span> <span class="hps">e</span> <span class="hps">C</span> <span class="hps">+</span> <span class="hps">+</span><span>,</span> <span class="hps">são fundadas</span> <span class="hps">no conceito de</span> <span class="hps">duas entidades distintas</span><span>: classes</span> <span class="hps">e instâncias.</span></span></p>

<ul>
 <li><span lang="pt"><span class="hps">Uma </span><span class="hps">classe define</span> <span class="hps">todas as propriedades</span> <span class="hps">(considerando-se</span> <span class="hps">os métodos</span> <span class="hps">e campos em</span> <span class="hps">Java</span><span>,</span> <span class="hps">ou membros em</span> <span class="hps">C + +</span><span>, para ser</span> <span class="hps">propriedades)</span> <span class="hps">que caracterizam</span> <span class="hps">um determinado conjunto de</span> <span class="hps">objetos.</span> <span class="hps">Uma classe é</span> algo<span class="hps"> abstrato</span><span>, ao invés de</span> <span class="hps">qualquer membro</span> <span class="hps">particular do</span> <span class="hps">conjunto de objetos</span> <span class="hps">que descreve.</span> <span class="hps">Por exemplo,</span> <span class="hps">a classe <code>Employee</code></span><span class="hps"> poderia representar o</span> <span class="hps">conjunto de</span> <span class="hps">todos os funcionários.</span></span></li>
 <li><span id="result_box" lang="pt"><span class="alt-edited hps">Uma</span><em> </em><span class="alt-edited hps"><em>instância</em>,</span> <span class="alt-edited hps">por outro</span> <span class="hps">lado, é a</span> <span class="hps">instanciação de uma classe</span><span>, ou seja,</span> <span class="hps">um dos seus membros</span><span>.</span> <span class="hps">Por exemplo</span><span>, <code>Victoria</code></span> <span class="hps">poderia ser uma</span> <span class="hps">instância da classe</span> </span><code>Employee</code><span id="result_box" lang="pt"><span>, o que representa</span> <span class="hps">um indivíduo em particular</span> <span class="hps">como um empregado.</span> <span class="hps">Uma instância</span> <span class="hps">tem exatamente</span> <span class="hps">as propriedades de</span> <span class="hps">sua classe pai</span> <span class="atn hps">(</span><span>nem mais, nem</span> <span class="hps">menos).</span></span></li>
</ul>

<p><span id="result_box" lang="pt"><span class="alt-edited hps">Uma</span> <span class="hps">linguagem baseada em</span> <span class="hps">protótipo</span><span>, como</span> <span class="hps">JavaScript,</span> <span class="hps">não faz essa</span> <span class="hps">distinção</span><span>:</span> <span class="hps">ele simplesmente tem</span> <span class="hps">objetos.</span> <span class="hps">Uma</span> <span class="hps">linguagem baseada em</span> <span class="hps">protótipo</span> <span class="hps">tem a idéia </span><span class="alt-edited hps">de um <em>objeto</em></span><em> <span class="alt-edited hps">prototípico</span></em></span><span lang="pt"><span>, um objeto</span> <span class="hps">usado como um modelo</span> <span class="alt-edited hps">do qual</span> <span class="alt-edited hps">obtém as propriedades</span> <span class="hps">iniciais para</span> <span class="hps">um novo objeto.</span> <span class="hps">Qualquer objeto</span> <span class="hps">pode especificar</span> <span class="hps">suas próprias propriedades</span><span class="alt-edited">, quando você</span> <span class="alt-edited hps">o cria</span> <span class="hps">ou</span> <span class="hps">em tempo de execução</span><span>.</span> <span class="hps">Além disso, qualquer</span> <span class="hps">objeto</span> <span class="hps">pode ser associado</span> <span class="hps">como</span> <span class="alt-edited hps">um protótipo de </span><span class="alt-edited hps">outro objeto,</span> <span class="alt-edited hps">permitindo ao</span> <span class="hps">segundo objeto</span> <span class="alt-edited hps">compartilhar</span> <span class="hps">as propriedades</span> <span class="hps">do primeiro</span> <span class="hps">objeto</span><span>.</span></span></p>

<h3 id="Definindo_uma_classe">Definindo uma classe</h3>

<p>Em linguagens baseadas em classe, você define uma classe em uma <em>definição de classe</em> separada. Nessa definição, você pode especificar métodos especiais, chamados de <em>construtores</em>, para criar instâncias da classe. Um método <em>construtor</em> pode especificar valores iniciais para as propriedades da instância e executar outros processamentos apropriados no momento da criação. Você pode usar o operador <code>new</code>, em associação com o método construtor para criar instâncias de classe.</p>

<p>O JavaScript segue um modelo semelhante, mas não têm uma definição da classe separada do construtor. Em vez disso, você define uma função de construtor para criar objetos com um conjunto inicial particular de propriedades e valores. Qualquer função JavaScript pode ser usado como um construtor. Você pode usar o operador <code>new</code> com uma função de construtor para criar um novo objeto.</p>

<h3 id="Subclasses_e_herança">Subclasses e herança</h3>

<p>Em uma linguagem baseada em classe, você cria a hierárquia de classes através de sua definição. Em uma definição de classes,  você pode  especificar que a nova classe é uma <em>subclasse</em> de outra já existente. A subclasse herda todas as propriedades da  superclasse e pode adicionar novas propriedades ou modificar propriedades herdadas. Por exemplo, assuma que  a classe <code>Employee</code> tem somente duas propriedades <code>name</code> e <code>dept</code> , e <code>Manager</code> é uma subclasse of <code>Employee </code>que adiciona a propriedade <code>reports</code>. Neste caso, uma instância da classe <code>Manager</code>  terá todas as três propiedades: <code>name</code>, <code>dept</code>, and <code>reports</code>.</p>

<p>Em JavaScript, a herança é implementada associando um objeto prototípico a qualquer função de construtor. Então, você pode criar exatamente o mesmo exemplo: <code>Employee</code> — <code>Manager</code>, mas utilizando uma terminologia ligeramente diferente. Primeiro, define-se a função de construtor de  <code>Employee</code>, especificando as propriedades <code>name</code> e <code>dept</code>. Depois,  define-se a função de construtor de  <code>Manager</code>, especificando a propriedade <code>reports</code>. Finalmente, associa-se um objeto new <code>Employee</code>  como  <code>prototype</code> para a função de construtor <code>Manager</code>. Então, quando vocẽ criar um objeto new <code>Manager</code>, ele herdará as propriedades  <code>name</code> e <code>dept</code> do objeto <code>Employee</code>.</p>

<h3 id="Adicionando_e_removendo_propriedades">Adicionando e removendo propriedades</h3>

<p>Em uma linguagem baseada em classe, você normalmente cria uma classe em tempo de compilação e então vincula as instâncias da classe em tempo de compilação, ou tempo de execução. Você não pode alterar o número ou o tipo de propriedade de uma classe após definí-la. Em javaScript, no entanto, você pode adicionar ou remover propriedades de qualquer objeto. Se você adiciona uma propriedade a um objeto que é usado como o protótipo para um conjunto de objetos, os objetos no qual ele é protótipo herdarão as novas propriedades.</p>

<h3 id="Sumário_das_diferenças">Sumário das diferenças</h3>

<p>A tabela a seguir apresenta um breve resumo de algumas dessas diferenças. O restante deste capítulo descreve os detalhes do uso de construtores e protótipos JavaScript para criar uma hierarquia de objetos e compara isso à maneira como você faria em Java.</p>

<table class="fullwidth-table">
 <caption>Comparação de objetos do sistema baseados em classes (Java) e baseado em protótipo (JavaScript)</caption>
 <thead>
  <tr>
   <th scope="col"><strong>Baseados em classes (Java)</strong></th>
   <th scope="col"><strong>Baseados em protótipos (JavaScript)</strong></th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Classes e instancias são entidades distintas.</td>
   <td>Todos os objetos são instancias.</td>
  </tr>
  <tr>
   <td>Define uma classe com uma definição de classe; cria um objeto - como instância da classe - com o método constructor.</td>
   <td>Define e cria um conjunto de objetos com funções construtoras.</td>
  </tr>
  <tr>
   <td>Cria um único objeto com o operador <code>new</code>.</td>
   <td>Faz o mesmo.</td>
  </tr>
  <tr>
   <td>Constroi uma hierarquia de objetos usando definição de classe para definir subclasses de classes existentes.</td>
   <td>Constrói uma hierarquia de objetos, atribuindo um objeto como o protótipo associado com uma função de construtor.</td>
  </tr>
  <tr>
   <td>Herda propriedade seguindo a cadeia de classe.</td>
   <td>Herda propriedade seguindo a cadeia de protótipo.</td>
  </tr>
  <tr>
   <td>Definição de classe especifica todas as propriedades de todas as instâncias de uma classe. Não é possível adicionar propriedades dinamicamente em tempo de execução.</td>
   <td>Função construtor ou protótipo especifica um conjunto <em>inicial </em>de propriedades. Pode adicionar ou remover propriedades de forma dinâmica para objetos individuais ou para todo o conjunto de objetos.</td>
  </tr>
 </tbody>
</table>

<h2 id="O_exemplo_employee">O exemplo employee</h2>

<p>O restante deste capítulo usa a hierarquia employee como mostrado na figura abaixo. </p>

<div class="twocolumns">
<p>Uma simples hierarquia de objetos:</p>

<p><img alt="" src="https://mdn.mozillademos.org/files/3060/figure8.1.png"></p>

<ul>
 <li><code>Employee</code> tem a propriedade <code>name</code> (cujo valor padrão é uma string vazia) e <code>dept</code> (cujo valor padrão  e o "general").</li>
 <li><code>Manager</code> é baseado no <code>Employee</code>. É adicionada a propriedade <code>reports</code> (cujo valor padrão é um array vazio, planejado para ter um array do objeto <code>Employee como valor</code>).</li>
 <li><code>WorkerBee</code> também é baseado no  <code>Employee</code>. É adicionada  a propriedade <code>projects</code> (cujo valor padrão é um array vazio, pretende-se ter um array de strings como valor).</li>
 <li><code>SalesPerson</code> é baseado no <code>WorkerBee</code>. É adicionada a propriedade <code>quota</code> (cujo valor padrão é 100). E também controla a propriedade <code>dept</code>  com o valor "sales", indicando que todos os salespersons são o mesmo departamento.</li>
 <li><code>Engineer</code> é baseado no <code>WorkerBee</code>. É adicionada a propriedade <code>machine</code> (cujo valor padrão é uma string vazia) e também controla a propriedade <code>dept</code> com o valor "engineering".</li>
</ul>
</div>

<h2 id="Criando_a_hierarquia">Criando a hierarquia</h2>

<p>Há muitas formas de definir funções construtoras apropriadas para implementar a hierarquia <code>Employee</code>. Como escolher defini-las depende amplamente do que você quer ser capaz de fazer em sua aplicação.</p>

<p>Esta seção mostra definições simples de como trabalhar com heranças. Nestas definições, você não pode especificar nenhum valor de propriedade quando criar um objeto. O recém-criado objeto terá os valores padrão, que você poderá alterar mais tarde.</p>

<p>Na aplicação real, você poderia definir construtores que permitem que você forneça valores de propriedade no momento da criação do objeto (veja <a href="#Construtores_flexíveis">Construtores flexíveis</a> para saber mais). Por enquanto, estas simples definições demonstram como a herança ocorre.</p>

<p>As seguintes definições Java e JavaScript <code>Employee</code> são similares. A única diferença é que você precisa especificar o tipo de cada propriedade em Java, mas não em JavaScript (devido ao Java ser uma <a href="http://en.wikipedia.org/wiki/Strong_and_weak_typing">linguagem fortemente tipada</a> enquanto o JavaScript é linguagem fracamente tipada).</p>

<div class="twocolumns">
<h4 id="JavaScript">JavaScript</h4>

<pre class="brush: js notranslate">function Employee() {
  this.name = "";
  this.dept = "general";
}
</pre>

<h4 id="Java">Java</h4>

<pre class="brush: java notranslate">public class Employee {
   public String name = "";
   public String dept = "general";
}
</pre>
</div>

<p>As definições <code>Manager</code> e <code>WorkerBee</code> mostram a diferença na forma de especificar o próximo objeto mais alto na cadeia de herança. Em JavaScript, você adiciona uma instância prototípica como o valor da propriedade <code>prototype</code> da função construtora. Você pode fazer isso a qualquer momento depois de definir o construtor. Em Java, você especifica a superclasse dentro da classe definida. Você não pode alterar a superclasse fora da classe definida.</p>

<div class="twocolumns">
<h4 id="JavaScript_2">JavaScript</h4>

<pre class="brush: js notranslate">function Manager() {
  Employee.call(this);
  this.reports = [];
}
Manager.prototype = Object.create(Employee.prototype);

function WorkerBee() {
  Employee.call(this);
  this.projects = [];
}
WorkerBee.prototype = Object.create(Employee.prototype);
</pre>

<h4 id="Java_2">Java</h4>

<pre class="brush: java notranslate">public class Manager extends Employee {
   public Employee[] reports = new Employee[0];
}



public class WorkerBee extends Employee {
   public String[] projects = new String[0];
}


</pre>
</div>

<p>As definições <code>Engineer</code> e <code>SalesPerson</code> criam objetos que descendem de <code>WorkerBee</code> e consequentemente de <code>Employee</code>. Objetos destes tipos tem propriedades de todos os objetos acima de sua cadeia. Em adição, estas definições substituem o valor herdado da propriedade <code>dept</code> com novos valores específicos para esses objetos.</p>

<div class="twocolumns">
<h4 id="JavaScript_3">JavaScript</h4>

<pre class="brush: js notranslate">function SalesPerson() {
   WorkerBee.call(this);
   this.dept = "sales";
   this.quota = 100;
}
SalesPerson.prototype = Object.create(WorkerBee.prototype);

function Engineer() {
   WorkerBee.call(this);
   this.dept = "engineering";
   this.machine = "";
}
Engineer.prototype = Object.create(WorkerBee.prototype);
</pre>

<h4 id="Java_3">Java</h4>

<pre class="brush: java notranslate">public class SalesPerson extends WorkerBee {
   public double quota;
   public dept = "sales";
   public quota = 100.0;
}


public class Engineer extends WorkerBee {
   public String machine;
   public dept = "engineering";
   public machine = "";
}

</pre>
</div>

<p>Usando estas definições, você pode criar instâncias desses objetos que obterão valores padrão para suas propriedades. A próxima imagem mostra o uso destas definições JavaScript para criar novos objetos e mostrar os valores das propriedades dos novos objetos. </p>

<div class="note">
<p><strong>Note:</strong> O termo <em>instancia   </em>tem significado específicamente técnico em linguagens baseadas em classe. Nessas linguagens, uma instância é uma instanciação individual de uma classe e é fundamentalmente diferente de uma classe. Em JavaScript, "instância" não tem esse significado técnico porque JavaScript não tem essa diferença entre classes e instâncias. No entanto, falando sobre JavaScript, "instância" pode ser usada informalmente para significar um objeto criado usando uma função construtora particular. Então, neste exemplo, você pode informalmente dizer que <code><code>jane</code></code> é uma instância de <code><code>Engineer</code></code>. Similarmente, embora os termos <em><em>parent</em>, <em>child</em>, <em>ancestor</em></em>, e <em><em>descendant</em></em> não tenham significados formais em JavaScript; você pode usá-los informalmente para referir a objetos altos ou baixos na cadeia de protótipos.</p>
</div>

<h3 id="Criando_objetos_com_definições_simples">Criando objetos com definições simples</h3>

<div class="twocolumns">
<h4 id="Hierarquia_do_Objeto">Hierarquia do Objeto</h4>

<p>A hierarquia abaixo foi criada utilizando o código ao lado.</p>

<p><img src="https://mdn.mozillademos.org/files/10412/=figure8.3.png"></p>

<h4 id="Objetos_individuais_Jim_Sally_Mark_Fred_Jane_etc._Instancias_criadas_a_partir_do_construtor.">Objetos individuais = Jim, Sally, Mark, Fred, Jane, etc. "Instancias" criadas a partir do construtor.</h4>

<pre class="brush: js notranslate">var jim = new Employee;
// jim.name is ''
// jim.dept is 'general'

var sally = new Manager;
// sally.name is ''
// sally.dept is 'general'
// sally.reports is []

var mark = new WorkerBee;
// mark.name is ''
// mark.dept is 'general'
// mark.projects is []

var fred = new SalesPerson;
// fred.name is ''
// fred.dept is 'sales'
// fred.projects is []
// fred.quota is 100

var jane = new Engineer;
// jane.name is ''
// jane.dept is 'engineering'
// jane.projects is []
// jane.machine is ''
</pre>
</div>

<h2 id="Propriedades_do_Objeto">Propriedades do Objeto</h2>

<p>Esta seção discute como objetos herdam propriedades de outros objetos na cadeia de protótipos e o que acontece quando você adiciona uma propriedade em tempo de execução.</p>

<h3 id="Herdando_Propriedades">Herdando Propriedades</h3>

<p>Suponha que você criou o objeto <code>mark</code> como um <code>WorkerBee</code> com a seguinte declaração:</p>

<pre class="brush: js notranslate">var mark = new WorkerBee;
</pre>

<p>Quando o JavaScript vê o operador <code>new</code>, ele cria um novo objeto genérico e implicitamente define o valor da propriedade interna [[Protótipo]] para o valor de <code>WorkerBee.prototype</code> passando este novo objeto como o valor da palavra-chave <code>this</code> para a função construtora de <code>WorkerBee</code>. A propriedade interna [[__proto__]] determina a cadeia de protótipos usada para retornar os valores das propriedades. Uma vez que essas propriedades são definidas, o JavaScript retorna o novo objeto e a declaração de atribuição define a variável <code>mark</code> para este objeto.</p>

<p>Este processo não põe explicitamente valores no objeto <code>mark</code> (valores <em>locais</em>) para as propriedades que <code>mark</code> herdou da cadeia de protótipo. Quando você solicita o valor de uma propriedade, o JavaScript primeiro verifica se o valor existe nesse objeto. Caso exista, esse valor é retornado. Se o valor não existe localmente, JavaScript verifica a cadeia de protótipos (usando a propriedade  interna __proto__). Se um objeto na cadeia de protótipos possui um valor para a propriedade, este valor é retornado. Se nenhuma propriedade é encontrada, o Javascript avisa que o objeto não possui a propriedade. Deste modo, o objeto <code>mark</code> possui as seguintes propriedades e valores: </p>

<pre class="brush: js notranslate">mark.name = "";
mark.dept = "general";
mark.projects = [];
</pre>

<p>The <code>mark</code> object inherits values for the <code>name</code> and <code>dept</code> properties from the prototypical object in <code>mark.__proto__</code>. It is assigned a local value for the <code>projects</code> property by the <code>WorkerBee</code> constructor. This gives you inheritance of properties and their values in JavaScript. Some subtleties of this process are discussed in <a href="#Property_inheritance_revisited">Property inheritance revisited</a>.</p>

<p>Because these constructors do not let you supply instance-specific values, this information is generic. The property values are the default ones shared by all new objects created from <code>WorkerBee</code>. You can, of course, change the values of any of these properties. So, you could give specific information for <code>mark</code> as follows:</p>

<pre class="brush: js notranslate">mark.name = "Doe, Mark";
mark.dept = "admin";
mark.projects = ["navigator"];</pre>

<h3 id="Adding_properties">Adding properties</h3>

<p>In JavaScript, you can add properties to any object at run time. You are not constrained to use only the properties provided by the constructor function. To add a property that is specific to a single object, you assign a value to the object, as follows:</p>

<pre class="brush: js notranslate">mark.bonus = 3000;
</pre>

<p>Now, the <code>mark</code> object has a <code>bonus</code> property, but no other <code>WorkerBee</code> has this property.</p>

<p>If you add a new property to an object that is being used as the prototype for a constructor function, you add that property to all objects that inherit properties from the prototype. For example, you can add a <code>specialty</code> property to all employees with the following statement:</p>

<pre class="brush: js notranslate">Employee.prototype.specialty = "none";
</pre>

<p>As soon as JavaScript executes this statement, the <code>mark</code> object also has the <code>specialty</code> property with the value of <code>"none"</code>. The following figure shows the effect of adding this property to the <code>Employee</code> prototype and then overriding it for the <code>Engineer</code> prototype.</p>

<p><img alt="" class="internal" src="/@api/deki/files/4422/=figure8.4.png" style="height: 519px; width: 833px;"><br>
 <small><strong>Adding properties</strong></small></p>

<h2 id="More_flexible_constructors">More flexible constructors</h2>

<p>The constructor functions shown so far do not let you specify property values when you create an instance. As with Java, you can provide arguments to constructors to initialize property values for instances. The following figure shows one way to do this.</p>

<p><img alt="" class="internal" id="figure8.5" src="/@api/deki/files/4423/=figure8.5.png" style="height: 481px; width: 1012px;"><br>
 <small><strong>Specifying properties in a constructor, take 1</strong></small></p>

<p>The following table shows the Java and JavaScript definitions for these objects.</p>

<div class="twocolumns">
<h4 id="JavaScript_4">JavaScript</h4>

<h4 id="Java_4">Java</h4>
</div>

<div class="twocolumns">
<pre class="brush: js notranslate">function Employee (name, dept) {
  this.name = name || "";
  this.dept = dept || "general";
}
</pre>

<pre class="brush: java notranslate">public class Employee {
   public String name;
   public String dept;
   public Employee () {
      this("", "general");
   }
   public Employee (String name) {
      this(name, "general");
   }
   public Employee (String name, String dept) {
      this.name = name;
      this.dept = dept;
   }
}
</pre>
</div>

<div class="twocolumns">
<pre class="brush: js notranslate">function WorkerBee (projs) {

 this.projects = projs || [];
}
WorkerBee.prototype = new Employee;
</pre>

<pre class="brush: java notranslate">public class WorkerBee extends Employee {
   public String[] projects;
   public WorkerBee () {
      this(new String[0]);
   }
   public WorkerBee (String[] projs) {
      projects = projs;
   }
}
</pre>
</div>

<div class="twocolumns">
<pre class="brush: js notranslate">
function Engineer (mach) {
   this.dept = "engineering";
   this.machine = mach || "";
}
Engineer.prototype = new WorkerBee;
</pre>

<pre class="brush: java notranslate">public class Engineer extends WorkerBee {
   public String machine;
   public Engineer () {
      dept = "engineering";
      machine = "";
   }
   public Engineer (String mach) {
      dept = "engineering";
      machine = mach;
   }
}
</pre>
</div>

<p>These JavaScript definitions use a special idiom for setting default values:</p>

<pre class="brush: js notranslate">this.name = name || "";
</pre>

<p>The JavaScript logical OR operator (<code>||</code>) evaluates its first argument. If that argument converts to true, the operator returns it. Otherwise, the operator returns the value of the second argument. Therefore, this line of code tests to see if <code>name</code> has a useful value for the <code>name</code> property. If it does, it sets <code>this.name</code> to that value. Otherwise, it sets <code>this.name</code> to the empty string. This chapter uses this idiom for brevity; however, it can be puzzling at first glance.</p>

<div class="note">
<p><strong>Note:</strong> This may not work as expected if the constructor function is called with arguments which convert to <code><code>false</code></code> (like <code>0</code> (zero) and empty string (<code><code>""</code></code>). In this case the default value will be chosen.</p>
</div>

<p>With these definitions, when you create an instance of an object, you can specify values for the locally defined properties. You can use the following statement to create a new <code>Engineer</code>:</p>

<pre class="brush: js notranslate">var jane = new Engineer("belau");
</pre>

<p><code>Jane</code>'s properties are now:</p>

<pre class="brush: js notranslate">jane.name == "";
jane.dept == "engineering";
jane.projects == [];
jane.machine == "belau"
</pre>

<p>Notice that with these definitions, you cannot specify an initial value for an inherited property such as <code>name</code>. If you want to specify an initial value for inherited properties in JavaScript, you need to add more code to the constructor function.</p>

<p>So far, the constructor function has created a generic object and then specified local properties and values for the new object. You can have the constructor add more properties by directly calling the constructor function for an object higher in the prototype chain. The following figure shows these new definitions.</p>

<p><img alt="" class="internal" src="/@api/deki/files/4430/=figure8.6.png" style="height: 534px; width: 1063px;"><br>
 <small><strong>Specifying properties in a constructor, take 2</strong></small></p>

<p>Let's look at one of these definitions in detail. Here's the new definition for the <code>Engineer</code> constructor:</p>

<pre class="brush: js notranslate">function Engineer (name, projs, mach) {
  this.base = WorkerBee;
  this.base(name, "engineering", projs);
  this.machine = mach || "";
}
</pre>

<p>Suppose you create a new <code>Engineer</code> object as follows:</p>

<pre class="brush: js notranslate">var jane = new Engineer("Doe, Jane", ["navigator", "javascript"], "belau");
</pre>

<p>JavaScript follows these steps:</p>

<ol>
 <li>The <code>new</code> operator creates a generic object and sets its <code>__proto__</code> property to <code>Engineer.prototype</code>.</li>
 <li>The <code>new</code> operator passes the new object to the <code>Engineer</code> constructor as the value of the <code>this</code> keyword.</li>
 <li>The constructor creates a new property called <code>base</code> for that object and assigns the value of the <code>WorkerBee</code> constructor to the <code>base</code> property. This makes the <code>WorkerBee</code> constructor a method of the <code>Engineer</code> object.The name of the<code> base</code> property is not special. You can use any legal property name; <code>base</code> is simply evocative of its purpose.</li>
 <li>
  <p>The constructor calls the <code>base</code> method, passing as its arguments two of the arguments passed to the constructor (<code>"Doe, Jane"</code> and <code>["navigator", "javascript"]</code>) and also the string <code>"engineering"</code>. Explicitly using <code>"engineering"</code> in the constructor indicates that all <code>Engineer</code> objects have the same value for the inherited <code>dept</code> property, and this value overrides the value inherited from <code>Employee</code>.</p>
 </li>
 <li>Because <code>base</code> is a method of <code>Engineer</code>, within the call to <code>base</code>, JavaScript binds the <code>this</code> keyword to the object created in Step 1. Thus, the <code>WorkerBee</code> function in turn passes the <code>"Doe, Jane"</code> and <code>"engineering"</code> arguments to the <code>Employee</code> constructor function. Upon return from the <code>Employee</code> constructor function, the <code>WorkerBee</code> function uses the remaining argument to set the <code>projects</code> property.</li>
 <li>Upon return from the <code>base</code> method, the <code>Engineer</code> constructor initializes the object's <code>machine</code> property to <code>"belau"</code>.</li>
 <li>Upon return from the constructor, JavaScript assigns the new object to the <code>jane</code> variable.</li>
</ol>

<p>You might think that, having called the <code>WorkerBee</code> constructor from inside the <code>Engineer</code> constructor, you have set up inheritance appropriately for <code>Engineer</code> objects. This is not the case. Calling the <code>WorkerBee</code> constructor ensures that an <code>Engineer</code> object starts out with the properties specified in all constructor functions that are called. However, if you later add properties to the <code>Employee</code> or <code>WorkerBee</code> prototypes, those properties are not inherited by the <code>Engineer</code> object. For example, assume you have the following statements:</p>

<pre class="brush: js notranslate">function Engineer (name, projs, mach) {
  this.base = WorkerBee;
  this.base(name, "engineering", projs);
  this.machine = mach || "";
}
var jane = new Engineer("Doe, Jane", ["navigator", "javascript"], "belau");
Employee.prototype.specialty = "none";
</pre>

<p>The <code>jane</code> object does not inherit the <code>specialty</code> property. You still need to explicitly set up the prototype to ensure dynamic inheritance. Assume instead you have these statements:</p>

<pre class="brush: js notranslate">function Engineer (name, projs, mach) {
  this.base = WorkerBee;
  this.base(name, "engineering", projs);
  this.machine = mach || "";
}
Engineer.prototype = new WorkerBee;
var jane = new Engineer("Doe, Jane", ["navigator", "javascript"], "belau");
Employee.prototype.specialty = "none";
</pre>

<p>Now the value of the <code>jane</code> object's <code>specialty</code> property is "none".</p>

<p>Another way of inheriting is by using the <code><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" title="en-US/docs/JavaScript/Reference/Global Objects/Function/call">call()</a></code> / <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" title="en-US/docs/JavaScript/Reference/Global Objects/Function/apply"><code>apply()</code></a> methods. Below are equivalent:</p>

<div class="twocolumns">
<pre class="brush: js notranslate">function Engineer (name, projs, mach) {
  this.base = WorkerBee;
  this.base(name, "engineering", projs);
  this.machine = mach || "";
}
</pre>

<pre class="brush: js notranslate">function Engineer (name, projs, mach) {
  WorkerBee.call(this, name, "engineering", projs);
  this.machine = mach || "";
}
</pre>
</div>

<p>Using the javascript <code>call()</code> method makes a cleaner implementation because the <code>base</code> is not needed anymore.</p>

<h2 id="Property_inheritance_revisited">Property inheritance revisited</h2>

<p>The preceding sections described how JavaScript constructors and prototypes provide hierarchies and inheritance. This section discusses some subtleties that were not necessarily apparent in the earlier discussions.</p>

<h3 id="Local_versus_inherited_values">Local versus inherited values</h3>

<p>When you access an object property, JavaScript performs these steps, as described earlier in this chapter:</p>

<ol>
 <li>Check to see if the value exists locally. If it does, return that value.</li>
 <li>If there is not a local value, check the prototype chain (using the <code>__proto__</code> property).</li>
 <li>If an object in the prototype chain has a value for the specified property, return that value.</li>
 <li>If no such property is found, the object does not have the property.</li>
</ol>

<p>The outcome of these steps depends on how you define things along the way. The original example had these definitions:</p>

<pre class="brush: js notranslate">function Employee () {
  this.name = "";
  this.dept = "general";
}

function WorkerBee () {
  this.projects = [];
}
WorkerBee.prototype = new Employee;
</pre>

<p>With these definitions, suppose you create <code>amy</code> as an instance of <code>WorkerBee</code> with the following statement:</p>

<pre class="brush: js notranslate">var amy = new WorkerBee;
</pre>

<p>The <code>amy</code> object has one local property, <code>projects</code>. The values for the <code>name</code> and <code>dept</code> properties are not local to <code>amy</code> and so are gotten from the <code>amy</code> object's <code>__proto__</code> property. Thus, <code>amy</code> has these property values:</p>

<pre class="brush: js notranslate">amy.name == "";
amy.dept == "general";
amy.projects == [];
</pre>

<p>Now suppose you change the value of the <code>name</code> property in the prototype associated with <code>Employee</code>:</p>

<pre class="brush: js notranslate">Employee.prototype.name = "Unknown"
</pre>

<p>At first glance, you might expect that new value to propagate down to all the instances of <code>Employee</code>. However, it does not.</p>

<p>When you create <em>any</em> instance of the <code>Employee</code> object, that instance gets a local value for the <code>name</code> property (the empty string). This means that when you set the <code>WorkerBee</code> prototype by creating a new <code>Employee</code> object, <code>WorkerBee.prototype</code> has a local value for the <code>name</code> property. Therefore, when JavaScript looks up the <code>name</code> property of the <code>amy</code> object (an instance of <code>WorkerBee</code>), JavaScript finds the local value for that property in <code>WorkerBee.prototype</code>. It therefore does not look farther up the chain to <code>Employee.prototype</code>.</p>

<p>If you want to change the value of an object property at run time and have the new value be inherited by all descendants of the object, you cannot define the property in the object's constructor function. Instead, you add it to the constructor's associated prototype. For example, assume you change the preceding code to the following:</p>

<pre class="brush: js notranslate">function Employee () {
  this.dept = "general";
}
Employee.prototype.name = "";

function WorkerBee () {
  this.projects = [];
}
WorkerBee.prototype = new Employee;

var amy = new WorkerBee;

Employee.prototype.name = "Unknown";
</pre>

<p>In this case, the <code>name</code> property of <code>amy</code> becomes "Unknown".</p>

<p>As these examples show, if you want to have default values for object properties and you want to be able to change the default values at run time, you should set the properties in the constructor's prototype, not in the constructor function itself.</p>

<h3 id="Determining_instance_relationships">Determining instance relationships</h3>

<p>Property lookup in JavaScript looks within an object's own properties and, if the property name is not found, it looks within the special object property <code>__proto__</code>. This continues recursively; the process is called "lookup in the prototype chain".</p>

<p>The special property <code>__proto__</code> is set when an object is constructed; it is set to the value of the constructor's <code>prototype</code> property. So the expression <code>new Foo()</code> creates an object with <code>__proto__ == <code class="moz-txt-verticalline">Foo.prototype</code></code>. Consequently, changes to the properties of <code class="moz-txt-verticalline">Foo.prototype</code> alters the property lookup for all objects that were created by <code>new Foo()</code>.</p>

<p>Every object has a <code>__proto__</code> object property (except <code>Object</code>); every function has a <code>prototype</code> object property. So objects can be related by 'prototype inheritance' to other objects. You can test for inheritance by comparing an object's <code>__proto__</code> to a function's <code>prototype</code> object. JavaScript provides a shortcut: the <code>instanceof</code> operator tests an object against a function and returns true if the object inherits from the function prototype. For example,</p>

<pre class="brush: js notranslate">var f = new Foo();
var isTrue = (f instanceof Foo);</pre>

<p>For a more detailed example, suppose you have the same set of definitions shown in <a href="#Inheriting_properties">Inheriting properties</a>. Create an <code>Engineer</code> object as follows:</p>

<pre class="brush: js notranslate">var chris = new Engineer("Pigman, Chris", ["jsd"], "fiji");
</pre>

<p>With this object, the following statements are all true:</p>

<pre class="brush: js notranslate">chris.__proto__ == Engineer.prototype;
chris.__proto__.__proto__ == WorkerBee.prototype;
chris.__proto__.__proto__.__proto__ == Employee.prototype;
chris.__proto__.__proto__.__proto__.__proto__ == Object.prototype;
chris.__proto__.__proto__.__proto__.__proto__.__proto__ == null;
</pre>

<p>Given this, you could write an <code>instanceOf</code> function as follows:</p>

<pre class="brush: js notranslate">function instanceOf(object, constructor) {
   object = object.__proto__;
   while (object != null) {
      if (object == constructor.prototype)
         return true;
      if (typeof object == 'xml') {
        return constructor.prototype == XML.prototype;
      }
      object = object.__proto__;
   }
   return false;
}
</pre>

<div class="note"><strong>Note:</strong> The implementation above checks the type of the object against "xml" in order to work around a quirk of how XML objects are represented in recent versions of JavaScript. See {{ bug(634150) }} if you want the nitty-gritty details.</div>

<p class="note">Using the <code>instanceOf</code> function defined above, these expressions are true:</p>

<pre class="brush: js notranslate">instanceOf (chris, Engineer)
instanceOf (chris, WorkerBee)
instanceOf (chris, Employee)
instanceOf (chris, Object)
</pre>

<p>But the following expression is false:</p>

<pre class="brush: js notranslate">instanceOf (chris, SalesPerson)
</pre>

<h3 id="Global_information_in_constructors">Global information in constructors</h3>

<p>When you create constructors, you need to be careful if you set global information in the constructor. For example, assume that you want a unique ID to be automatically assigned to each new employee. You could use the following definition for <code>Employee</code>:</p>

<pre class="brush: js notranslate">var idCounter = 1;

function Employee (name, dept) {
   this.name = name || "";
   this.dept = dept || "general";
   this.id = idCounter++;
}
</pre>

<p>With this definition, when you create a new <code>Employee</code>, the constructor assigns it the next ID in sequence and then increments the global ID counter. So, if your next statement is the following, <code>victoria.id</code> is 1 and <code>harry.id</code> is 2:</p>

<pre class="brush: js notranslate">var victoria = new Employee("Pigbert, Victoria", "pubs")
var harry = new Employee("Tschopik, Harry", "sales")
</pre>

<p>At first glance that seems fine. However, <code>idCounter</code> gets incremented every time an <code>Employee</code> object is created, for whatever purpose. If you create the entire <code>Employee</code> hierarchy shown in this chapter, the <code>Employee</code> constructor is called every time you set up a prototype. Suppose you have the following code:</p>

<pre class="brush: js notranslate">var idCounter = 1;

function Employee (name, dept) {
   this.name = name || "";
   this.dept = dept || "general";
   this.id = idCounter++;
}

function Manager (name, dept, reports) {...}
Manager.prototype = new Employee;

function WorkerBee (name, dept, projs) {...}
WorkerBee.prototype = new Employee;

function Engineer (name, projs, mach) {...}
Engineer.prototype = new WorkerBee;

function SalesPerson (name, projs, quota) {...}
SalesPerson.prototype = new WorkerBee;

var mac = new Engineer("Wood, Mac");
</pre>

<p>Further assume that the definitions omitted here have the <code>base</code> property and call the constructor above them in the prototype chain. In this case, by the time the <code>mac</code> object is created, <code>mac.id</code> is 5.</p>

<p>Depending on the application, it may or may not matter that the counter has been incremented these extra times. If you care about the exact value of this counter, one possible solution involves instead using the following constructor:</p>

<pre class="brush: js notranslate">function Employee (name, dept) {
   this.name = name || "";
   this.dept = dept || "general";
   if (name)
      this.id = idCounter++;
}
</pre>

<p>When you create an instance of <code>Employee</code> to use as a prototype, you do not supply arguments to the constructor. Using this definition of the constructor, when you do not supply arguments, the constructor does not assign a value to the id and does not update the counter. Therefore, for an <code>Employee</code> to get an assigned id, you must specify a name for the employee. In this example, <code>mac.id</code> would be 1.</p>

<h3 id="No_multiple_inheritance">No multiple inheritance</h3>

<p>Some object-oriented languages allow multiple inheritance. That is, an object can inherit the properties and values from unrelated parent objects. JavaScript does not support multiple inheritance.</p>

<p>Inheritance of property values occurs at run time by JavaScript searching the prototype chain of an object to find a value. Because an object has a single associated prototype, JavaScript cannot dynamically inherit from more than one prototype chain.</p>

<p>In JavaScript, you can have a constructor function call more than one other constructor function within it. This gives the illusion of multiple inheritance. For example, consider the following statements:</p>

<pre class="brush: js notranslate">function Hobbyist (hobby) {
   this.hobby = hobby || "scuba";
}

function Engineer (name, projs, mach, hobby) {
   this.base1 = WorkerBee;
   this.base1(name, "engineering", projs);
   this.base2 = Hobbyist;
   this.base2(hobby);
   this.machine = mach || "";
}
Engineer.prototype = new WorkerBee;

var dennis = new Engineer("Doe, Dennis", ["collabra"], "hugo")
</pre>

<p>Further assume that the definition of <code>WorkerBee</code> is as used earlier in this chapter. In this case, the <code>dennis</code> object has these properties:</p>

<pre class="brush: js notranslate">dennis.name == "Doe, Dennis"
dennis.dept == "engineering"
dennis.projects == ["collabra"]
dennis.machine == "hugo"
dennis.hobby == "scuba"
</pre>

<p>So <code>dennis</code> does get the <code>hobby</code> property from the <code>Hobbyist</code> constructor. However, assume you then add a property to the <code>Hobbyist</code> constructor's prototype:</p>

<pre class="brush: js notranslate">Hobbyist.prototype.equipment = ["mask", "fins", "regulator", "bcd"]
</pre>

<p>The <code>dennis</code> object does not inherit this new property.</p>

<div>{{PreviousNext("Web/JavaScript/Guide/Working_with_Objects", "Web/JavaScript/Guide/Iterators_and_Generators")}}</div>
