---
title: undefined
slug: Web/JavaScript/Reference/Global_Objects/undefined
translation_of: Web/JavaScript/Reference/Global_Objects/undefined
---
<div>
<div>
<div>{{jsSidebar("Objects")}}</div>

<div>全局属性<code><strong>undefined</strong></code>表示原始值<code>{{Glossary("Undefined", "undefined")}}。</code>它是一个 JavaScript 的 {{Glossary("Primitive", "原始数据类型")}} 。</div>



<div>{{js_property_attributes(0,0,0)}}</div>



<div>
<div>{{EmbedInteractiveExample("pages/js/globalprops-undefined.html")}}</div>
</div>
</div>
</div>

<h2 id="Syntax">语法</h2>

<pre class="syntaxbox"><code>undefined </code></pre>

<h2 id="Description">描述</h2>

<p><code>undefined</code>是<em>全局对象</em>的一个属性。也就是说，它是全局作用域的一个变量。<code>undefined</code>的最初值就是原始数据类型<code>{{Glossary("Undefined", "undefined")}}</code>。</p>

<p>在现代浏览器（JavaScript 1.8.5/Firefox 4+），自 ECMAscript5 标准以来 undefined 是一个不能被配置（non-configurable），不能被重写（non-writable）的属性。即便事实并非如此，也要避免去重写它。</p>

<p>一个没有被赋值的变量的类型是 undefined。如果方法或者是语句中<strong>操作的变量没有被赋值，则会返回 undefined</strong>（对于这句话持疑惑态度，请查看英文原文来理解）。</p>

<pre class="brush: js">function test(a){
    console.log(typeof a);    // undefined
    return a;
}

test();                       // 返回"undefined"</pre>

<p>一个函数如果没有使用 return 语句指定{{jsxref("Statements/return", "返回")}}值，就会返回一个 undefined 值。</p>

<div class="warning">
<p><strong>警告：</strong>但是它有可能在非全局作用域中被当作{{Glossary("Identifier", "标识符")}}（变量名）来使用 (因为 undefined 不是一个{{jsxref("Reserved_Words", "保留字")}}))，这样做是一个非常坏的主意，因为这样会使你的代码难以去维护和排错。</p>

<pre class="brush: js">// 不要这样做！

// 打印 'foo string' PS：说明 undefined 的值和类型都已经改变
(function() {
var undefined = 'foo';
console.log(undefined, typeof undefined)
})()

// 打印 'foo string' PS：说明 undefined 的值和类型都已经改变
(function(undefined) {
console.log(undefined, typeof undefined)
})('foo')

</pre>
</div>

<h2 id="示例">示例</h2>

<h3 id="严格相等和undefined">严格相等和 undefined</h3>

<p>你可以使用 undefined 和严格相等或不相等操作符来决定一个变量是否拥有值。在下面的代码中，变量 x 是未定义的，if 语句的求值结果将是 true</p>

<pre class="brush: js">var x;

if (x === undefined) {
// 执行这些语句
} else {
// 这些语句不会被执行
}</pre>

<div class="note">
<p><strong>备注：</strong>这里是必须使用严格相等操作符（===）而不是标准相等操作符（==），因为 x == undefined 会检查 x 是不是 null，但是严格相等不会检查（有点饶人，其实 === 会严格判断双方的类型、值等是否相等）。null 不等同于 undefined。移步{{jsxref("Operators/Comparison_Operators", "比较操作符")}}查看详情。</p>
</div>

<h3 id="Typeof_操作符和undefined">Typeof 操作符和 undefined</h3>

<p>或者，可以使用{{jsxref("Operators/typeof", "typeof")}}：</p>

<pre class="brush: js">var x;
if(typeof x === 'undefined') {
    // 执行这些语句
}</pre>

<p>使用 {{jsxref("Operators/typeof", "typeof")}}的原因是它不会在一个变量没有被声明的时候抛出一个错误。</p>

<pre class="brush: js">// 这里没有声明 y
if(typeof y === 'undefined') {       // 没有错误，执行结果为 true
   console.log("y is " + typeof y )  // y is undefined
}

if(y === undefined) {                // ReferenceError: y is not defined

}</pre>

<p>但是，技术方面看来这样的使用方法应该被避免。JavaScript 是一个静态作用域语言，所以，一个变量是否被声明可以通过看它是否在一个封闭的上下文中被声明。唯一的例外是全局作用域，但是全局作用域是被绑定在全局对象上的，所以要检查一个变量是否在全局上下文中存在可以通过检查全局对象上是否存在这个属性（比如使用{{jsxref("Operators/in", "in")}}操作符）。</p>

<pre class="brush: js">if ('x' in window) {
  // 只有 x 被全局性的定义 才会执行这些语句
}</pre>

<h3 id="Void操作符和undefined">Void 操作符和 undefined</h3>

<p>{{jsxref("Operators/void", "void")}} 操作符是第三种可以替代的方法。</p>

<pre class="brush: js">var x;
if(x === void 0) {
    // 执行这些语句
}

// 没有声明 y
if(y === void 0) {
    // 抛出一个 RenferenceError 错误 (与`typeof`相比)
}
</pre>

<h2 id="规范">规范</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-undefined', 'undefined')}}</td>
  </tr>
 </tbody>
</table>

<h2 id="浏览器兼容性">浏览器兼容性</h2>

<p>{{Compat("javascript.builtins.undefined")}}</p>
