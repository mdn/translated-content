---
title: ArrayBuffer.prototype.slice()
slug: Web/JavaScript/Reference/Global_Objects/ArrayBuffer/slice
translation_of: Web/JavaScript/Reference/Global_Objects/ArrayBuffer/slice
---
<div>{{JSRef}}</div>

<p><code><strong>slice()</strong></code>方法返回一个新的 <code>ArrayBuffer</code> ，它的内容是这个<code>ArrayBuffer的</code>字节副本，从begin（包括），到end（不包括）。</p>

<div>{{EmbedInteractiveExample("pages/js/arraybuffer-slice.html")}}</div>



<h2 id="语法">语法</h2>

<pre class="syntaxbox">arraybuffer.slice(begin[, end])</pre>

<h3 id="参数">参数</h3>

<dl>
 <dt><code>begin</code></dt>
 <dd>从零开始的字节索引，切片从这开始。</dd>
 <dt><code>end</code></dt>
 <dd>结束切片的字节索引。如果没指定end，新的 <code>ArrayBuffer</code> 将包含这个 <code>ArrayBuffer</code> 从头到尾的所有字节。由begin和end指定的这个范围夹在当前数组的有效索引范围内。如果新<code>ArrayBuffer</code>的长度在计算后为负，它将强制为0 。</dd>
</dl>

<h3 id="返回值">返回值</h3>

<p> 一个新的 <code>ArrayBuffer</code> 对象。</p>

<h2 id="描述">描述</h2>

<p><code>slice</code> 方法复制到但不包括由end参数指示的字节。如果begin或end是负数，则指的是从数组末尾开始的索引，而不是从头开始。</p>

<h2 id="示例">示例</h2>

<h3 id="复制一个_ArrayBuffer">复制一个 <code>ArrayBuffer</code></h3>

<pre class="brush: js">var buf1 = new ArrayBuffer(8);
var buf2 = buf1.slice(0);
</pre>

<h2 id="规范">规范</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
   <th scope="col">Status</th>
   <th scope="col">Comment</th>
  </tr>
  <tr>
   <td>{{SpecName('Typed Array')}}</td>
   <td>{{Spec2('Typed Array')}}</td>
   <td>Superseded by EMCAScript 6.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-arraybuffer.prototype.slice', 'ArrayBuffer.prototype.slice')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td>Initial definition in an ECMA standard.</td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-arraybuffer.prototype.slice', 'ArrayBuffer.prototype.slice')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td> </td>
  </tr>
 </tbody>
</table>

<h2 id="浏览器兼容性">浏览器兼容性</h2>



<p>{{Compat("javascript.builtins.ArrayBuffer.slice")}}</p>

<h2 id="相关链接">相关链接</h2>

<ul>
 <li>{{jsxref("ArrayBuffer")}}</li>
</ul>
