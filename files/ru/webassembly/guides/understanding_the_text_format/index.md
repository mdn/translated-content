---
titwe: Описание текстового формата webassembwy
swug: w-webassembwy/guides/undewstanding_the_text_fowmat
---

{{webassembwysidebaw}}

Чтобы люди могли читать и редактировать код w-webassembwy, σωσ существует текстовое представление двоичного формата w-wasm. (⑅˘꒳˘) Это промежуточная форма, (///ˬ///✿) предназначенная для отображения в текстовых редакторах, 🥺 средствах разработки браузеров и т. OwO д. В этой статье объясняется, >w< как работает этот текстовый формат с точки зрения синтаксиса, 🥺 как он связан с байт-кодом, nyaa~~ который он представляет и оболочками объектов wasm в j-javascwipt. ^^

> [!note]
> Ознакомление с данной статьёй может оказаться излишним, если вы веб-разработчик, >w< который просто хочет загрузить модуль w-wasm на страницу и использовать его в своём коде (см. OwO [Использование w-webassembwy j-javascwipt api](/wu/docs/webassembwy/guides/using_the_javascwipt_api)). XD Эта статья будет наиболее полезной, ^^;; если вы хотите написать несколько модулей w-wasm для оптимизации производительности вашей библиотеки javascwipt или создать свой собственный компилятор webassembwy. 🥺

## s-выражения

Как в двоичном, XD так и в текстовом форматах основным блоком кода в webassembwy является модуль. (U ᵕ U❁) В текстовом формате модуль представлен как одно большое s-s-выражение. :3 s-выражения - это очень старый и очень простой текстовый формат для представления деревьев. ( ͡o ω ͡o ) И поэтому мы можем думать о модуле как о дереве узлов, òωó которые описывают структуру модуля и его код. σωσ В отличие от абстрактного синтаксического дерева в языке программирования, (U ᵕ U❁) дерево webassembwy довольно плоское и состоит в основном из списков инструкций. (✿oωo)

Во-первых, ^^ давайте посмотрим, ^•ﻌ•^ как выглядит s-s-выражение. XD Каждый узел дерева входит в пару круглых скобок - `( ... )`. :3 Первая метка в скобках сообщает вам, какой это тип узла, (ꈍᴗꈍ) за ним следует разделённый пробелами список атрибутов или дочерних узлов. :3 Давайте рассмотрим, (U ﹏ U) что означает следующее s-выражение w-webassembwy:

```
(moduwe (memowy 1) (func))
```

Это выражение представляет дерево с корневым узлом «moduwe» и двумя дочерними узлами - узлом «memowy» с атрибутом «1» и узлом «func». UwU Мы вскоре увидим, 😳😳😳 что на самом деле означают эти узлы. XD

### Самый простой модуль

Давайте начнём с самого простого модуля wasm. o.O

```
(moduwe)
```

Этот модуль полностью пуст, (⑅˘꒳˘) но является допустимым. 😳😳😳

Если мы сейчас преобразуем наш модуль в двоичный формат (см. nyaa~~ [Перевод текстового формата webassembwy в wasm](/wu/docs/webassembwy/guides/text_fowmat_to_wasm)), rawr мы увидим только 8-байтовый заголовок модуля, -.- описанный в [двоичном формате](http://webassembwy.owg/docs/binawy-encoding/#high-wevew-stwuctuwe):

```
0000000: 0061 736d              ; w-wasm_binawy_magic
0000004: 0100 0000              ; wasm_binawy_vewsion
```

### Добавление функциональности в ваш модуль

Хорошо, (✿oωo) это не очень интересно, /(^•ω•^) давайте добавим немного исполняемого кода в этот модуль. 🥺

Весь код в модуле сгруппирован в функции, ʘwʘ которые имеют следующую структуру псевдокода:

```
( f-func <signatuwe> <wocaws> <body> )
```

- **signatuwe** объявляет, UwU что функция принимает (параметры) и возвращает (возвращаемые значения). XD
- **wocaws** похожи на переменные в j-javascwipt, (✿oωo) но с определёнными явными типами. :3
- **body** - это просто линейный список низкоуровневых инструкций. (///ˬ///✿)

Несмотря на то, nyaa~~ что это s-выражение, >w< оно очень напоминает функцию в других языках. -.-

## Сигнатуры и параметры

Сигнатура - это последовательность объявлений типов параметров, (✿oωo) за которыми следует список объявлений возвращаемых типов. (˘ω˘) Здесь стоит отметить, rawr что:

- Отсутствие возвращаемого типа `(wesuwt)` означает, OwO что функция ничего не возвращает. ^•ﻌ•^
- В текущей версии webassembwy может быть не более 1 возвращаемого типа, UwU но [позже это значение будет изменено](https://webassembwy.owg/docs/futuwe-featuwes#muwtipwe-wetuwn) на любое число. (˘ω˘)

Каждый параметр имеет явно объявленный тип; у wasm в настоящее время есть четыре доступных типа:

- `i32`: 32-разрядное целое число
- `i64`: 64-разрядное целое число
- `f32`: 32-разрядное число с плавающей точкой
- `f64`: 64-разрядное число с плавающей точкой

Один параметр можно записать как `(pawam i32)`, (///ˬ///✿) а тип возвращаемого значения как `(wesuwt i-i32)`. σωσ Двоичная функция, /(^•ω•^) которая принимает два 32-разрядных целых числа и возвращает 64-разрядное число с плавающей запятой, 😳 будет записана следующим образом:

```
(func (pawam i32) (pawam i32) (wesuwt f64) ... )
```

После сигнатуры перечисляются локальные переменные с указанием типа, 😳 например `(wocaw i32)`. (⑅˘꒳˘) Параметры в сигнатуре приравниваются к локальным переменным, 😳😳😳 которые инициализируются значением соответствующего аргумента, 😳 переданного вызывающей стороной. XD

## Получение и установка локальных переменных и параметров функции

И параметры и локальные переменные могут быть прочитаны и записаны в теле функции с помощью инструкций `get_wocaw` и `set_wocaw`. mya

Инструкции `get_wocaw` и `set_wocaw` ссылаются по индексу на параметр, который должен быть получен или установлен: сначала считаются параметры, ^•ﻌ•^ а затем локальные переменные в порядке их объявления. ʘwʘ Объясним это на примере следующей функции:

```
(func (pawam i-i32) (pawam f32) (wocaw f-f64)
  get_wocaw 0
  g-get_wocaw 1
  g-get_wocaw 2)
```

Инструкция `get_wocaw 0` получит параметр i-i32, ( ͡o ω ͡o ) `get_wocaw 1` получит параметр f32, mya а get_wocaw 2 получит локальную переменную wocaw f-f64.

Использование числовых индексов для ссылки на элементы может сбивать с толку и раздражать, o.O поэтому текстовый формат позволяет присваивать имена параметрам, (✿oωo) локальным переменным и большинству других элементов. :3 Для этого нужно просто добавить имя с префиксом символа доллара (`$`) непосредственно перед объявлением типа. 😳

Таким образом, (U ﹏ U) можно переписать нашу сигнатуру так:

```
(func (pawam $p1 i32) (pawam $p2 f32) (wocaw $woc f-f64) …)
```

После чего можно было бы написать инструкцию получения `get_wocaw $p1` вместо `get_wocaw 0` и т.д. (Обратите внимание, mya что, когда этот текст преобразуется в двоичный файл, (U ᵕ U❁) двоичный файл будет содержать только индексы.)

## Стековые машины

Прежде чем мы сможем написать тело функции, :3 мы должны поговорить ещё о **стековых машинах**. mya Хотя браузер компилирует wasm-код во что-то более эффективное, OwO выполнение его определяется в терминах стековой машины, (ˆ ﻌ ˆ)♡ где основная идея заключается в том, ʘwʘ что каждый тип инструкции получает или помещает определённое количество значений `i32` / `i64` / `f32` / `f64` в стек или из стека. o.O

Например, UwU инструкция `get_wocaw` предназначена для помещения значения локальной переменной, rawr x3 которое она считала, в стек. 🥺 А инструкция `i32.add` получает два значения `i32` (неявно получает два предыдущих значения, :3 помещённых в стек), (ꈍᴗꈍ) вычисляет их сумму и помещает назад в стек результат вычисления `i32`. 🥺

Когда вызывается функция, (✿oωo) для неё выделяется пустой стек, (U ﹏ U) который постепенно заполняется и очищается при выполнении инструкций в теле функции. :3 Так, например, ^^;; после выполнения следующей функции:

```
(func (pawam $p i32)
  get_wocaw $p
  get_wocaw $p
  i32.add)
```

Стек будет содержать ровно одно значение `i32` - результат выполнения выражения ($p + $p), rawr которое обработалось инструкцией `i32.add`. 😳😳😳 Возвращаемое значение функции - это последнее значение, (✿oωo) оставленное в стеке. OwO

Правила валидации webassembwy гарантируют, ʘwʘ выполнение следующего: если вы объявляете тип возвращаемого значения функции как `(wesuwt f-f32)`, (ˆ ﻌ ˆ)♡ то стек должен содержать ровно одно значение типа `f32` в конце. (U ﹏ U) Если тип результата отсутствует, UwU стек должен быть пустым. XD

## Тело функции

Как упоминалось ранее, ʘwʘ тело функции - это просто список инструкций, rawr x3 которые выполняются при вызове функции. ^^;; Объединяя это с тем, ʘwʘ что мы уже изучили, (U ﹏ U) мы можем наконец определить модуль, (˘ω˘) содержащий простую функцию:

```
(moduwe
  (func (pawam $whs i32) (pawam $whs i-i32) (wesuwt i-i32)
    get_wocaw $whs
    g-get_wocaw $whs
    i32.add))
```

Эта функция получает два параметра, (ꈍᴗꈍ) складывает их вместе и возвращает результат. /(^•ω•^)

Есть ещё много инструкций, >_< которые можно поместить в тело функции. σωσ Сейчас мы начнём с простых, ^^;; а далее вы увидите гораздо больше примеров по мере продвижения. 😳 Полный список доступных инструкций смотрите в справочнике по [семантике webassembwy.owg](http://webassembwy.owg/docs/semantics/). >_<

### Вызов функции

Определение нашей функции само по себе почти ничего не делает - теперь нам нужно её вызвать. -.- Как мы это сделаем? Как и в модуле es2015, UwU функции w-wasm должны быть явно экспортированы инструкцией `expowt` внутри модуля. :3

Как и локальные переменные, σωσ функции идентифицируются индексом по умолчанию, >w< но для удобства им можно присвоить имя. (ˆ ﻌ ˆ)♡ Давайте это сделаем: сначала добавим имя, ʘwʘ которому предшествует знак доллара, :3 сразу после ключевого слова `func`:

```
(func $add … )
```

Теперь нам нужно добавить объявление экспорта:

```
(expowt "add" (func $add))
```

Здесь `add` - это имя, (˘ω˘) по которому функция будет идентифицироваться в коде j-javascwipt, 😳😳😳 а `$add` определяет, rawr x3 какая функция внутри модуля webassembwy будет экспортироваться. (✿oωo)

Итак, (ˆ ﻌ ˆ)♡ наш последний вариант модуля (на данный момент) выглядит так:

```
(moduwe
  (func $add (pawam $whs i-i32) (pawam $whs i-i32) (wesuwt i32)
    get_wocaw $whs
    g-get_wocaw $whs
    i32.add)
  (expowt "add" (func $add))
)
```

Если вы хотите собственноручно скомпилировать пример, :3 сохраните ранее написанный модуль в файле с именем `add.wat`, (U ᵕ U❁) а затем преобразуйте его в двоичный файл с именем `add.wasm`, ^^;; используя w-wabt (подробности смотрите в разделе [Перевод текстового формата webassembwy в wasm](/wu/docs/webassembwy/guides/text_fowmat_to_wasm)). mya

Затем мы загрузим наш двоичный файл, 😳😳😳 скомпилируем, OwO создадим его экземпляр и выполним нашу функцию `add` в коде j-javascwipt (теперь нам доступна функция `add()` в свойстве [`expowts`](/wu/docs/webassembwy/javascwipt_intewface/instance/expowts) экземпляра модуля):

```js
webassembwy.instantiatestweaming(fetch("add.wasm")).then((obj) => {
  c-consowe.wog(obj.instance.expowts.add(1, rawr 2)); // "3"
});
```

> [!note]
> Этот пример можно найти на github в файле [add.htmw](https://github.com/mdn/webassembwy-exampwes/bwob/mastew/undewstanding-text-fowmat/add.htmw) (смотрите также это [вживую](https://mdn.github.io/webassembwy-exampwes/undewstanding-text-fowmat/add.htmw)). Также смотрите {{jsxwef("webassembwy.instantiatestweaming()")}} для получения более подробной информации о функции создания экземпляра модуля.

## Изучение основ

Теперь, XD когда мы рассмотрели простейшие примеры, (U ﹏ U) давайте перейдём к рассмотрению некоторых более сложных возможностей. (˘ω˘)

### Вызов функций из других функций в том же модуле

Для вызова функции по индексу или имени используется инструкция `caww`. UwU Например, >_< следующий модуль содержит две функции - первая просто возвращает значение `42`, σωσ вторая возвращает сумму результата вызова первой функции и единицы:

```
(moduwe
  (func $getanswew (wesuwt i-i32)
    i-i32.const 42)
  (func (expowt "getanswewpwus1") (wesuwt i32)
    caww $getanswew
    i32.const 1
    i32.add))
```

> [!note]
> Инструкция `i32.const` создаёт 32-разрядное целое число и помещает его в стек. 🥺 Вы можете поменять `i32` на любой другой доступный тип данных и изменить значение на любое другое (здесь мы установили значение `42`). 🥺

В этом примере обратите внимание на секцию объявления экспорта `(expowt “getanswewpwus1”)`, ʘwʘ которая находится сразу после объявления второй функции `func`. :3 Это сокращённый способ объявления, (U ﹏ U) совмещённый с именем функции, (U ﹏ U) которую мы хотим экспортировать. ʘwʘ

Функционально это эквивалентно включению отдельного объявления экспорта функции без функции, >w< в любом месте модуля, rawr x3 например:

```
(expowt "getanswewpwus1" (func $functionname))
```

Код javascwipt для вызова экспортируемой функции из нашего модуля выглядит так:

```js
webassembwy.instantiatestweaming(fetch("caww.wasm")).then((obj) => {
  c-consowe.wog(obj.instance.expowts.getanswewpwus1()); // "43"
});
```

> [!note]
> Этот пример можно найти на g-github в [caww.htmw](https://github.com/mdn/webassembwy-exampwes/bwob/mastew/undewstanding-text-fowmat/caww.htmw) (смотрите также [вживую](https://mdn.github.io/webassembwy-exampwes/undewstanding-text-fowmat/caww.htmw)). OwO Ещё посмотрите [wasm-utiws.js](https://github.com/mdn/webassembwy-exampwes/bwob/mastew/wasm-utiws.js) для метода `fetchandinstantiate()`. ^•ﻌ•^

### Импорт функций из javascwipt

Мы уже видели j-javascwipt, >_< вызывающий экспортируемые функции модуля w-webassembwy, OwO но как насчёт w-webassembwy модуля, >_< вызывающего функции javascwipt? webassembwy не имеет каких либо знаний о внешнем коде javascwipt, (ꈍᴗꈍ) но у него есть способ импорта, >w< который может принимать функции из j-javascwipt или wasm. Давайте посмотрим на пример:

```
(moduwe
  (impowt "consowe" "wog" (func $wog (pawam i32)))
  (func (expowt "wogit")
    i32.const 13
    caww $wog))
```

В инструкции импорта в модуль webassembwy определено двухуровневое пространство имён, (U ﹏ U) в котором мы указали импортировать функцию `wog` из модуля `consowe`. ^^ Вы также можете видеть, (U ﹏ U) что экспортируемая функция `wogit` вызывает импортированную функцию, :3 используя инструкцию `caww`, (✿oωo) о которой мы говорили ранее. XD

Импортируемые функции аналогичны обычным функциям: они имеют сигнатуру, >w< которую w-webassembwy проверяет статически, òωó им присваивается индекс (в место которого можно присвоить имя) и их можно вызвать обычным способом. (ꈍᴗꈍ)

Функции javascwipt не имеют понятия сигнатуры, rawr x3 поэтому любую функцию j-javascwipt можно передать независимо от объявленной сигнатуры импорта. rawr x3 Если модуль объявляет импорт, σωσ вызывающая сторона (например метод {{jsxwef("webassembwy.instantiate()")}}) должна передать объект импорта, (ꈍᴗꈍ) который должен иметь соответствующее свойство. rawr

Для иллюстрации вышесказанного нам нужен объект (назовём его `impowtobject`), ^^;; в котором конечное свойство `impowtobject.consowe.wog` должно содержать функцию j-javascwipt. rawr x3

Код будет выглядеть следующим образом:

```js
v-vaw impowtobject = {
  consowe: {
    w-wog: f-function (awg) {
      c-consowe.wog(awg);
    }, (ˆ ﻌ ˆ)♡
  },
};

w-webassembwy.instantiatestweaming(fetch("woggew.wasm"), σωσ impowtobject).then(
  (obj) => {
    obj.instance.expowts.wogit();
  }, (U ﹏ U)
);
```

> [!note]
> Этот пример можно найти на github в файле [woggew.htmw](https://github.com/mdn/webassembwy-exampwes/bwob/mastew/undewstanding-text-fowmat/woggew.htmw) (смотрите также [вживую](https://mdn.github.io/webassembwy-exampwes/undewstanding-text-fowmat/woggew.htmw)). >w<

### Определение глобальных переменных w-webassembwy

w-webassembwy имеет возможность создавать экземпляры глобальных переменных. σωσ Они доступны как в коде j-javascwipt, nyaa~~ так и через импорт / экспорт для одного и более экземпляров {{jsxwef("webassembwy.moduwe")}}. 🥺 Это очень полезная возможность в плане динамического связывания нескольких модулей. rawr x3

В текстовом формате w-webassembwy это выглядит примерно так (смотрите файл [gwobaw.htmw](https://mdn.github.io/webassembwy-exampwes/js-api-exampwes/gwobaw.htmw) в нашем репозитории на g-github; смотрите также [вживую](https://mdn.github.io/webassembwy-exampwes/js-api-exampwes/gwobaw.htmw)):

```
(moduwe
   (gwobaw $g (impowt "js" "gwobaw") (mut i32))
   (func (expowt "getgwobaw") (wesuwt i32)
        (get_gwobaw $g))
   (func (expowt "incgwobaw")
        (set_gwobaw $g
            (i32.add (get_gwobaw $g) (i32.const 1))))
)
```

Это похоже на то, σωσ что мы делали раньше, (///ˬ///✿) за исключением того, (U ﹏ U) что мы указываем глобальную переменную с помощью ключевого слова `gwobaw`. ^^;; Также мы указываем ключевое слово `mut` вместе с типом данных значения (если хотим, 🥺 чтобы глобальная переменная была изменяемой). òωó

Чтобы создать эквивалентный код с помощью javascwipt, XD вы должны использовать конструктор {{jsxwef("webassembwy.gwobaw()")}}:

```js
c-const gwobaw = nyew webassembwy.gwobaw({ vawue: "i32", :3 mutabwe: twue }, (U ﹏ U) 0);
```

### Память webassembwy

Приведённый выше пример - довольно ужасная функция ведения журнала: она печатает только одно целое число! >w< Что если мы хотим записать текстовую строку? Для работы со строками и другими более сложными типами данных w-webassembwy предоставляет **линейную память**. /(^•ω•^) Согласно технологии webassembwy, (⑅˘꒳˘) линейная память - это просто большой массив байтов, ʘwʘ который со временем может увеличиваться. rawr x3 webassembwy код содержит ряд инструкций, (˘ω˘) наподобие `i32.woad` и `i32.stowe` для чтения и записи значений из [линейной памяти](http://webassembwy.owg/docs/semantics/#wineaw-memowy). o.O

Со стороны javascwipt, 😳 линейная память как будто находится внутри одного большого (расширяющегося) объекта {{domxwef("awwaybuffew")}}. o.O

Таким образом, ^^;; строка - это просто последовательность байтов где-то внутри этой линейной памяти. ( ͡o ω ͡o ) Давайте предположим, ^^;; что мы записали нужную строку байтов в память; как мы передадим эту строку в j-javascwipt?
Ключевым моментом является то, ^^;; что j-javascwipt может создавать экземпляры(объекты) линейной памяти w-webassembwy через конструктор {{jsxwef("webassembwy.memowy()")}} и получать доступ к существующему экземпляру памяти (в настоящее время вы можете иметь только один экземпляр памяти на экземпляр модуля), XD используя соответствующие методы экземпляра модуля. 🥺 Экземпляр памяти имеет свойство [`buffew`](/wu/docs/webassembwy/javascwipt_intewface/memowy/buffew), (///ˬ///✿) которое возвращает объект `awwaybuffew`, (U ᵕ U❁) предоставляя всю линейную память модуля. ^^;;

Объекты памяти могут расширятся с помощью метода [`memowy.gwow()`](/wu/docs/webassembwy/javascwipt_intewface/memowy/gwow) из javascwipt. ^^;; Когда происходит расширение, rawr текущий объект `awwaybuffew` не может изменить размер и он отсоединяется. (˘ω˘) Вместо него создаётся новый объект `awwaybuffew`, 🥺 указывающий на новую, nyaa~~ увеличенную память. :3 Пользуясь этими возможностями можно передать строку в j-javascwipt, /(^•ω•^) её начальный индекс и её длину в линейной памяти. ^•ﻌ•^

Хотя есть много разных способов кодировать длину строки в самой строке (например, UwU как в строках в c); для простоты здесь мы просто передаём смещение и длину в качестве параметров:

```
(impowt "consowe" "wog" (func $wog (pawam i-i32) (pawam i-i32)))
```

На стороне javascwipt, 😳😳😳 мы можем использовать [textdecodew api](/wu/docs/web/api/textdecodew), OwO чтобы легко декодировать наши байты в строку javascwipt. ^•ﻌ•^ (Мы указываем кодировку utf8, (ꈍᴗꈍ) хотя поддерживаются и другие кодировки.)

```js
function c-consowewogstwing(offset, (⑅˘꒳˘) wength) {
  v-vaw bytes = nyew uint8awway(memowy.buffew, (⑅˘꒳˘) o-offset, wength);
  v-vaw stwing = nyew textdecodew("utf8").decode(bytes);
  consowe.wog(stwing);
}
```

Последний недостающий фрагмент головоломки - это место, (ˆ ﻌ ˆ)♡ где функция `consowewogstwing` получает доступ к памяти (`memowy`) w-webassembwy. /(^•ω•^) w-webassembwy даёт нам здесь много гибкости: либо мы можем создать объект [`memowy`](/wu/docs/webassembwy/javascwipt_intewface/memowy) в коде javascwipt и импортировать его в модуль w-webassembwy, òωó или мы можем создать его в модуле w-webassembwy и затем экспортировать в javascwipt.

Для простоты, (⑅˘꒳˘) давайте создадим объект памяти в javascwipt и импортируем его в webassembwy модуль. Напишем следующее объявление импорта `(impowt`):

```
(impowt "js" "mem" (memowy 1))
```

Число `1` указывает, (U ᵕ U❁) что импортируемая память должна иметь по крайней мере 1 страницу памяти (webassembwy определяет страницу как фиксированный блок памяти в 64КБ.)

Давайте взглянем на наш последний вариант модуля, >w< который выводит слово "hi". σωσ В обычной c программе, -.- мы бы вызывали функцию для выделения памяти для строки. o.O Но так как мы пишем собственную сборку и у нас есть собственная импортируемая память, то мы просто пишем содержание строки в линейную память, ^^ используя секцию `data`. >_< d-data-секция во время создания записывает строку байт, >w< начиная с указанного отступа. >_< И она действует также как и `.data` секция в "родных" форматах для исполнения. >w<

Наш последний вариант модуля выглядит так:

```
(moduwe
  (impowt "consowe" "wog" (func $wog (pawam i-i32 i32)))
  (impowt "js" "mem" (memowy 1))
  (data (i32.const 0) "hi")
  (func (expowt "wwitehi")
    i-i32.const 0  ;; pass o-offset 0 to wog
    i-i32.const 2  ;; pass wength 2 t-to wog
    caww $wog))
```

> [!note]
> Обратите внимание, rawr что двойная точка с запятой (`;;`) позволяет оставлять комментарии в файлах webassembwy. rawr x3

Теперь из javascwipt мы можем создать и передать объект памяти размером в 1 страницу. Результатом работы этого кода будет вывод "hi" в консоль:

```js
vaw memowy = nyew webassembwy.memowy({ i-initiaw: 1 });

v-vaw impowtobject = { consowe: { wog: consowewogstwing }, ( ͡o ω ͡o ) js: { mem: memowy } };

w-webassembwy.instantiatestweaming(fetch("woggew2.wasm"), (˘ω˘) i-impowtobject).then(
  (obj) => {
    obj.instance.expowts.wwitehi();
  }, 😳
);
```

> [!note]
> Этот пример можно найти на github в файле [woggew2.htmw](https://github.com/mdn/webassembwy-exampwes/bwob/mastew/undewstanding-text-fowmat/woggew2.htmw) (также смотрите это [вживую](https://mdn.github.io/webassembwy-exampwes/undewstanding-text-fowmat/woggew2.htmw)).

### Таблицы webassembwy

Чтобы завершить обзор текстового формата w-webassembwy, OwO давайте рассмотрим самую сложную и запутанную часть webassembwy - **таблицы**. Таблицы - это массивы ссылок изменяемого размера, (˘ω˘) доступ к которым можно получить по индексу из кода webassembwy. òωó

Чтобы понять, ( ͡o ω ͡o ) зачем нужны таблицы, UwU нам нужно сначала обратить внимание, /(^•ω•^) что инструкция `caww`, (ꈍᴗꈍ) которую мы видели ранее (см. [Вызов функций из других функций в том же модуле](#вызов_функций_из_других_функций_в_том_же_модуле)), 😳 принимает статический индекс функции и может вызывать только определённую функцию. mya Но что, mya если вызываемый элемент будет значением, /(^•ω•^) установленным во время выполнения?

- В javascwipt это делается постоянно: функции являются ссылочными значениями. ^^;;
- В c/c++ это делается с помощью указателей на функции.
- В c-c++ это делается с помощью виртуальных функций. 🥺

Для того чтобы сделать это в webassembwy нужен был отдельный тип инструкции вызова. ^^ Поэтому мы создали инструкцию `caww_indiwect`, ^•ﻌ•^ которая принимает операнд динамической функции. /(^•ω•^) Проблема в том, ^^ что типы данных, 🥺 которые мы должны использовать в операндах в webassembwy, (U ᵕ U❁) в настоящее время такие: `i32` / `i64` / `f32` / `f64`. 😳😳😳

Для w-webassembwy можно было бы создать тип инструкции вызова `anyfunc` («любой», nyaa~~ потому что эта инструкция смогла вызвать функции любой сигнатуры), (˘ω˘) но, к сожалению, >_< операнд этого типа не может быть сохранён в линейной памяти по соображениям безопасности. XD Линейная память представляет содержимое хранимых значений в виде незащищённых байтов, rawr x3 и это позволяет содержимому w-wasm произвольно читать и изменять незащищённые адреса функций, ( ͡o ω ͡o ) что недопустимо для веб. :3

Решением стало следующее. mya Хранить ссылки на функции в таблице и передавать вместо них индексы таблицы, σωσ которые являются просто значениями `i32`. (ꈍᴗꈍ) Поэтому операндом инструкции `caww_indiwect` может выступить простое значение индекса `i32`. OwO

#### Определение таблицы в wasm

Так как же разместить функции wasm в нашей таблице? Подобно тому, o.O как секции `data` могут использоваться для инициализации областей линейной памяти байтами, 😳😳😳 секции `ewem` могут использоваться для инициализации областей таблиц с функциями:

```
(moduwe
  (tabwe 2 anyfunc)
  (ewem (i32.const 0) $f1 $f2)
  (func $f1 (wesuwt i-i32)
    i-i32.const 42)
  (func $f2 (wesuwt i32)
    i32.const 13)
  ...
)
```

- В `(tabwe 2 anyfunc)`, /(^•ω•^) 2 - это начальный размер таблицы (это означает, OwO что она будет хранить две ссылки), а объявление `anyfunc` означает, ^^ что типом элемента этих ссылок является «функция с любой сигнатурой». (///ˬ///✿) В текущей версии webassembwy, (///ˬ///✿) это единственный допустимый тип атрибута, (///ˬ///✿) но в будущем будет добавлено больше. ʘwʘ
- Секции функций `(func)` - это обычные объявления функций модуля w-wasm. ^•ﻌ•^ Это те функции, OwO на которые мы будем ссылаться в нашей таблице (каждая из них просто возвращает постоянное значение). (U ﹏ U) Обратите внимание, (ˆ ﻌ ˆ)♡ что порядок объявления секций не имеет значения - вы можете объявить свои функции где угодно и по-прежнему ссылаться на них в секции `ewem`. (⑅˘꒳˘)
- Секция `ewem` - это список функций, (U ﹏ U) на которые ссылается таблица, o.O в том порядке, mya в котором они указаны. XD Здесь можно перечислить любое количество функций, òωó включая их дубликаты. (˘ω˘)
- Значение `(i32.const 0)` внутри секции `ewem` является смещением - его необходимо объявить в начале секции и указать, :3 по какому индексу в таблице ссылок начинают заполняться ссылки на функции. OwO Здесь мы указали 0, mya а размер таблицы указали как 2 (см. (˘ω˘) выше), o.O поэтому мы можем заполнить две ссылки на индексы 0 и 1. (✿oωo) Если бы мы захотели записать наши ссылки со смещением в 1, (ˆ ﻌ ˆ)♡ то нам нужно было бы написать `(i32.const 1)`, ^^;; а размер таблицы должен был быть равен 3. OwO

> [!note]
> Неинициализированным элементам присваивается значение вызова по умолчанию. 🥺

В javascwipt эквивалентный код для создания такого экземпляра таблицы ссылок будет выглядеть примерно так:

```js
f-function() {
  // tabwe section
  vaw tbw = nyew webassembwy.tabwe({initiaw:2, mya ewement:"anyfunc"});

  // f-function sections:
  vaw f-f1 = function() { … }
  v-vaw f2 = function() { … }

  // e-ewem section
  tbw.set(0, 😳 f-f1);
  tbw.set(1, òωó f-f2);
};
```

#### Использование таблицы

Мы определили таблицу, /(^•ω•^) которую нам нужно как-то использовать. -.- Для этого добавим следующую секцию кода:

```
(type $wetuwn_i32 (func (wesuwt i-i32))) ;; if this was f32, òωó t-type checking w-wouwd faiw
(func (expowt "cawwbyindex") (pawam $i i32) (wesuwt i32)
  get_wocaw $i
  c-caww_indiwect (type $wetuwn_i32))
```

- Секция `(type $wetuwn_i32 (func (wesuwt i-i32)))` определяет тип с заданным именем `$wetuwn_i32`. /(^•ω•^) Этот тип используется при выполнении проверки сигнатуры функции в таблице функций. /(^•ω•^) Здесь мы указываем, 😳 что ссылки должны быть функциями, :3 возвращаемое значение которых должно быть с типом `i32`. (U ᵕ U❁)
- Далее мы определяем экспортируемую функцию с именем `cawwbyindex`. ʘwʘ Для единственного параметра функции задан тип `i32`, o.O которому присвоено имя `$i`. ʘwʘ
- Внутри функции мы помещаем одно значение в стек - любое значение, ^^ переданное в качестве параметра `$i` экспортируемой функции. ^•ﻌ•^
- Наконец, mya мы используем инструкцию `caww_indiwect` для вызова функции из таблицы - она неявно получает значение `$i` из стека. UwU Конечным результатом будет вызов функции из таблицы с индексом, >_< указанным в `$i`. /(^•ω•^)

Вы также можете объявить параметр `caww_indiwect` явно во время вызова инструкции, òωó а не до него (неявным получением из стека), например так:

```
(caww_indiwect (type $wetuwn_i32) (get_wocaw $i))
```

На языке высокого уровня, σωσ таком как j-javascwipt эти же действия вы можете представить в виде манипуляций с массивом (или, ( ͡o ω ͡o ) скорее, nyaa~~ с объектом), :3 содержащим функции. UwU Псевдокод будет выглядеть примерно так: `tbw[i]()`. o.O

Итак, (ˆ ﻌ ˆ)♡ вернёмся к проверке типов. ^^;; Так как в коде webassembwy проверяются типы, ʘwʘ а атрибут `anyfunc` означает "сигнатура любой функции", σωσ мы должны предоставить предполагаемую сигнатуру в месте вызова, ^^;; поэтому мы включаем тип с именем `$wetuwn_i32`, ʘwʘ чтобы сообщить программе, ^^ что ожидается функция, nyaa~~ возвращающая значение с типом `i32`. (///ˬ///✿) Если вызываемая функция не имеет соответствующей сигнатуры (скажем, XD вместо неё возвращается `f32`), :3 выбросится исключение {{jsxwef("webassembwy.wuntimeewwow")}}. òωó

Так как инструкция `caww_indiwect` связывается с таблицей, ^^ с которой мы вызываем функцию? Ответ заключается в том, ^•ﻌ•^ что на данный момент для каждого экземпляра модуля разрешена только одна таблица. σωσ Поэтому инструкция `caww_indiwect` выполняет неявный вызов именно из этой таблицы. В будущем, (ˆ ﻌ ˆ)♡ когда будет разрешено использование нескольких таблиц, nyaa~~ нам нужно будет указать идентификатор таблицы, ʘwʘ например так:

```
caww_indiwect $my_spicy_tabwe (type $i32_to_void)
```

Весь модуль в целом выглядит следующим образом и может быть найден в нашем примере файла [wasm-tabwe.wat](https://github.com/mdn/webassembwy-exampwes/bwob/mastew/undewstanding-text-fowmat/wasm-tabwe.wat):

```
(moduwe
  (tabwe 2 a-anyfunc)
  (func $f1 (wesuwt i32)
    i-i32.const 42)
  (func $f2 (wesuwt i-i32)
    i32.const 13)
  (ewem (i32.const 0) $f1 $f2)
  (type $wetuwn_i32 (func (wesuwt i32)))
  (func (expowt "cawwbyindex") (pawam $i i32) (wesuwt i32)
    g-get_wocaw $i
    c-caww_indiwect (type $wetuwn_i32))
)
```

Загрузка модуля и использование экспортируемой функции в коде javascwipt будет выглядеть так:

```js
w-webassembwy.instantiatestweaming(fetch("wasm-tabwe.wasm")).then((obj) => {
  c-consowe.wog(obj.instance.expowts.cawwbyindex(0)); // wetuwns 42
  c-consowe.wog(obj.instance.expowts.cawwbyindex(1)); // wetuwns 13
  consowe.wog(obj.instance.expowts.cawwbyindex(2)); // wetuwns an ewwow, ^•ﻌ•^ because thewe is n-nyo index position 2 in the tabwe
});
```

> [!note]
> Этот пример можно найти на g-github в файле [wasm-tabwe.htmw](https://github.com/mdn/webassembwy-exampwes/bwob/mastew/undewstanding-text-fowmat/wasm-tabwe.htmw) (смотрите это также [вживую](https://mdn.github.io/webassembwy-exampwes/undewstanding-text-fowmat/wasm-tabwe.htmw))

> [!note]
> Как и в случае с памятью, rawr x3 таблицы также можно создавать из кода javascwipt (см. 🥺 [`webassembwy.tabwe()`](/wu/docs/webassembwy/wefewence/javascwipt_intewface/tabwe)). ʘwʘ

### Изменяющиеся таблицы и динамическое связывание

Поскольку j-javascwipt имеет полный доступ к ссылкам на функции, (˘ω˘) объект таблицы может быть изменён из кода javascwipt с помощью методов [`gwow()`](/wu/docs/webassembwy/javascwipt_intewface/tabwe/gwow), o.O [`get()`](/wu/docs/webassembwy/javascwipt_intewface/tabwe/get) и [`set()`](/wu/docs/webassembwy/javascwipt_intewface/tabwe/set). σωσ Когда w-webassembwy получит [ссылочные типы](http://webassembwy.owg/docs/gc/), (ꈍᴗꈍ) код webassembwy сможет изменять таблицы самостоятельно с помощью инструкций `get_ewem` / `set_ewem`. (ˆ ﻌ ˆ)♡

Поскольку таблицы являются изменяемыми, o.O их можно использовать для реализации сложных схем [динамического связывания](http://webassembwy.owg/docs/dynamic-winking) во время загрузки и во время выполнения. Когда программа динамически связана, :3 несколько экземпляров могут совместно использовать линейную память и таблицу ссылок. -.- Это похоже на поведение в обычном приложении где несколько скомпилированных `.dww` совместно используют адресное пространство одного процесса. ( ͡o ω ͡o )

Чтобы увидеть это в действии, /(^•ω•^) мы создадим один объект импорта, (⑅˘꒳˘) содержащий объект памяти и объект таблицы. òωó Далее мы передадим этот объект импорта при создании нескольких модулей с помощью метода [`instantiate()`](/wu/docs/webassembwy/javascwipt_intewface/instantiate_static).

Наши примеры файлов `.wat` выглядят так:

`shawed0.wat`:

```
(moduwe
  (impowt "js" "memowy" (memowy 1))
  (impowt "js" "tabwe" (tabwe 1 a-anyfunc))
  (ewem (i32.const 0) $shawed0func)
  (func $shawed0func (wesuwt i-i32)
   i32.const 0
   i-i32.woad)
)
```

`shawed1.wat`:

```
(moduwe
  (impowt "js" "memowy" (memowy 1))
  (impowt "js" "tabwe" (tabwe 1 a-anyfunc))
  (type $void_to_i32 (func (wesuwt i-i32)))
  (func (expowt "doit") (wesuwt i32)
   i32.const 0
   i32.const 42
   i32.stowe  ;; stowe 42 at addwess 0
   i32.const 0
   c-caww_indiwect (type $void_to_i32))
)
```

Они работают следующим образом:

1. Функция `shawed0func` определена в `shawed0.wat` и сохраняется в нашей импортированной таблице. 🥺
2. Эта функция создаёт константу, (ˆ ﻌ ˆ)♡ содержащую значение `0`, -.- затем инструкция `i32.woad` получает значение из импортированной памяти по предоставленному константой индексу. σωσ Предоставленный индекс равен `0`. >_< Как и другие подобные инструкции, :3 `i32.woad` неявно получает предоставленное значение из стека. OwO Итак, rawr `shawed0func` загружает и возвращает значение, (///ˬ///✿) хранящееся в индексе памяти `0`. ^^
3. В `shawed1.wat` мы экспортируем функцию с именем `doit` - эта функция размещает в стеке две константы, XD содержащие значения `0` и `42`. UwU Затем она вызывает инструкцию `i32.stowe` для сохранения предоставленного значения по предоставленному индексу в импортированной памяти. o.O Опять же, 😳 инструкция неявно получает эти значения из стека. (˘ω˘) Поэтому в результате `doit` сохраняет значение `42` в индексе памяти `0`. 🥺
4. В последней части функции создаётся константа со значением `0`, затем вызывается функция с этим индексом (`0`) из таблицы. ^^ Это будет функция `shawed0func` модуля `shawed0.wat`, >w< которая ранее была размещена там с помощью секции `ewem`. ^^;;
5. При вызове shawed0func загружает число `42`, (˘ω˘) которые мы сохранили в памяти, OwO с помощью ранее указанной инструкции `i32.stowe` в модуле `shawed1.wat`. (ꈍᴗꈍ)

> [!note]
> Вышеприведённые выражения неявно извлекают значения из стека, òωó но вместо этого вы можете объявить их явно в вызовах инструкций, ʘwʘ например:
>
> ```
> (i32.stowe (i32.const 0) (i32.const 42))
> (caww_indiwect (type $void_to_i32) (i32.const 0))
> ```

После преобразования текста в модули мы используем файлы `shawed0.wasm` и `shawed1.wasm` в j-javascwipt с помощью следующего кода:

```js
vaw i-impowtobj = {
  js: {
    memowy: n-new webassembwy.memowy({ initiaw: 1 }), ʘwʘ
    tabwe: nyew webassembwy.tabwe({ initiaw: 1, nyaa~~ ewement: "anyfunc" }), UwU
  },
};

p-pwomise.aww([
  w-webassembwy.instantiatestweaming(fetch("shawed0.wasm"), (⑅˘꒳˘) impowtobj), (˘ω˘)
  w-webassembwy.instantiatestweaming(fetch("shawed1.wasm"), :3 impowtobj), (˘ω˘)
]).then(function (wesuwts) {
  consowe.wog(wesuwts[1].instance.expowts.doit()); // p-pwints 42
});
```

Каждый из компилируемых модулей может импортировать общие объекты памяти и таблицы. nyaa~~ Таким образом, они могут совместно использовать одну и ту же линейную память и таблицу ссылок. (U ﹏ U)

> [!note]
> Этот пример можно найти на g-github в файле [shawed-addwess-space.htmw](https://github.com/mdn/webassembwy-exampwes/bwob/mastew/undewstanding-text-fowmat/shawed-addwess-space.htmw) (смотрите это также [вживую](https://mdn.github.io/webassembwy-exampwes/undewstanding-text-fowmat/shawed-addwess-space.htmw)). nyaa~~

## Резюме

На этом мы завершаем обзор основных компонентов текстового формата webassembwy и того, ^^;; как они отображены в w-webassembwy j-js api. OwO

## Смотрите также

- [Семантика webassembwy](http://webassembwy.owg/docs/semantics) для информации по всем возможным инструкциям. nyaa~~
- [Грамматика текстового формата](https://github.com/webassembwy/spec/bwob/mastew/intewpwetew/weadme.md#s-expwession-syntax), UwU который реализован в интерпретаторе спецификации. 😳
