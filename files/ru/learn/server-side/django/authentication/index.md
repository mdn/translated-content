---
title: "Руководство Django Часть 8: Аутентификация и авторизация пользователя"
slug: Learn/Server-side/Django/Authentication
---

{{LearnSidebar}}{{PreviousMenuNext("Learn/Server-side/Django/Sessions", "Learn/Server-side/Django/Forms", "Learn/Server-side/Django")}}

В данном руководстве мы продемонстрируем вам систему входа пользователя на ваш сайт используя его собственный аккаунт. Кроме того, мы покажем как реализовать контроль того, что может видеть и делать пользователь, в зависимости от того, залогинен он, или нет, а также имеет ли он соответствующий уровень прав доступа _(permissions)_. Для того чтобы продемонстрировать все это, мы расширим [LocalLibrary](/ru/docs/Learn/Server-side/Django/Tutorial_local_library_website), добавив страницы для входа/выхода, а также страницы просмотра/редактирования книг, специфические для пользователя и персонала.

| Требования: | Завершить изучение предыдущих тем руководства, включая [Руководство Django Часть 7: Работа с сессиями](/ru/docs/Learn/Server-side/Django/Sessions). |
| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| Цель:       | Понимать как настроить и использовать механизм аутентификации пользователя и разграничений прав доступа.                                            |

## Обзор

Django предоставляет систему аутентификации и авторизации ("permission") пользователя, реализованную на основе фреймворка работы с сессиями, который мы рассматривали в [предыдущей части](/ru/docs/Learn/Server-side/Django/Sessions). Система аутентификации и авторизации позволяет вам проверять учётные данные пользователей и определять какие действия какой пользователь может выполнять. Данный фреймворк включает в себя встроенные модели для `Пользователей` и `Групп` (основной способ применения прав доступа для более чем одного пользователя), непосредственно саму систему прав доступа (permissions)/флаги, которые определяют может ли пользователь выполнить задачу, с какой формой и отображением для авторизованных пользователей, а так же получить доступ к контенту с ограниченным доступом.

> [!NOTE]
> В соответствии с идеологией Django система аутентификации является очень общей и, таким образом, не предоставляет некоторые возможности, которые присутствуют в других системах веб-аутентификации. Решениями некоторых общих задач занимаются пакеты сторонних разработчиков, например, защита от подбора пароля (через стороннюю библиотеку OAuth).

В данном разделе руководства мы покажем вам реализацию аутентификации пользователя на сайте [LocalLibrary](/ru/docs/Learn/Server-side/Django/Tutorial_local_library_website), создание страниц входа/выхода, добавления разграничения доступа (permissions) к вашим моделям, а также продемонстрируем контроль за доступом к некоторым страницам. Мы будем использовать аутентификацию/авторизацию для показа пользователям и сотрудникам библиотеки, списков книг, которые были взяты на прокат.

Система аутентификации является очень гибкой и позволяет вам формировать свои собственные URL-адреса, формы, отображения, а также шаблоны страниц, если вы пожелаете, с нуля, через простой вызов функций соответствующего API для авторизации пользователя. Тем не менее, в данной статье мы будем использовать "встроенные" в Django методы отображений и форм аутентификации, а также методы построения страниц входа и выхода. Нам все ещё необходимо создавать шаблоны страниц, но это будет достаточно несложно.

Мы покажем вам как реализовать разграничение доступа (permissions), а также выполнять соответствующую проверку статусов авторизации и прав доступа, в отображениях, и в шаблонах страниц.

## Подключение аутентификации

Аутентификация была подключена автоматически когда мы создали [скелет сайта](/ru/docs/Learn/Server-side/Django/skeleton_website) (в части 2), таким образом на данный момент вам ничего не надо делать.

> [!NOTE]
> Необходимые настройки были выполнены для нас, когда мы создали приложение при помощи команды `django-admin startproject`. Таблицы базы данных для пользователей и модели авторизации были созданы, когда в первый раз выполнили команду `python manage.py migrate`.

Соответствующие настройки сделаны в параметрах `INSTALLED_APPS` и `MIDDLEWARE` файла проекта (**locallibrary/locallibrary/settings.py**), как показано ниже:

```python
INSTALLED_APPS = [
    ...
    'django.contrib.auth',  # Фреймворк аутентификации и моделей по умолчанию.
    'django.contrib.contenttypes',  # Django контент-типовая система (даёт разрешения, связанные с моделями).
    ....

MIDDLEWARE = [
    ...
    'django.contrib.sessions.middleware.SessionMiddleware',  # Управление сессиями между запросами
    ...
    'django.contrib.auth.middleware.AuthenticationMiddleware',  # Связывает пользователей, использующих сессии, запросами.
    ....
```

## Создание пользователей и групп

Вы уже создали своего первого пользователя когда мы рассматривали [Административная панель сайта Django](/ru/docs/Learn/Server-side/Django/Admin_site) в части 4 (это был суперпользователь, созданный при помощи команды `python manage.py createsuperuser`). Наш суперпользователь уже авторизован и имеет все необходимые уровни доступа к данным и функциям, таким образом нам необходимо создать тестового пользователя для отработки соответствующей работы сайта. В качестве наиболее быстрого способа, мы будем использовать административную панель сайта для создания соответствующих групп и аккаунтов _locallibrary_.

> [!NOTE]
> Вы можете создавать пользователей программно, как показано ниже. Например, вам мог бы подойти данный способ в том случае, если вы разрабатываете интерфейс, который позволяет пользователям создавать их собственные аккаунты (вы не должны предоставлять доступ пользователям к административной панели вашего сайта).
>
> ```python
> from django.contrib.auth.models import User
>
> # Создайте пользователя и сохраните его в базе данных
> user = User.objects.create_user('myusername', 'myemail@crazymail.com', 'mypassword')
>
> # Обновите поля и сохраните их снова
> user.first_name = 'John'
> user.last_name = 'Citizen'
> user.save()
> ```

Ниже мы создадим группу, а затем пользователя. Несмотря на то, что у нас пока нет никаких разрешений для добавления к нашей библиотеке каких-либо членов, если мы захотим это сделать в будущем, то будет намного проще добавлять их к уже созданной группе, с заданной аутентификацией.

Запустите сервер разработки и перейдите к административной панели вашего сайта (`http://127.0.0.1:8000/admin/`). Залогиньтесь на сайте при помощи параметров (имя пользователя и пароля) аккаунта суперпользователя. Самая "верхняя" страница панели Администратора показывает все наши модели. Для того, чтобы увидеть записи в разделе **Authentication and Authorisation** вы можете нажать на ссылку **Users**, или **Groups**.

![Admin site - add groups or users](admin_authentication_add.png)

В первую очередь, в качестве нового члена нашего сайта, давайте создадим новую группу.

1. Нажмите на кнопку **Add** **(Добавить)** (рядом с Group) и создайте новую _группу_; для данной группы введите **Name (Имя)** "Library Members".![Admin site - add group](admin_authentication_add_group.png)
2. Для данной группы не нужны какие-либо разрешения, поэтому мы просто нажимаем кнопку **SAVE (Сохранить)** (вы перейдёте к списку групп).

Теперь давайте создадим пользователя:

1. Перейдите обратно на домашнюю страницу административной панели
2. Для перехода к диалогу добавления пользователя нажмите на кнопку **Add**, соответствующую строке _Users (Пользователи)_.![Admin site - add user pt1](admin_authentication_add_user_prt1.png)
3. Введите соответствующие **Username** (имя пользователя) и **Password**/**Password confirmation (пароль/подтверждение пароля)** для вашего тестового пользователя
4. Нажмите **SAVE** для завершения процесса создания пользователя.

   Административная часть сайта создаст нового пользователя и немедленно перенаправит вас на страницу _Change user (Изменение параметров пользователя)_ где вы можете, соответственно, изменить ваш **username**, а кроме того добавить информацию для дополнительных полей модели User. Эти поля включают в себя имя пользователя, фамилию, адрес электронной почты, статус пользователя, а также соответствующие параметры доступа (может быть установлен только флаг **Active**). Ниже вы можете определить группу для пользователя и необходимые параметры доступа, а кроме того, вы можете увидеть важные даты, относящиеся к пользователю (дату подключения к сайту и дату последнего входа).![Admin site - add user pt2](admin_authentication_add_user_prt2.png)

5. В разделе _Groups_, из списка _Доступные группы_ выберите группу **Library Member**, а затем переместите её в блок "Выбранные группы" (нажмите **стрелку-"направо"**, находящуюся между блоками).![Admin site - add user to group](admin_authentication_user_add_group.png)
6. Больше нам не нужно здесь нечего делать, просто нажмите "Save"(Сохранить), и вы вернётесь к списку созданных пользователей.

Вот и все! Теперь у вас есть учётная запись «обычного члена библиотеки», которую вы сможете использовать для тестирования (как только добавим страницы, чтобы пользователи могли войти в систему).

> [!NOTE]
> Попробуйте создать другого пользователя, например "Библиотекаря". Так же создайте группу "Библиотекарей" и добавьте туда своего только что созданного библиотекаря

## Настройка представлений проверки

Django предоставляет почти все, что нужно для создания страниц аутентификации входа, выхода из системы и управления паролями из коробки. Это включает в себя url-адреса, представления (views) и формы,но не включает шаблоны — мы должны создать свой собственный шаблон!

В этом разделе мы покажем, как интегрировать систему по умолчанию в Сайт LocalLibrary и создать шаблоны. Мы поместим их в основные URL проекта.

> [!NOTE]
> Вы не должны использовать этот код, но вполне вероятно, что вы хотите, потому что это делает вещи намного проще. Вам почти наверняка потребуется изменить код обработки формы, если вы измените свою модель пользователя (сложная тема!) но даже в этом случае вы всё равно сможете использовать функции просмотра запасов.

> **Примечание:**В этом случае мы могли бы разумно поместить страницы аутентификации, включая URL-адреса и шаблоны, в наше приложение каталога. Однако, если бы у нас было несколько приложений, было бы лучше отделить это общее поведение входа в систему и иметь его доступным на всем сайте, так что это то, что мы показали здесь!

### Проектирование URLs

Добавьте следующее в нижней части проекта urls.py файл (**locallibrary/locallibrary/urls.py**) файл:

```python
#Add Django site authentication urls (for login, logout, password management)
urlpatterns += [
    path('accounts/', include('django.contrib.auth.urls')),
]
```

Перейдите по `http://127.0.0.1:8000/accounts/` URL (обратите внимание на косую черту!), Django покажет ошибку, что он не смог найти этот URL, и перечислить все URL, которые он пытался открыть. Из этого вы можете увидеть URL-адреса, которые будут работать, например:

> [!NOTE]
> Использование вышеуказанного метода добавляет следующие URL-адреса с именами в квадратных скобках, которые могут использоваться для изменения сопоставлений URL-адресов. Вам не нужно реализовывать что-либо ещё - приведённое выше сопоставление URL-адресов автоматически отображает указанные ниже URL-адреса.
>
> ```python
> accounts/ login/ [name='login']
> accounts/ logout/ [name='logout']
> accounts/ password_change/ [name='password_change']
> accounts/ password_change/done/ [name='password_change_done']
> accounts/ password_reset/ [name='password_reset']
> accounts/ password_reset/done/ [name='password_reset_done']
> accounts/ reset/<uidb64>/<token>/ [name='password_reset_confirm']
> accounts/ reset/done/ [name='password_reset_complete']
> ```

Теперь попробуйте перейти к URL-адресу входа (`http://127.0.0.1:8000/accounts/login/`). Это приведёт к сбою снова, но с ошибкой, сообщающей вам, что нам не хватает требуемого шаблона (registration / login.html) в пути поиска шаблона. Вы увидите следующие строки, перечисленные в жёлтом разделе вверху:

```python
Exception Type:    TemplateDoesNotExist
Exception Value:    registration/login.html
```

Следующий шаг - создать каталог регистрации в пути поиска, а затем добавить файл login.html.

### Каталог шаблонов

URL-адреса (и неявные представления), которые мы только что добавили, ожидают найти связанные с ними шаблоны в каталоге / регистрации / где-то в пути поиска шаблонов.

Для этого сайта мы разместим наши HTML-страницы в каталоге **templates / registration /**. Этот каталог должен находиться в корневом каталоге проекта, то есть в том же каталоге, что и в каталоге и папках **locallibrary**). Создайте эти папки сейчас.

> [!NOTE]
> Ваша структура папок теперь должна выглядеть так:
> locallibrary (django project folder)
> |\_catalog
> |\_locallibrary
> |\_templates **(new)**
> |\_registration

Чтобы сделать эти директории видимыми для загрузчика шаблонов (т. е. помещать этот каталог в путь поиска шаблона) откройте настройки проекта (**/locallibrary/locallibrary/settings.py**), и обновите в секции `TEMPLATES` строку `'DIRS'` как показано.

```python
TEMPLATES = [
    {
        ...
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        ...
```

### Шаблон аутентификации

> **Предупреждение:** **Важно**: Шаблоны аутентификации, представленные в этой статье, являются очень простой / слегка изменённой версией шаблонов логина демонстрации Django. Возможно, вам придётся настроить их для собственного использования!

Создайте новый HTML файл, названный /**locallibrary/templates/registration/login.html**. дайте ему следующее содержание:

```django
{% extends "base_generic.html" %}

{% block content %}

{% if form.errors %}
  <p>Your username and password didn't match. Please try again.</p>
{% endif %}

{% if next %}
  {% if user.is_authenticated %}
    <p>Your account doesn't have access to this page. To proceed,
    please login with an account that has access.</p>
  {% else %}
    <p>Please login to see this page.</p>
  {% endif %}
{% endif %}

<form method="post" action="{% url 'login' %}">
{% csrf_token %}
<table>

<tr>
  <td>\{{ form.username.label_tag }}</td>
  <td>\{{ form.username }}</td>
</tr>

<tr>
  <td>\{{ form.password.label_tag }}</td>
  <td>\{{ form.password }}</td>
</tr>
</table>

<input type="submit" value="login" />
<input type="hidden" name="next" value="\{{ next }}" />
</form>

{# Assumes you setup the password_reset view in your URLconf #}
<p><a href="{% url 'password_reset' %}">Lost password?</a></p>

{% endblock %}
```

Этот шаблон имеет сходство с тем, что мы видели раньше - он расширяет наш базовый шаблон и переопределяет блок контента. Остальная часть кода - это довольно стандартный код обработки формы, о котором мы поговорим в следующем учебном пособии. Все, что вам нужно знать, это показ формы, в которой вы можете ввести своё имя пользователя и пароль, а если вы введёте недопустимые значения, вам будет предложено ввести правильные значения, когда страница обновится.

Перейдите на страницу входа (`http://127.0.0.1:8000/accounts/login/`) когда вы сохраните свой шаблон, и вы должны увидеть что-то наподобие этого:

![Library login page v1](library_login.png)

Если ваша попытка войти в систему будет успешной, вы будете перенаправлены на другую страницу (по умолчанию это будет `http://127.0.0.1:8000/accounts/profile/`). Проблема здесь в том, что по умолчанию Django ожидает, что после входа в систему вы захотите перейти на страницу профиля, что может быть или не быть. Поскольку вы ещё не определили эту страницу, вы получите ещё одну ошибку!

Откройте настройки проекта (**/locallibrary/locallibrary/settings.py**) и добавьте текст ниже. Теперь, когда вы входите в систему, вы по умолчанию должны перенаправляться на домашнюю страницу сайта.

```python
# Redirect to home URL after login (Default redirects to /accounts/profile/)
LOGIN_REDIRECT_URL = '/'
```

### Шаблон выхода

Если вы перейдёте по URL-адресу выхода (`http://127.0.0.1:8000/accounts/logout/`), то увидите странное поведение - ваш пользователь наверняка выйдет из системы, но вы попадёте на страницу выхода администратора. Это не то, что вам нужно, хотя бы потому, что ссылка для входа на этой странице приведёт вас к экрану входа в систему администратора. (и это доступно только для пользователей, у которых есть разрешение `is_staff`).

Создайте и откройте **/locallibrary/templates/registration/logged_out.html**. Скопируйте текст ниже:

```django
{% extends "base_generic.html" %}

{% block content %}
  <p>Logged out!</p>

  <a href="{% url 'login'%}">Click here to login again.</a>
{% endblock %}
```

Этот шаблон очень прост. Он просто отображает сообщение, информирующее вас о том, что вы вышли из системы, и предоставляет ссылку, которую вы можете нажать, чтобы вернуться на экран входа в систему. Если вы снова перейдёте на страницу выхода из системы, вы увидите эту страницу:

![Library logout page v1](library_logout.png)

### Шаблон сброса пароля

Система сброса пароля по умолчанию использует электронную почту, чтобы отправить пользователю ссылку на сброс. Вам необходимо создать формы, чтобы получить адрес электронной почты пользователя, отправить электронное письмо, разрешить им вводить новый пароль и отметить, когда весь процесс будет завершён.

В качестве отправной точки можно использовать следующие шаблоны.

#### Форма сброса пароля

Это форма, используемая для получения адреса электронной почты пользователя (для отправки пароля для сброса пароля). Создайте **/locallibrary/templates/registration/password_reset_form.html** и дайте ему следующее содержание:

```django
{% extends "base_generic.html" %}

{% block content %}
  <form action="" method="post">{% csrf_token %}
      {% if form.email.errors %} \{{ form.email.errors }} {% endif %}
          <p>\{{ form.email }}</p>
      <input type="submit" class="btn btn-default btn-lg" value="Reset password" />
  </form>
{% endblock %}
```

#### Сброс пароля

Эта форма отображается после того, как ваш адрес электронной почты будет собран. Создайте **/locallibrary/templates/registration/password_reset_done.html**, и дайте ему следующее содержание:

```django
{% extends "base_generic.html" %}

{% block content %}
  <p>
    We've emailed you instructions for setting your password. If they haven't
    arrived in a few minutes, check your spam folder.
  </p>
{% endblock %}
```

#### Сброс пароля по email

Этот шаблон предоставляет текст электронной почты HTML, содержащий ссылку на сброс, которую мы отправим пользователям. Создайте /locallibrary/templates/registration/password_reset_email.html и дайте ему следующее содержание:

```django
Someone asked for password reset for email \{{ email }}. Follow the link below:
\{{ protocol}}://\{{ domain }}{% url 'password_reset_confirm' uidb64=uid token=token %}
```

#### Подтверждение на сброс пароля

На этой странице вы вводите новый пароль после нажатия ссылки в электронном письме с возвратом пароля. Создайте /locallibrary/templates/registration/password_reset_confirm.html и дайте ему следующее содержание:

```django
{% extends "base_generic.html" %}

{% block content %}
  {% if validlink %}
    <p>Please enter (and confirm) your new password.</p>
    <form action="" method="post">
      {% csrf_token %}
      <table>
        <tr>
          <td>
            \{{ form.new_password1.errors }}
            <label for="id_new_password1">New password:</label>
          </td>
          <td>\{{ form.new_password1 }}</td>
        </tr>
        <tr>
          <td>
            \{{ form.new_password2.errors }}
            <label for="id_new_password2">Confirm password:</label>
          </td>
          <td>\{{ form.new_password2 }}</td>
        </tr>
        <tr>
          <td></td>
          <td><input type="submit" value="Change my password" /></td>
        </tr>
      </table>
    </form>
  {% else %}
    <h1>Password reset failed</h1>
    <p>
      The password reset link was invalid, possibly because it has already been
      used. Please request a new password reset.
    </p>
  {% endif %}
{% endblock %}
```

#### Сброс пароля завершён

Это последний шаблон сброса пароля, который отображается, чтобы уведомить вас о завершении сброса пароля. Создайте /locallibrary/templates/registration/password_reset_complete.html и дайте ему следующее содержание:

```django
{% extends "base_generic.html" %}

{% block content %}
  <h1>The password has been changed!</h1>
  <p><a href="{% url 'login' %}">log in again?</a></p>
{% endblock %}
```

### Тестирование новых страниц аутентификации

Теперь, когда вы добавили конфигурацию URL и создали все эти шаблоны, теперь страницы аутентификации должны работать! Вы можете протестировать новые страницы аутентификации, попытавшись войти в систему, а затем выйдите из учётной записи суперпользователя, используя эти URL-адреса:

- `http://127.0.0.1:8000/accounts/login/`
- `http://127.0.0.1:8000/accounts/logout/`

Вы сможете проверить функцию сброса пароля по ссылке на странице входа. **Имейте в виду, что Django отправляет только сбросные электронные письма на адреса (пользователи), которые уже хранятся в его базе данных!**

> [!NOTE]
> Система сброса пароля требует, чтобы ваш сайт поддерживал электронную почту, что выходит за рамки этой статьи, поэтому эта часть **ещё не будет работать.** Чтобы разрешить тестирование, поместите следующую строку в конец файла settings.py. Это регистрирует любые письма, отправленные на консоль (чтобы вы могли скопировать ссылку на сброс пароля с консоли).
>
> ```python
> EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
> ```
>
> Для получения дополнительной информации см. [Отправка email](https://docs.djangoproject.com/en/2.0/topics/email/) (Django docs).

## Тестирование проверки подлинности пользователей

В этом разделе мы рассмотрим, что мы можем сделать, чтобы выборочно контролировать контент, который видят пользователи, на основе того, вошли ли они в систему или нет.

### Тестирование в шаблонах

Вы можете получить информацию о текущем зарегистрированном пользователе в шаблонах с переменной шаблона \\{{user}} (это добавляется в контекст шаблона по умолчанию при настройке проекта, как и в нашем скелете).

Обычно вы сначала проверяете переменную шаблона \\{{user.is_authenticated}}, чтобы определить, имеет ли пользователь право видеть конкретный контент. Чтобы продемонстрировать это, мы обновим нашу боковую панель, чтобы отобразить ссылку «Вход», если пользователь вышел из системы, и ссылку «Выход», если он вошёл в систему.

Откройте базовый шаблон (/locallibrary/catalog/templates/base_generic.html) и скопируйте следующий текст в sidebar блок непосредственно перед тегом шаблона endblock.

```python
  <ul class="sidebar-nav">

    ...

   {% if user.is_authenticated %}
     <li>User: \{{ user.get_username }}</li>
     <li><a href="{% url 'logout'%}?next=\{{request.path}}">Logout</a></li>
   {% else %}
     <li><a href="{% url 'login'%}?next=\{{request.path}}">Login</a></li>
   {% endif %}
  </ul>
```

Как вы можете видеть, мы используем теги шаблона if-else-endif для условного отображения текста на основе того, является ли \\{{user.is_authenticated}} истинным. Если пользователь аутентифицирован, мы знаем, что у нас есть действительный пользователь, поэтому мы вызываем \\{{user.get_username}}, чтобы отобразить их имя.

Мы создаём URL-адрес для входа и выхода из системы, используя тег шаблона URL-адреса и имена соответствующих конфигураций URLs. Также обратите внимание на то, как мы добавили `?next=\{{request.path}}` в конец URLs. Это означает, что следующий URL-адрес содержит адрес (URL) текущей страницы, в конце связанного URL-адреса. После того, как пользователь успешно выполнил вход в систему, представления будут использовать значение "`next`" чтобы перенаправить пользователя обратно на страницу, где они сначала нажали ссылку входа / выхода из системы.

> [!NOTE]
> Попробуйте! Если вы находитесь на главной странице и вы нажимаете «Вход / Выход» на боковой панели, то после завершения операции вы должны вернуться на ту же страницу.

### Тестирование в представлениях

Если вы используете функциональные представления, самым простым способом ограничить доступ к вашим функциям является применение `login_required` декоратор к вашей функции просмотра, как показано ниже. Если пользователь вошёл в систему, ваш код просмотра будет выполняться как обычно. Если пользователь не вошёл в систему, это перенаправит URL-адрес входа, определённый в настройках проекта. (`settings.LOGIN_URL`), передав текущий абсолютный путь в качестве next параметра URL. Если пользователю удастся войти в систему, они будут возвращены на эту страницу, но на этот раз аутентифицированы.

```python
from django.contrib.auth.decorators import login_required

@login_required
def my_view(request):
    ...
```

> [!NOTE]
> Вы можете сделать то же самое вручную, путём тестирования `request.user.is_authenticated`, но декоратор намного удобнее!

Аналогичным образом, самый простой способ ограничить доступ к зарегистрированным пользователям в ваших представлениях на основе классов - это производные от `LoginRequiredMixin`. Вы должны объявить этот mixin сначала в списке суперкласса, перед классом основного представления.

```python
from django.contrib.auth.mixins import LoginRequiredMixin

class MyView(LoginRequiredMixin, View):
    ...
```

Это имеет такое же поведение при переадресации, что и `login_required` декоратор. Вы также можете указать альтернативное местоположение для перенаправления пользователя, если он не аутентифицирован (`login_url`), и имя параметра URL вместо "`next`" , чтобы вставить текущий абсолютный путь (`redirect_field_name`).

```python
class MyView(LoginRequiredMixin, View):
    login_url = '/login/'
    redirect_field_name = 'redirect_to'
```

Для получения дополнительной информации ознакомьтесь с [Django docs here](https://docs.djangoproject.com/en/1.10/topics/auth/default/#limiting-access-to-logged-in-users).

## Пример - перечисление книг текущего пользователя

Теперь, когда мы знаем, как ограничить страницу определённому пользователю, создайте представление о книгах, которые заимствовал текущий пользователь.

К сожалению, у нас пока нет возможности пользователям использовать книги! Поэтому, прежде чем мы сможем создать список книг, мы сначала расширим `BookInstance` модель для поддержки концепции заимствования и использования приложения Django Admin для заимствования ряда книг нашему тестовому пользователю.

### Модели

Прежде всего, мы должны предоставить пользователям возможность кредита на `BookInstance` (у нас уже есть `status` и `due_back` дата, но у нас пока нет связи между этой моделью и пользователем. Мы создадим его с помощью поля `ForeignKey` (один ко многим). Нам также нужен простой механизм для проверки того, просрочена ли заёмная книга.

Откройте **catalog/models.py**, и импортируйте модель `User` из `django.contrib.auth.models` (добавьте это чуть ниже предыдущей строки импорта в верхней части файла, так `User` доступен для последующего кода, что позволяет использовать его):

```python
from django.contrib.auth.models import User
```

Затем добавьте поле `borrower` в модель `BookInstance`:

```python
borrower = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
```

Пока мы здесь, давайте добавим свойство, которое мы можем вызвать из наших шаблонов, чтобы указать, просрочен ли конкретный экземпляр книги. Хотя мы могли бы рассчитать это в самом шаблоне, использование свойства, как показано ниже, будет намного более эффективным. Добавьте это где-нибудь в верхней части файла:

```
from datetime import date
```

Теперь добавьте следующее определение свойства внутри класса BookInstance:

```python
@property
def is_overdue(self):
    if self.due_back and date.today() > self.due_back:
        return True
    return False
```

> [!NOTE]
> Сначала мы проверим, является ли `due_back` пустым, прежде чем проводить сравнение. Пустое поле `due_back` заставило Django выкидывать ошибку, а не показывать страницу: пустые значения не сопоставимы. Это не то, что мы хотели бы, чтобы наши пользователи испытывали!

Теперь, когда мы обновили наши модели, нам нужно будет внести новые изменения в проект, а затем применить эти миграции:

```bash
python3 manage.py makemigrations
python3 manage.py migrate
```

### Admin

Теперь откройте каталог **catalog/admin.py**, и добавьте поле `borrower` в класс `BookInstanceAdmin` , как в `list_display` , так и в полях `fieldsets` , как показано ниже. Это сделает поле видимым в разделе Admin, так что мы можем при необходимости назначить `User` в `BookInstance`.

```python
@admin.register(BookInstance)
class BookInstanceAdmin(admin.ModelAdmin):
    list_display = ('book', 'status', 'borrower', 'due_back', 'id')
    list_filter = ('status', 'due_back')

    fieldsets = (
        (None, {
            'fields': ('book','imprint', 'id')
        }),
        ('Availability', {
            'fields': ('status', 'due_back','borrower')
        }),
    )
```

### Займите несколько книг

Теперь, когда возможно кредитовать книги конкретному пользователю, зайдите и заработайте на нескольких записей в `BookInstance`. Установите `borrowed` поле вашему тестовому пользователю, сделайте `status` «В займе» и установите сроки оплаты как в будущем, так и в прошлом.

> [!NOTE]
> Мы не будем описывать процесс, так как вы уже знаете, как использовать Admin сайт!

### Займ в представлении

Теперь мы добавим представление для получения списка всех книг, которые были предоставлены текущему пользователю. Мы будем использовать один и тот же общий класс, с которым мы знакомы, но на этот раз мы также будем импортировать и выводить из `LoginRequiredMixin`, так что только вошедший пользователь сможет вызвать это представление. Мы также решили объявить `template_name`, вместо того, чтобы использовать значение по умолчанию, потому что у нас может быть несколько разных списков записей BookInstance, с разными представлениями и шаблонами.

Добавьте следующее в catalog/views.py:

```python
from django.contrib.auth.mixins import LoginRequiredMixin

class LoanedBooksByUserListView(LoginRequiredMixin,generic.ListView):
    """
    Generic class-based view listing books on loan to current user.
    """
    model = BookInstance
    template_name ='catalog/bookinstance_list_borrowed_user.html'
    paginate_by = 10

    def get_queryset(self):
        return BookInstance.objects.filter(borrower=self.request.user).filter(status__exact='o').order_by('due_back')
```

Чтобы ограничить наш запрос только объектами BookInstance для текущего пользователя, мы повторно реализуем `get_queryset()`, как показано выше. Обратите внимание, что "o" это сохранённый код для "on loan" и мы сортируем по дате `due_back`, чтобы сначала отображались самые старые элементы.

### URL-адрес для заёмных книг

Теперь откройте **/catalog/urls.py** и добавьте `url()` , указывая на приведённое выше представление (вы можете просто скопировать текст ниже в конец файла).

```python
urlpatterns += [
    url(r'^mybooks/$', views.LoanedBooksByUserListView.as_view(), name='my-borrowed'),
]
```

### Шаблон для заёмных книг

Теперь все, что нам нужно сделать для этой страницы, - это добавить шаблон. Сначала создайте файл шаблона **/catalog/templates/catalog/bookinstance_list_borrowed_user.html** и дайте ему следующее содержание:

```python
{% extends "base_generic.html" %}

{% block content %}
    <h1>Borrowed books</h1>

    {% if bookinstance_list %}
    <ul>

      {% for bookinst in bookinstance_list %}
      <li class="{% if bookinst.is_overdue %}text-danger{% endif %}">
        <a href="{% url 'book-detail' bookinst.book.pk %}">\{{bookinst.book.title}}</a> (\{{ bookinst.due_back }})
      </li>
      {% endfor %}
    </ul>

    {% else %}
      <p>There are no books borrowed.</p>
    {% endif %}
{% endblock %}
```

Этот шаблон очень похож на тот, который мы создали ранее для объектов `Book` и `Author`. Единственное, что «новое» здесь, это то, что мы проверяем метод, который мы добавили в модель `(bookinst.is_overdue`) с целью использовать его для изменения цвета просроченных предметов.

Когда сервер разработки запущен, вы должны теперь иметь возможность просматривать список для зарегистрированного пользователя в своём браузере по адресу `http://127.0.0.1:8000/catalog/mybooks/`. Попробуйте это, когда ваш пользователь войдёт в систему и выйдет из системы (во втором случае вы должны быть перенаправлены на страницу входа в систему).

### Добавить список на боковую панель

Последний шаг - добавить ссылку на эту новую страницу в sidebar. Мы поместим это в тот же раздел, где мы покажем другую информацию для зарегистрированного пользователя.

Откройте базовый шаблон (**/locallibrary/catalog/templates/base_generic.html**) и добавьте выделенную строку из sidebar, как показано на рисунке.

```python
 <ul class="sidebar-nav">
   {% if user.is_authenticated %}
   <li>User: \{{ user.get_username }}</li>
   <li><a href="{% url 'my-borrowed' %}">My Borrowed</a></li>
   <li><a href="{% url 'logout'%}?next=\{{request.path}}">Logout</a></li>
   {% else %}
   <li><a href="{% url 'login'%}?next=\{{request.path}}">Login</a></li>
   {% endif %}
 </ul>
```

### На что это похоже?

Когда любой пользователь войдёт в систему, он будет видеть ссылку «Мной позаимствовано (_My Borrowed)_» в боковой колонке, и список книг, показанных ниже (первая книга не имеет установленной даты, что является ошибкой, которую мы надеемся исправить в более позднем уроке!).

![Library - borrowed books by user](library_borrowed_by_user.png)

## Права доступа

Права доступа связаны с моделями и определяют операции, которые могут выполняться на экземпляре модели самим пользователем, у которого есть разрешение. По умолчанию Django автоматически даёт _добавить_, _изменить_, и _удалить_ разрешения у всех моделей, которые позволяют пользователям с правом доступа выполнять связанные действия через администратора сайта. Вы можете определить свои собственные разрешения для моделей и предоставить их конкретным пользователям. Вы также можете изменить разрешения, связанные с разными экземплярами одной и той же модели. Тестирование разрешений в представлениях и шаблонах очень похоже на тестирование по статусу аутентификации (фактически, тестирование прав доступа также проверяет аутентификацию).

### Модели

Определение разрешений выполняется в разделе моделей "`class Meta`" , используется `permissions` поле. Вы можете указать столько разрешений, сколько необходимо в кортеже, причём каждое разрешение определяется во вложенном кортеже, содержащем имя разрешения и отображаемое значение разрешения. Например, мы можем определить разрешение, позволяющее пользователю отметить, что книга была возвращена, как показано здесь:

```python
class BookInstance(models.Model):
    ...
    class Meta:
        ...
        permissions = (("can_mark_returned", "Set book as returned"),)
```

Затем мы могли бы назначить разрешение группе «Библиотекарь» (Librarian) на сайте администратора.

Откройте **catalog/models.py**, и добавьте разрешение, как показано выше. Вам нужно будет повторно выполнить миграцию (вызвав `python3 manage.py makemigrations` и `python3 manage.py migrate`) для надлежащего обновления базы данных.

### Шаблоны

Разрешения текущего пользователя хранятся в переменной шаблона, называемой `\{{ perms }}`. Вы можете проверить, имеет ли текущий пользователь определённое разрешение, используя конкретное имя переменной в соответствующем приложении «Django» - например, `\{{ perms.catalog.can_mark_returned }}` будет `True` если у пользователя есть это разрешение, а `False` - в противном случае. Обычно мы проверяем разрешение с использованием шаблона `{% if %}`, как показано в:

```python
{% if perms.catalog.can_mark_returned %}
    <!-- We can mark a BookInstance as returned. -->
    <!-- Perhaps add code to link to a "book return" view here. -->
{% endif %}
```

### Представления

Разрешения можно проверить в представлении функции, используя `permission_required` декоратор или в представлении на основе классов, используя `PermissionRequiredMixin`. шаблон и поведение такие же, как для аутентификации входа в систему, хотя, конечно, вы можете разумно добавить несколько разрешений.

Функция в представлении с декоратором:

```python
from django.contrib.auth.decorators import permission_required

@permission_required('catalog.can_mark_returned')
@permission_required('catalog.can_edit')
def my_view(request):
    ...
```

Требуется разрешение mixin для представлений на основе классов.

```python
from django.contrib.auth.mixins import PermissionRequiredMixin

class MyView(PermissionRequiredMixin, View):
    permission_required = 'catalog.can_mark_returned'
    # Or multiple permissions
    permission_required = ('catalog.can_mark_returned', 'catalog.can_edit')
    # Note that 'catalog.can_edit' is just an example
    # the catalog application doesn't have such permission!
```

### Пример

Мы не будем обновлять LocalLibrary здесь; возможно, в следующем уроке!

## Испытайте себя

Ранее в этой статье мы показали вам, как создать страницу для текущего пользователя, в которой перечислены книги, которые они заимствовали. Теперь задача состоит в том, чтобы создать аналогичную страницу, которая видна только для библиотекарей, которая отображает _все_ книги, которые были заимствованы, и которая показывает имя каждого заёмщика.

Вы должны следовать той же схеме, что и для другого представления. Главное отличие состоит в том, что вам нужно ограничить представление только библиотекарями. Вы можете сделать это на основе того, является ли пользователь сотрудником (декоратор функции: `staff_member_required`, переменная шаблона: `user.is_staff`) но мы рекомендуем вам вместо этого использовать `can_mark_returned` разрешения и `PermissionRequiredMixin`, как описано в предыдущем разделе.

> **Предупреждение:** **Важно**: Не забудьте использовать вашего суперпользователя для тестирования на основе разрешений (проверки разрешений всегда возвращают true для суперпользователей, даже если разрешение ещё не определено!). Вместо этого создайте пользователя-библиотекаря и добавьте необходимые возможности.

Когда вы закончите, ваша страница должна выглядеть примерно, как на скриншоте ниже.

![All borrowed books, restricted to librarian](library_borrowed_all.png)

## Подводим итоги

Отличная работа - теперь вы создали веб-сайт, на котором участники библиотеки могут входить в систему и просматривать собственный контент, и библиотекари (с правом доступа) могут просматривать все заёмные книги с их читателями. На данный момент мы все ещё просто просматриваем контент, но те же принципы и методы используются, когда вы хотите начать изменять и добавлять данные.

В следующей статье мы рассмотрим, как вы можете использовать формы Django для сбора пользовательского ввода, а затем начнём изменять некоторые из наших сохранённых данных.

## Смотрите также

- [User authentication in Django](https://docs.djangoproject.com/en/1.10/topics/auth/) (Django docs)
- [Using the (default) Django authentication system](https://docs.djangoproject.com/en/1.10/topics/auth/default//) (Django docs)
- [Introduction to class-based views > Decorating class-based views](https://docs.djangoproject.com/en/1.10/topics/class-based-views/intro/#decorating-class-based-views) (Django docs)

{{PreviousMenuNext("Learn/Server-side/Django/Sessions", "Learn/Server-side/Django/Forms", "Learn/Server-side/Django")}}
