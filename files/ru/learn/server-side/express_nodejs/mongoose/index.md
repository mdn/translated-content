---
title: "Учебник Express часть 3: Использование базы данных (с помощью Mongoose)"
slug: Learn/Server-side/Express_Nodejs/mongoose
---

{{LearnSidebar}}{{PreviousMenuNext("Learn/Server-side/Express_Nodejs/skeleton_website", "Learn/Server-side/Express_Nodejs/routes", "Learn/Server-side/Express_Nodejs")}}

В этой статье даётся краткое введение в базы данных, и методика их использования в приложениях Node/Express. Затем мы покажем, как можно использовать [Mongoose](http://mongoosejs.com/) для доступа к базе данных веб-сайта [LocalLibrary](/ru/docs/Learn/Server-side/Express_Nodejs/Tutorial_local_library_website). Мы объясним, как объявляются схемы и модели объектов, укажем основные типы полей, и методику базовой валидации. В статье также кратко показаны основные методы доступа к данным модели.

| Предварительные сведения: | [Express Tutorial Part 2: Creating a skeleton website](/ru/docs/Learn/Server-side/Express_Nodejs/skeleton_website) |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| Цель:                     | Уметь спроектировать и создать свои модели, используя Mongoose.                                                    |

## Обзор

Сотрудники библиотеки будут использовать сайт Local Library для хранения информации о книгах и абонентах, а абоненты библиотеки будут использовать его для просмотра и поиска книг, для получения информации о доступных копиях, для резервирования или одалживания книг. Чтобы эффективно хранить и извлекать информацию, мы будем хранить её в базе данных.

Express-приложения могут использовать различные базы данных, и есть несколько подходов, которые можно использовать для выполнения операций **C**reate, **R**ead, **U**pdate and **D**elete (CRUD) (создать, прочесть, обновить, удалить). В руководстве дан краткий обзор некоторых доступных опций, и детально рассмотрены некоторые механизмы работы.

### Какие базы данных можно использовать?

*Express-*приложение может использовать любые базы данных, поддерживаемые _Node_ (сам по себе Express не определяет каких-либо конкретных дополнительных свойств и требований для управления базами данных). Есть [много популярных](https://expressjs.com/en/guide/database-integration.html) вариантов — PostgreSQL, MySQL, Redis, SQLite, и MongoDB.

При выборе базы данных следует учитывать такие факторы как время разработки, время обучения, простота репликации и копирования, расходы, поддержка сообщества и т. д. Хотя нет единственной "лучшей" базы данных, почти любое из популярных решений будет приемлемым для сайта малого и среднего размера, такого как наша Local Library.

Более подробно о вариантах смотрите в: [Database integration](https://expressjs.com/en/guide/database-integration.html) (Express docs).

### Каков наилучший способ взаимодействия с базой данных?

Существует два подхода при работе с базой данных:

- Использование родного языка запросов баз данных (т.е. SQL)
- Использование объектной модели данных (ODM) или объектно-реляционной модели (ORM). ODM / ORM представляют данные веб-сайта как объекты JavaScript, которые затем отображаются на поддерживающую базу данных. Некоторые ORM привязаны к определённой базе данных, тогда как другие не зависят от конкретной базы данных.

Наилучшую производительность можно получить с помощью SQL или другого языка запросов, поддерживаемого базой данных. Объектные модели (ODM) часто медленнее, потому что требуют перевода объектов в формат базы данных, при этом не обязательно будут использованы наиболее эффективные запросы к базе данных (особенно, если ODM предназначена для различных баз данных и должна идти на большие компромиссы в смысле поддержки тех или иных функций базы данных).

Преимущество применения ORM состоит в том, что программисты могут сосредоточиться на объектах JavaScript, а не на семантике базы данных — особенно, если требуется работать с разными базами данных (на одном или разных веб-сайтах). Они также дают очевидное место для валидации и проверки данных.

> [!NOTE]
> Совет: Применение ODM / ORMs часто приводит к снижению затрат на разработку и обслуживание! Если вы не очень хорошо знакомы с языком запросов базы данных или если производительность не имеет первостепенного значения, следует серьёзно рассмотреть возможность применения ODM.

### Какую модель ORM/ODM следует использовать?

Есть много ODM/ORM доступных решений на сайте менеджера пакетов NPM (проверьте теги по подгруппе [odm](https://www.npmjs.com/browse/keyword/odm) и [orm](https://www.npmjs.com/browse/keyword/orm)).

Популярные решения на момент написания статьи:

- [Mongoose](https://www.npmjs.com/package/mongoose): — это средство моделирование объектов базы данных [MongoDB](https://www.mongodb.org/), предназначенное для асинхронной работы.
- [Waterline](https://www.npmjs.com/package/waterline): ORM фреймворка [Sails](http://sailsjs.com/) (основан на Express) . Она предоставляет единый API для доступа к множеству баз данных, в том числе Redis, mySQL, LDAP, MongoDB, и Postgres.
- [Bookshelf](https://www.npmjs.com/package/bookshelf): поддерживает как promise- так и традиционные callback- интерфейсы, поддержка транзакций, eager/nested-eager relation loading, полиморфные ассоциации, и поддержка, один к одному, один ко многим, и многие ко многим. Работает с PostgreSQL, MySQL, и SQLite3.
- [Objection](https://www.npmjs.com/package/objection): Делает настолько лёгким, насколько возможно, использование всей мощи SQL и движка базы данных ( поддерживает SQLite3, Postgres, и MySQL).
- [Sequelize](https://www.npmjs.com/package/sequelize): Основанная на промисах ORM для Node.js и [io.js](https://ru.wikipedia.org/wiki/Io.js). Поддерживает диалекты PostgreSQL, MySQL, MariaDB, SQLite и MSSQL, обладает надёжной поддержкой транзакций, отношений, чтения копий и т.д.
- [Node ORM2](https://node-orm.readthedocs.io/en/latest/) — это OR менеджер для NodeJS. Поддерживает MySQL, SQLite и Progress, помогает работать с БД, используя объектный подход.
- [JugglingDB](http://1602.github.io/jugglingdb/) — это кросс-ДБ ORM для NodeJS, обеспечивающая общий интерфейс для доступа к наиболее популярным форматам БД. Поддерживает MySQL, SQLite3, Postgres, MongoDB, Redis и хранение данных в памяти js (собственный движок, только для тестирования).

Как правило, при выборе решения следует учитывать как предоставляемые функции, так и "деятельность сообщества" ( загрузки, вклад, отчёты об ошибках, качество документации, и т.д. ) . На момент написания статьи Mongoose являлась очень популярной ORM, и разумно, если вы выбрали MongoDB.

### Применение Mongoose и MongoDb для LocalLibrary

В примере LocalLibrary (и до конца раздела) мы будем использовать Mongoose ODM для доступа к данным нашей библиотеки. Mongoose является интерфейсом для MongoDB, NoSQL-базы данных с открытым исходным кодом, в которой использована документов-ориентированная модель данных. В MongoDB «коллекции» и «документы» — это аналоги «таблиц» и «строк» в реляционных БД.

Это сочетание ODM и БД весьма популярно в сообществе Node, частично потому, что система хранения документов и запросов очень похожа на JSON и поэтому знакома разработчикам JavaScript.

> [!NOTE]
> Не обязательно знать MongoDB, чтобы использовать Mongoose, хотя [документацию Mongoose](http://mongoosejs.com/docs/guide.html) легче использовать и понимать, если вы уже знакомы с MongoDB.

Далее показано, как определить и получить доступ к схеме и моделям Mongoose для примера веб-сайта LocalLibrary.

## Проектирование моделей LocalLibrary

Прежде чем начинать писать код моделей, стоит обдумать, какие данные нам нужно хранить, и каковы отношения между разными объектами.

Мы знаем, что нужно хранить информацию о книгах (название, резюме (краткое описание), автор, жанр, ISBN (Международный стандартный книжный номер) ) и что может быть несколько доступных экземпляров (с уникальными идентификаторами, статусом наличия и т. д.). Может потребоваться хранить больше информации об авторе (не только имя, т.к. могут быть авторы с одинаковыми или похожими именами). Мы хотим иметь возможность сортировать данные по названиям книг, по авторам, по жанрам и категориям.

При проектировании моделей имеет смысл иметь отдельные модели для каждого «объекта» (группы связанных данных). В этом случае очевидными объектами являются книги, экземпляры книг и авторы.

Можно также использовать модели для представления параметров списка выбора (например, как выпадающий список вариантов), вместо жёсткого кодирования выбора на самом веб-сайте - рекомендуется, когда не все параметры известны или могут быть изменены. Явный кандидат для модели такого типа — это жанр книги (например, «Научная фантастика», «Французская поэзия» и т.д.),

Как только мы определились с моделями и полями, следует подумать об отношениях между ними.

С учётом сказанного, UML-диаграмма связей (см. ниже) показывает модели, которые представлены как прямоугольники. Мы решили, что создадим модели для книги (общие сведения о книге), для экземпляра книги (состояние отдельных физических копий книги, доступных в системе) и для автора. Кроме того, у нас будет модель для жанра, чтобы эти значения можно было создавать динамически. Решено не создавать модель для `BookInstance:status` — мы пропишем в коде необходимые значения, потому что не ожидаем их изменения. На элементах диаграммы показаны имя модели, имена и типы полей, имена методов и типы их результатов .

Также показаны отношения между моделями, включая множественные отношения. Числа на линиях связи показывают максимум и минимум моделей, участвующих отношении. Например, линия между `Book` и `Genre` показывает, что `Book` и `Genre` связаны. Числа на этой линии рядом с моделью `Book` показывают, что жанр может быть связан с любым количеством книг, а числа на другом конце линии рядом с `Genre` отмечают, что книга может быть связана с любым количеством жанров.

> [!NOTE]
> Как показано в [Учебнике по Mongoose](#Mongoose_Справочник) ниже, часто лучше иметь поле, определяющее отношение между документами (моделями), только в одной модели (обратное отношение можно найти по присвоенному идентификатору `_id` в другой модели). Ниже мы предпочли задать отношения между Book/Genre и между Book/Author в схеме Book, а отношение между Book/BookInstance — в схеме BookInstance. Этот выбор в некотором смысле был произвольным — таким же хорошим мог бы быть выбор другого поля в другой схеме.

![Mongoose Library Model with correct cardinality](library_website_-_mongoose_express.png)

> [!NOTE]
> В следующем разделе дан базовый учебник, в котором объясняется, как задавать и как использовать модели. При чтении обратите внимание, как будут создаваться модели, приведённые на диаграмме.

## Учебник по Mongoose

В этом разделе кратко описано как подключиться к базе MongoDB с помощью Mongoose, как определить схемы и модели, как сформировать основные запросы.

> [!NOTE]
> На этот учебник значительно повлияло руководство [Mongoose quick start](https://www.npmjs.com/package/mongoose) на _npm_ и [официальная документация](http://mongoosejs.com/docs/guide.html).

### Установка Mongoose и MongoDB

Mongoose устанавливается в ваш проект (**package.json**) как и другие зависимости - при помощи NPM. Команда установки (выполняется из каталога проекта):

```bash
npm install mongoose
```

Установка _Mongoose_ добавит все зависимости, включая драйвер MongoDB, но не установит саму базу данных. При желании установить сервер MongoDB локально, можно [скачать установочный файл здесь](https://www.mongodb.com/download-center) для своей операционной системы и установить его. Также можно использовать облако MongoDB.

> [!NOTE]
> В примере для хранения базы данных мы используем облачный сервис [sandbox tier](https://mlab.com/plans/pricing/) ("песочницу"). Это удобно для разработки и имеет смысл для руководства, потому что такой подход делает "установку" базы данных независимой от операционной системы (база данных как веб-сервис — это также подход, который вы можете использовать для своей базы данных, находящейся в реальной эксплуатации).

### Подключение к MongoDB

_Mongoose_ требует подключение к MongoDB. Вы можете использовать require() и подключится к локальной БД при помощи `mongoose.connect(),` как показано ниже.

```js
// Импортировать модуль mongoose
var mongoose = require("mongoose");

// Установим подключение по умолчанию
var mongoDB = "mongodb://127.0.0.1/my_database";
mongoose.connect(mongoDB);
// Позволим Mongoose использовать глобальную библиотеку промисов
mongoose.Promise = global.Promise;
// Получение подключения по умолчанию
var db = mongoose.connection;

// Привязать подключение к событию ошибки  (получать сообщения об ошибках подключения)
db.on("error", console.error.bind(console, "MongoDB connection error:"));
```

При помощи `mongoose.connection` можно получить стандартный объект `Connection`. После подключения в экземпляре `Connection` возникает событие open (открыт).

> [!NOTE]
> Если необходимо создать дополнительные подключения, можно использовать `mongoose.createConnection()`. При этом будут применены те же БД URI (хост, БД, порт, опции и т.д.), что и в `connect()` и будет возвращён объект `Connection`.

### Определение и создание моделей

Модели можно создать при помощи интерфейса `Schema` . Schema позволяет указать поля, которые будут в каждом документе, значения полей по умолчанию и требования по валидации. Кроме того, можно задать статические методы и методы-хелперы (от help), облегчающие работу с вашими типами данных, а также задать виртуальные свойства, которые можно использовать как и обычные поля, но без влияния на данные в самой базе данных.

Схемы "компилируются " в окончательную модель методом `mongoose.model()`. После создания модели её можно использовать для поиска, создания, обновления и удаления объектов данного типа.

> [!NOTE]
> Каждой модели соответствует _коллекция_ _документов_ в ДБ MongoDB. Документы будут содержать поля тех типов, которые заданы в модели `Schema`.

#### Определение схем данных

Код ниже показывает, как можно задать простую схему. Сначала при помощи `require()` создаётся объект mongoose, затем конструктор Schema создаёт новый экземпляр схемы, при этом различные поля задаются как параметры конструктора.

```js
//Требуется Mongoose
var mongoose = require("mongoose");

//Определяем схему
var Schema = mongoose.Schema;

var SomeModelSchema = new Schema({
  a_string: String,
  a_date: Date,
});
```

В примере созданы два поля, типа String и типа Date. В следующем разделе будут примеры полей других типов, их валидации и примеры других методов.

#### Создание модели

Модели создаются из схем методом `mongoose.model()`:

```js
// Определяем схему
var Schema = mongoose.Schema;

var SomeModelSchema = new Schema({
  a_string: String,
  a_date: Date,
});

// Компилируем модель из схемы
var SomeModel = mongoose.model("SomeModel", SomeModelSchema);
```

Первый аргумент - уникальное имя создаваемой для модели коллекции(Mongoose создаст коллекцию для модели _SomeModel_), второй аргумент - схема, которая используется для создания модели.

> [!NOTE]
> После создания классов модели они могут применяться для создания, обновления или удаления записей в базе, для выполнения запросов по всем записям или по их подмножествам. Как это делать, будет показано в разделе [Использование моделей](#Using_models), и когда будут создаваться представления.

#### Типы схемы (поля)

Схема может содержать любое количество полей, причём каждое поле будет полем документа, хранимого в БД _MongoDB_. Схема-пример содержит определения многих широко используемых типов полей.

```js
var schema = new Schema({
  name: String,
  binary: Buffer,
  living: Boolean,
  updated: { type: Date, default: Date.now },
  age: { type: Number, min: 18, max: 65, required: true },
  mixed: Schema.Types.Mixed,
  _someId: Schema.Types.ObjectId,
  array: [],
  ofString: [String], // You can also have an array of each of the other types too.
  nested: { stuff: { type: String, lowercase: true, trim: true } },
});
```

Большинство типов в [SchemaTypes](http://mongoosejs.com/docs/schematypes.html) (указаны после "type:" или после имён полей) достаточно очевидны. Исключения:

- `ObjectId`: Представляет отдельный экземпляр модели в БД. Например, book может ссылаться на объект- автора. Поле будет содержать уникальный идентификатор (`_id`) отдельного объекта. При необходимости использования этой информации применяют метод `populate()`.
- [Mixed](http://mongoosejs.com/docs/schematypes.html#mixed): Произвольный тип в схеме.
- \[]: Массив элементов. В таких моделях можно выполнять JavaScript-операции для массивов (push, pop, unshift, etc.). Выше показан пример массива объектов неопределённого типа и массив строк, но можно использовать массив объектов любого типа.

Код содержит также два способа объявления полей:

- _Имя_ и _тип_ поля как пара "ключ-значение" (поля `name`, `binary и` `living`).
- _Имя_ поля, после которого указывается объект, определяющий _тип_ и другие возможности поля, такие как:

  - значения по умолчанию.
  - встроенные валидаторы (например, значения max и min) и функции-валидаторы пользователя.
  - Является ли поле обязательным
  - Должны ли строковые поля автоматически преобразовываться в нижний или верхний регистр, удалять ли ведущие и хвостовые пробелы (`пример:` `{ type: String, lowercase: true, trim: true }`)

Дополнительная информация - в [SchemaTypes](http://mongoosejs.com/docs/schematypes.html) (документация Mongoose).

#### Валидация (проверка допустимости)

Mongoose предусматривает встроенные валидаторы, валидаторы пользователя, синхронные и асинхронные валидаторы. Во всех случаях можно задать допустимые диапазоны или значения, а также сообщения об ошибках при нарушении условий валидации.

Встроенные валидаторы включают:

- Все [SchemaTypes](http://mongoosejs.com/docs/schematypes.html) имеют встроенный валидатор [required](http://mongoosejs.com/docs/api.html#schematype_SchemaType-required), который определяет, должно ли поле быть заданным перед сохранением документа.
- [Числа](http://mongoosejs.com/docs/api.html#schema-number-js) имеют валидаторы [min](http://mongoosejs.com/docs/api.html#schema_number_SchemaNumber-min) и [max](http://mongoosejs.com/docs/api.html#schema_number_SchemaNumber-max).
- [Строки](http://mongoosejs.com/docs/api.html#schema-string-js) имеют:

  - [enum](http://mongoosejs.com/docs/api.html#schema_string_SchemaString-enum) (перечисления): задают множество допустимых для поля значений.
  - [match](http://mongoosejs.com/docs/api.html#schema_string_SchemaString-match) (соответствия)): задают регулярное выражение, которому должна соответствовать строка.
  - [maxlength](http://mongoosejs.com/docs/api.html#schema_string_SchemaString-maxlength), [minlength](http://mongoosejs.com/docs/api.html#schema_string_SchemaString-minlength) -максимальная и минимальная длина строки.

Пример ниже (с небольшими изменениями из документации Mongoose) показывает, как задать некоторые валидаторы и сообщения об ошибках:

```js

    var breakfastSchema = new Schema({
      eggs: {
        type: Number,
        min: [6, 'Too few eggs'],
        max: 12
        required: [true, 'Why no eggs?']
      },
      drink: {
        type: String,
        enum: ['Coffee', 'Tea', 'Water',]
      }
    });
```

Подробная информация по валидации полей - в разделе [Validation](http://mongoosejs.com/docs/validation.html) (документация Mongoose).

#### Виртуальные свойства

Виртуальные свойства - это свойства документа, которые можно читать (get) и задавать (set), но которые не хранятся в MongoDB. Методы "геттеры" полезны для форматирования и соединения полей, а "сеттеры" применяют для декомпозиции отдельных значений на несколько частей перед сохранением в БД. Пример из документации собирает (и разбирает) виртуальное свойство "полное имя" из полей "имя" и "фамилия", что удобнее, чем конструировать полное имя каждый раз, когда оно используется в шаблоне.

> [!NOTE]
> В библиотеке виртуальное свойство будет применено для определения уникального URL каждой записи в модели по пути и по значению `_id` записи.

Подробная информация - в разделе [Virtuals](http://mongoosejs.com/docs/guide.html#virtuals) (документация Mongoose).

#### Методы и помощники запросов

В схеме можно также задать методы экземпляра ([instance methods](http://mongoosejs.com/docs/guide.html#methods)), статические ([static](http://mongoosejs.com/docs/guide.html#statics)) методы и [помощники запросов](http://mongoosejs.com/docs/guide.html#query-helpers). Статические методы и методы экземпляра аналогичны, но различаются тем, что методы экземпляра связаны с конкретной записью и имеют доступ к текущему объекту. Помощники запросов позволяют расширить [API построителя цепочек запросов](http://mongoosejs.com/docs/queries.html) (например, можно добавить запрос "byName" ("по имени") в дополнение к методам `find()`, `findOne()` и `findById()`).

### Применение моделей

Подготовленную схему можно использовать для создания моделей. Модель представляет коллекцию документов в базе данных, в которой можно выполнять поиск, тогда как экземпляры модели представляют отдельные документы, которые можно сохранять и извлекать.

Ниже предлагается краткий обзор. Более подробно смотрите в [Models](http://mongoosejs.com/docs/models.html) (документация Mongoose).

#### Создание и изменение документов

Чтобы создать запись, следует определить экземпляр модели и вызвать метод `save()`. В примере ниже SomeModel — это модель с единственным полем "name", которую мы создадим из нашей схемы.

```js
// Создать экземпляр модели SomeModel
var awesome_instance = new SomeModel({ name: "awesome" });

// Сохранить новый экземпляр, передав callback
awesome_instance.save(function (err) {
  if (err) return handleError(err);
  // сохранили!
});
```

Создание записей (а также обновления, удаления и запросы) - это асинхронные операции, поэтому следует предусмотреть колбэк-функцию, которая будет вызвана при завершении операции. В API используется соглашение о первом аргументе, согласно которому первый аргумент колбэк-функции должен быть значением ошибки (или null). Если API возвращает некоторый результат, он должен быть вторым аргументом.

Можно использовать метод `create()` для создании экземпляра модели при его сохранении. Тогда колбэк-функция вернёт ошибку (или null) как первый аргумент и только что созданный экземпляр как второй аргумент.

```js
SomeModel.create({ name: "also_awesome" }, function (err, awesome_instance) {
  if (err) return handleError(err);
  // сохранили!
});
```

Каждая модель ассоциирована с соединением (с соединением по умолчанию, если используется `mongoose.model()`). Следует создать новое соединение и вызвать для него `.model()`, чтобы создать документ в другой базе данных.

Поля в новой записи могут быть получены и изменены с применением dot (точка)-синтаксиса. Для сохранения изменений служат методы `save()` и `update()`.

```js
// Доступ к полям модели в dot-нотации
console.log(awesome_instance.name); //вывод в консоль 'also_awesome'

// Изменить запись, модифицируя поля, потом вызвать save().
awesome_instance.name = "New cool name";
awesome_instance.save(function (err) {
  if (err) return handleError(err); // сохранили!
});
```

#### Поиск записей

При поиске записей методами запросов, условия поиска следует задавать как документ JSON. Приведённый фрагмент кода (ниже) показывает, как в БД найти имена (_name_) и возраст (_age_) всех спортсменов-теннисистов. Соответствие будет определяться по одному полю (sport), но можно добавить критерии поиска, задав, например, регулярное выражение, или удалить все критерии, чтобы получить список всех спортсменов.

```js
var Athlete = mongoose.model("Athlete", yourSchema);

// найти всех теннисистов, выбирать поля 'name' и 'age'
Athlete.find({ sport: "Tennis" }, "name age", function (err, athletes) {
  if (err) return handleError(err);
  // 'athletes' содержит список спортсменов, соответствующих критерию.
});
```

Если задать колбэк-функцию так, как показано выше, запрос будет выполнен немедленно. Однако колбэк-функция будет вызвана только после завершения поиска.

> [!NOTE]
> Все колбэк-функции в Mongoose используют образец `callback(error, result)`. Если при выполнении запроса возникает ошибка, параметр `error` будет содержать объект error, а `result` будет null. При успешном запросе параметр `error` будет null, а `result` будет содержать результат запроса.

Если не задать колбэк-функцию, API вернёт переменную типа [Query](http://mongoosejs.com/docs/api.html#query-js). Можно использовать объект запроса, чтобы создать и выполнить свой запрос (с колбэк-функцией) позже, при помощи метода `exec()`.

```js
// найти всех теннисистов
var query = Athlete.find({ sport: "Tennis" });

// выбрать поля 'name' и 'age'
query.select("name age");

// ограничить результат 5 элементами
query.limit(5);

// сортировать по возрасту
query.sort({ age: -1 });

// выполнить запрос позже
query.exec(function (err, athletes) {
  if (err) return handleError(err);
  // athletes содержит упорядоченный список из 5 теннисистов
});
```

Выше условия поиска были заданы в методе `find()`. Можно также использовать функцию `where()`, кроме того, можно соединить все части в одном запросе применением оператора dot (.) вместо того, чтобы выполнять их раздельно. Фрагмент кода (см. ниже) выполняет тот же запрос, что и предыдущий фрагмент, но с дополнительным условием для возраста.

```
Athlete.
  find().
  where('sport').equals('Tennis').
  where('age').gt(17).lt(50).  //Дополнительное условие
  limit(5).
  sort({ age: -1 }).
  select('name age').
  exec(callback); // callback - имя нашей колбэк-функции.
```

Метод [find()](http://mongoosejs.com/docs/api.html#query_Query-find) находит все записи, удовлетворяющие условию, но часто требуется найти только одну из таких записей. Вот методы для поиска одной записи:

- [`findById()`](http://mongoosejs.com/docs/api.html#model_Model.findById): Находит документ по заданному идентификатору `id` (каждый документ имеет уникальный идентификатор `id`).
- [`findOne()`](http://mongoosejs.com/docs/api.html#query_Query-findOne): Находит один документ, удовлетворяющий заданному критерию.
- [`findByIdAndRemove()`](http://mongoosejs.com/docs/api.html#model_Model.findByIdAndRemove), [`findByIdAndUpdate()`](http://mongoosejs.com/docs/api.html#model_Model.findByIdAndUpdate), [`findOneAndRemove()`](http://mongoosejs.com/docs/api.html#query_Query-findOneAndRemove), [`findOneAndUpdate()`](http://mongoosejs.com/docs/api.html#query_Query-findOneAndUpdate): Находит один документ по `id` или по критерию, а затем или обновляет, или удаляет его. Эти методы весьма полезны для обновления или удаления записей.

> [!NOTE]
> Есть также метод [`count()`](http://mongoosejs.com/docs/api.html#model_Model.count), который определяет количество записей, соответствующих условию. Он полезен при выполнении подсчётов без фактического извлечения записей.

Запросы полезны и во многих других случаях. Дополнительная информация - в [Queries](http://mongoosejs.com/docs/queries.html) (документация Mongoose).

#### Работа со связанными документами — загрузка

Один документ (экземпляр модели) может ссылаться на другой документ при помощи поля `ObjectId` схемы, или на много других документов, используя массив идентификаторов `ObjectIds`. Идентификатор соответствующей модели хранится в поле. При необходимости получить действительное содержимое связанного документа, следует использовать в запросе метод [`populate()`](http://mongoosejs.com/docs/api.html#query_Query-populate), который заменит идентификатор в запросе действительными данными.

Например, в следующей схеме определены авторы и рассказы. У каждого автора может быть несколько рассказов, которые представим массивом ссылок of `ObjectId`. У каждого рассказа может быть только один автор. Ссылка "ref" (выделена жирным) указывает в схеме, какая модель должна быть связана с этим полем.

```js
var mongoose = require("mongoose"),
  Schema = mongoose.Schema;

var authorSchema = Schema({
  name: String,
  stories: [{ type: Schema.Types.ObjectId, ref: "Story" }],
});

var storySchema = Schema({
  author: { type: Schema.Types.ObjectId, ref: "Author" },
  title: String,
});

var Story = mongoose.model("Story", storySchema);
var Author = mongoose.model("Author", authorSchema);
```

Можно сохранить ссылки в связанном документе, используя значение идентификатора `_id`. Ниже создаётся автор, затем рассказ, и значение идентификатора id автора сохраняется в поле "author" рассказа.

```js
var bob = new Author({ name: "Bob Smith" });

bob.save(function (err) {
  if (err) return handleError(err);

  //автор Bob создан, создаём рассказ
  var story = new Story({
    title: "Bob goes sledding",
    author: bob._id, // присваиваем полю значение идентификатора Боба. Идентификатор создаётся по умолчанию!
  });

  story.save(function (err) {
    if (err) return handleError(err);
    // У Боба теперь есть рассказ!
  });
});
```

Теперь документ "story" ссылается на автора по идентификатору документа "author". Для получения информации об авторе применяется метод `populate()` (показано ниже).

```js
Story.findOne({ title: "Bob goes sledding" })
  .populate("author") //подменяет идентификатор автора информацией об авторе!
  .exec(function (err, story) {
    if (err) return handleError(err);
    console.log("The author is %s", story.author.name);
    // выводит "The author is Bob Smith"
  });
```

> [!NOTE]
> Внимательные читатели заметили, что автор добавлен к рассказу, но ничего не сделано, чтобы добавить рассказ к массиву рассказов `stories` автора. Как же тогда получить список всех рассказов конкретного автора? Один из возможных вариантов - добавить автора в массив рассказов, но при этом пришлось бы хранить данные об авторах и рассказах в двух местах и поддерживать их актуальность.
>
> Лучше получить `_id` нашего автора _author_, и применить `find()` для поиска этого идентификатора в поле "author" всех рассказов.
>
> ```js
> Story.find({ author: bob._id }).exec(function (err, stories) {
>   if (err) return handleError(err);
>   // возвращает все рассказы, у которых идентификатор Боба.
> });
> ```

Это почти все, что следует знать для работы со связанными данными _в нашем руководстве_. Более полную информацию можно найти в [Population](http://mongoosejs.com/docs/populate.html) (документация Mongoose).

### Одна схема (модель) - один файл

Можно использовать любую структуру файлов при создании схем и моделей, однако мы настоятельно рекомендуем определять каждую схему модели в отдельном модуле (файле), экспортируя метод для создания модели. Пример приведён ниже:

```js
// Файл: ./models/somemodel.js

//Требуется Mongoose
var mongoose = require("mongoose");

//Определяем схему
var Schema = mongoose.Schema;

var SomeModelSchema = new Schema({
  a_string: String,
  a_date: Date,
});

//экспортируется функция для содания класса модели "SomeModel"
module.exports = mongoose.model("SomeModel", SomeModelSchema);
```

You can then require and use the model immediately in other files. Below we show how you might use it to get all instances of the model.

```js
//Создаём модель SomeModel просто вызовом модуля из файла
var SomeModel = require("../models/somemodel");

// Используем объект SomeModel (модель) для поиска всех записей в SomeModel
SomeModel.find(callback_function);
```

## Установка базы данных MongoDB

Мы уже немного понимаем, что может делать Mongoose и как следует проектировать модели. Теперь самое время начать работу над сайтом _LocalLibrary_. Самое первое, что мы должны сделать - установить базу данных MongoDb, в которой будут храниться данные нашей библиотеки.

В этом руководстве мы будем использовать базу данных в "песочнице" ("[sandbox](https://mlab.com/plans/pricing/)") - бесплатный облачный сервис, предоставляемый [mLab](https://mlab.com/welcome/). Такая база не очень подходит для промышленных веб-сайтов, поскольку не имеет избыточности, но она очень удобна для разработки и прототипирования. Мы используем её, так как она бесплатна, её легко установить, и потому что mLab - популярный поставщик _базы данных как сервиса,_ и это может быть разумным выбором для промышленной базы данных (на данный момент другие известные возможности включают [Compose](https://www.compose.com/), [ScaleGrid](https://scalegrid.io/pricing.html) и [MongoDB Atlas](https://www.mongodb.com/cloud/atlas)).

> [!NOTE]
> При желании можно установить БД MongoDb локально, загрузив и установив [подходящие для вашей системы двоичные файлы](https://www.mongodb.com/download-center). В этом случае приводимые ниже инструкции не изменятся, за исключением URL базы данных, который нужно будет задать для установки соединения.

Первым делом надо [создать аккаунт](https://mlab.com/signup/) на mLab (это бесплатно, требует только основных контактных данных и ознакомления с условиями обслуживания).

После входа в систему вы увидите главную страницу [home](https://mlab.com/home):

1. Щёлкните **Create New** в разделе _MongoDB Deployments_ для создания новой БД.![](mlabcreatenewdeployment.png)
2. Откроется экран _Cloud Provider Selection - раздела провайдера облака_.
   ![MLab - screen for new deployment](mlab_new_deployment_form_v2.png)

   - Выберите план SANDBOX (Free) из раздела Plan Type (тип плана).
   - Выберите любого провайдера в разделе _Cloud Provider (провайдер облака)_. Разные провайдеры обслуживают разные регионы (показаны под выбранным типом плана).
   - Щёлкните кнопку **Continue**.

3. Откроется экран выбора региона _Select Region_.

   ![Select new region screen](mlab_new_deployment_select_region_v2.png)

   - Выберите ближайший к вам регион и щёлкните кнопку **Continue**.

4. Откроется экран _Final Details_ для ввода названия БД.

   - Введите имя новой базы - `local_library` и нажмите **Continue**.

5. Откроется экран подтверждения заказа _Order Confirmation_.
   ![Order confirmation screen](mlab_new_deployment_order_confirmation.png)

   - Щёлкните **Submit Order** (подтвердить заказ), чтобы создать БД.

6. Вы вернётесь на главный (home) экран. Щёлкните по вновь созданной базе, чтобы открыть экран с детальной информацией. Как видно, в БД нет коллекций (данных).
   ![mLab - Database details screen](mlab_new_deployment_database_details.png)

   На форме выше обведён URL для соединения с вашей БДthat you need to use to access your database is displayed on the form above (shown for this database circled above). Чтобы его использовать, необходимо создать пользователя БД, который позже введёт этот URL.

7. Щёлкните по вкладке **Users** и выберите кнопку **Add database user** (добавить пользователя БД).
8. Введите имя пользователя и пароль (дважды), затем нажмите **Create** (создать). Не отмечайте _Make read only_ (только для чтения)!
   ![](mlab_database_users.png)

Теперь БД создана, и для доступа к ней есть URL, имя пользователя и пароль. Это должно выглядеть примерно так: `mongodb://your_user_namer:your_password@ds119748.mlab.com:19748/local_library`.

## Установка Mongoose

Откройте окно команд и перейдите в каталог, в котором создан [каркас веб-сайта Local Library](/ru/docs/Learn/Server-side/Express_Nodejs/skeleton_website). Введите команду install, чтобы установить Mongoose (и её зависимости), а также добавьте её в файл **package.json**, если вы ещё не сделали этого ранее, при чтении [Учебника по Mongoose](#Installing_Mongoose_and_MongoDB).

```bash
npm install mongoose
```

## Подключение к MongoDB

Откройте **/app.js** (в корне проекта) и скопируйте приведённый ниже текст, в котором объявляется _объект приложения_ _Express_ (после строки `var app = express();`). Замените строку url БД ('_insert_your_database_url_here_') тем URL, который представляет вашу БД (т.е. используйте информацию, полученную от [mLab](#Setting_up_the_MongoDB_database)).

```js
//Устанавливаем соединение с mongoose
var mongoose = require("mongoose");
var mongoDB = "insert_your_database_url_here"; //замените url!!!
mongoose.connect(mongoDB);
mongoose.Promise = global.Promise;
var db = mongoose.connection;
db.on("error", console.error.bind(console, "MongoDB connection error:"));
```

Как указано ранее в [Учебнике по Mongoose](#Connecting_to_MongoDB), этот код задаёт соединение по умолчанию с привязкой события ошибки error (так что ошибки будут выведены в консоль).

## Определение схемы LocalLibrary

Мы определим отдельный модуль для каждой модели как уже обсуждалось [выше](#One_schemamodel_per_file). Начнём с создания каталога для моделей в корне проекта (**/models**), после чего создадим отдельные файлы для каждой модели:

```
/express-locallibrary-tutorial  //the project root
  /models
    author.js
    book.js
    bookinstance.js
    genre.js
```

### Модель автора Author

Скопируйте код схемы автора `Author` (приведён ниже) в файл **./models/author.js** . В схеме определено, что у автора есть обязательные поля имени и фамилии типа `String` длиной не более 100 символов, и поля типа `Date` дата рождения и дата смерти.

```js
var mongoose = require("mongoose");

var Schema = mongoose.Schema;

var AuthorSchema = new Schema({
  first_name: { type: String, required: true, max: 100 },
  family_name: { type: String, required: true, max: 100 },
  date_of_birth: { type: Date },
  date_of_death: { type: Date },
});

// Виртуальное свойство для полного имени автора
AuthorSchema.virtual("name").get(function () {
  return this.family_name + ", " + this.first_name;
});

// Виртуальное свойство - URL автора
AuthorSchema.virtual("url").get(function () {
  return "/catalog/author/" + this._id;
});

//Export model
module.exports = mongoose.model("Author", AuthorSchema);
```

Мы объявим также в схеме AuthorSchema [виртуальное](#Virtual_properties) свойство "url" , которое позволит получить абсолютный URL конкретного экземпляра модели — используем это свойство в шаблонах, если потребуется получить связь с конкретным автором.

> [!NOTE]
> Объявить в схеме URL как виртуальные свойства - хорошая идея, т.к. URL отдельного элемента при необходимости изменения требует коррекции только в одном месте.
> Сейчас связь при помощи этого URL ещё не работает, так как у нас ещё нет кода, поддерживающего маршруты для экземпляров модели. Мы построим его в следующей статье!

В конце модуля экспортируется модель.

### Модель книги Book

Скопируйте код схемы `Book` (приведён ниже) в файл **./models/book.js**. Большая часть кода подобна коду для модели автора — объявляется схема с рядом строковых полей, с виртуальным свойством URL для получения URL конкретных книг, затем модель экспортируется.

```js
var mongoose = require("mongoose");

var Schema = mongoose.Schema;

var BookSchema = new Schema({
  title: { type: String, required: true },
  author: { type: Schema.ObjectId, ref: "Author", required: true },
  summary: { type: String, required: true },
  isbn: { type: String, required: true },
  genre: [{ type: Schema.ObjectId, ref: "Genre" }],
});

// Virtual for book's URL
BookSchema.virtual("url").get(function () {
  return "/catalog/book/" + this._id;
});

//Export model
module.exports = mongoose.model("Book", BookSchema);
```

Основное отличие в том, что созданы две ссылки на другие модели:

- author - это ссылка на единственный объект модели `Author` , обязательный элемент.
- genre (жанр) - ссылка на массив объектов модели `Genre`. Эта модель ещё не объявлена!

### Модель экземпляра книги BookInstance

Наконец, скопируйте код схемы `BookInstance` (приведён ниже) в файл **./models/bookinstance.js**. Схема `BookInstance` представляет конкретный экземпляр книги, которую можно одолжить на время, и содержит информацию о доступности экземпляров книги, о дате возврата одолженной книги, о деталях версии или печатного экземпляра.

```js
var mongoose = require("mongoose");

var Schema = mongoose.Schema;

var BookInstanceSchema = new Schema({
  book: { type: Schema.ObjectId, ref: "Book", required: true }, //ссылка на книгу
  imprint: { type: String, required: true },
  status: {
    type: String,
    required: true,
    enum: ["Available", "Maintenance", "Loaned", "Reserved"],
    default: "Maintenance",
  },
  due_back: { type: Date, default: Date.now },
});

// Virtual for bookinstance's URL
BookInstanceSchema.virtual("url").get(function () {
  return "/catalog/bookinstance/" + this._id;
});

//Export model
module.exports = mongoose.model("BookInstance", BookInstanceSchema);
```

В этой схеме новыми являются опции поля:

- `enum`: Позволяет указать допустимые значения строки. В нашем случае используются, чтобы задать статус доступности книги (применение enum (перечисления) означает, что мы ходим предотвратить ошибочное написание и произвольные значения статуса)
- `default`: определяет значение статуса по умолчанию (maintenance) при создании экземпляра книги, и дату `due_back` возврата книги (`now,` сейчас). Отметьте, как используется функция Date при установке даты!

Все остальное знакомо по предыдущим схемам.

### Модель жанра Genre - проверьте себя!

Откройте файл **./models/genre.js** и создайте схему для хранения жанра (категории книги, т.е. художественная или научная, романтика или военная история и т.д.).

Определение будет подобно другим моделям:

- В модели должно быть поле `name` типа `String` для указания жанра.
- Это поле должно быть обязательным, допустимый размер - от 3 до 100 символов.
- Объявите виртуальное ([virtual](#Virtual_properties)) свойство с именем `url` для URL жанра.
- Экспортируйте модель.

## Тестирование — создаём элементы БД

Вот так. У нас теперь есть все модели для создания сайта!

Для тестирования моделей (и для создания примеров книг и других элементов, которые потребуются в следующих статьях) выполним _независимый_ скрипт, который создаст элементы каждого типа:

1. Загрузите (или создайте) файл [populatedb.js](https://raw.githubusercontent.com/hamishwillee/express-locallibrary-tutorial/master/populatedb.js) в каталоге _express-locallibrary-tutorial_ (на том же уровне, что и `package.json`).

   > [!NOTE]
   > Не обязательно понимать, как работает [populatedb.js](https://raw.githubusercontent.com/hamishwillee/express-locallibrary-tutorial/master/populatedb.js); он просто помещает некоторые данные в базу данных.

2. Введите в корне проекта команду для установки модуля _async,_ который потребуется скрипту populatedb.js (роль async обсудим в следующих руководствах)

   ```bash
   npm install async
   ```

3. Запустите скрипт из командной строки, используя node. В качестве параметра укажите URL вашей БД _MongoDB_ (тот самый, которым вы ранее заменили _insert_your_database_url_here_ в файле `app.js` ):

   ```bash
   node populatedb <your mongodb url>
   ```

4. Скрипт должен выполниться до конца, выводя в терминал создаваемые элементы.

> [!NOTE]
> Откройте свою базу на [Lab](https://mlab.com/home). Вы сможете увидеть коллекции Book, Author, Genre, BookInstance (книги, авторы, жанры, экземпляры книг) и просмотреть содержащиеся в них документы.

## Итог

В этой статье мы познакомились с БД и ОРМ (объектно-реляционными моделями) в системе Node/Express, узнали, как определяются схемы и модели Mongoose. Мы применили эти знания при проектировании и реализации моделей `Book`, `BookInstance`, `Author` и `Genre` для веб-сайта _LocalLibrary_.

В конце мы испытали свои модели путём создания ряда элементов (при помощи автономного скрипта). В следующей статье мы рассмотрим создание страниц, на которых будут показаны эти элементы.

## Смотрите также

- [Database integration](https://expressjs.com/en/guide/database-integration.html) Интеграция БД (документация Express)
- [Mongoose website](http://mongoosejs.com/) Веб-сайт Mongoose (документация Mongoose)
- [Mongoose Guide](http://mongoosejs.com/docs/guide.html) Справочник Mongoose (документация Mongoose)
- [Validation](http://mongoosejs.com/docs/validation.html) Валидация (документация Mongoose)
- [Schema Types](http://mongoosejs.com/docs/schematypes.html) Типы в схемах (документация Mongoose)
- [Models](http://mongoosejs.com/docs/models.html) Модели (документация Mongoose)
- [Queries](http://mongoosejs.com/docs/queries.html) Запросы (документация Mongoose)
- [Population](http://mongoosejs.com/docs/populate.html) Пополнение БД (документация Mongoose)

{{PreviousMenuNext("Learn/Server-side/Express_Nodejs/skeleton_website", "Learn/Server-side/Express_Nodejs/routes", "Learn/Server-side/Express_Nodejs")}}

## In this module

- [Express/Node introduction](/ru/docs/Learn/Server-side/Express_Nodejs/Introduction)
- [Setting up a Node (Express) development environment](/ru/docs/Learn/Server-side/Express_Nodejs/development_environment)
- [Express Tutorial: The Local Library website](/ru/docs/Learn/Server-side/Express_Nodejs/Tutorial_local_library_website)
- [Express Tutorial Part 2: Creating a skeleton website](/ru/docs/Learn/Server-side/Express_Nodejs/skeleton_website)
- [Express Tutorial Part 3: Using a Database (with Mongoose)](/ru/docs/Learn/Server-side/Express_Nodejs/mongoose)
- [Express Tutorial Part 4: Routes and controllers](/ru/docs/Learn/Server-side/Express_Nodejs/routes)
- [Express Tutorial Part 5: Displaying library data](/ru/docs/Learn/Server-side/Express_Nodejs/Displaying_data)
- [Express Tutorial Part 6: Working with forms](/ru/docs/Learn/Server-side/Express_Nodejs/forms)
- [Express Tutorial Part 7: Deploying to production](/ru/docs/Learn/Server-side/Express_Nodejs/deployment)
