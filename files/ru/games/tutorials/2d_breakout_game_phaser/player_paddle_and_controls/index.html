---
title: Платформа и управление
slug: Games/Tutorials/2D_breakout_game_Phaser/Player_paddle_and_controls
translation_of: Games/Tutorials/2D_breakout_game_Phaser/Player_paddle_and_controls
original_slug: Games/Tutorials/Создание_2D_Breakout_игры_на_Phaser/Платформа_и_управление
---
<div>{{GamesSidebar}}</div>

<div>{{IncludeSubnav("/ru/docs/")}}</div>

<p>{{PreviousNext("Games/Tutorials/Создание_2D_Breakout_игры_на_Phaser/Bounce_off_the_walls", "Games/Tutorials/Создание_2D_Breakout_игры_на_Phaser/Game_over")}}</p>

<div class="summary">
<p>Это <strong>7 </strong>из 16 уроков <a href="https://developer.mozilla.org/ru/docs/Games/Tutorials/%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_2D_Breakout_%D0%B8%D0%B3%D1%80%D1%8B_%D0%BD%D0%B0_Phaser">руководства разработки игры с помощью Phaser</a>. Исходный код этого урока вы можете найти здесь: <a href="https://github.com/end3r/Gamedev-Phaser-Content-Kit/blob/gh-pages/demos/lesson07.html">Gamedev-Phaser-Content-Kit/demos/lesson07.html</a>.</p>
</div>

<p>Теперь, когда мы научили мячик двигаться и отскакивать от стен, давайте добавим немного геймплея. В этой главе мы создадим платформу-ракетку, которой будем отбивать наш мячик.</p>

<h2 id="Рисуем_платформу">Рисуем платформу</h2>

<p>С точки зрения фреймворка, платформа и мячик не сильно различаются - нам так же понадобится переменная для платформы, спрайт и немного магии.</p>

<h3 id="Создаём_платформу">Создаём платформу</h3>

<p>Сначала, добавим переменную <code>paddle</code>, сразу после переменной <code>ball</code>:</p>

<pre class="brush: js">var paddle;
</pre>

<p>После этого, в функции <code>preload</code>, загрузим изображение <code>paddle</code> при помощи ещё одного вызова функции <code>load.image()</code>:</p>

<pre class="brush: js">function preload() {
    // ...
    game.load.image('ball', 'img/ball.png');
    game.load.image('paddle', 'img/paddle.png');
}
</pre>

<h3 id="Добавляем_графику_для_платформы">Добавляем графику для платформы</h3>

<p>Чуть не забыли, на этом этапе нам надо скачать <a href="https://github.com/end3r/Gamedev-Phaser-Content-Kit/blob/gh-pages/demos/img/paddle.png">изображение платформы с Github</a> в папку <code>/img</code>.</p>

<h3 id="Рисуем_платформу_с_физикой">Рисуем платформу с физикой</h3>

<p>Далее, мы инициализируем спрайт нашей платформы при помощи функции <code>add.sprite()</code> — добавьте следующую строку кода в самый конец функции <code>create()</code>:</p>

<pre class="brush: js">paddle = game.add.sprite(game.world.width*0.5, game.world.height-5, 'paddle');
</pre>

<p>Мы можем использовать <code>world.width</code> и <code>world.height</code> для позиционирования платформы в том месте, где мы хотим: <code>game.world.width*0.5</code> расположит платформу прямо по середине экрана. В данном случае, нам повезло, что наш игровой мир совпадает с <code>&lt;canvas&gt;</code>, однако, в других играх мир может быть гораздо больше экрана. </p>

<p>Как вы могли заметить, перезагрузив, на данном этапе, страницу <code>index.html</code>, платформа находится не совсем по середине экрана. Почему? Всё дело в том, что, по умолчанию, точка, из которой начинается позиционирование объекта (якорь), находится в левом верхнем углу. Но мы можем это изменить и переместить якорь в середину платформы по ширине и в самый низ по высоте, чтобы проще было позиционировать платформу, относительно нижней грани экрана. Добавьте следующую строку кода:</p>

<pre class="brush: js">paddle.anchor.set(0.5,1);
</pre>

<p>Платформу расположили там, где и хотели. Теперь, чтобы платформа могла взаимодействовать с мячиком, добавим ей физику. Добавьте следующую строку кода в самый низ функции <code>create()</code>:</p>

<pre class="brush: js">game.physics.enable(paddle, Phaser.Physics.ARCADE);
</pre>

<p>Вот и настало время для магии - фреймворк сам позаботится о проверке столкновений (коллизий) в каждом кадре. Для того, чтобы включить проверку коллизий между платформой и мячиком, вызовите функцию <code>collide()</code> в функции <code>update()</code> как показано ниже:</p>

<pre class="brush: js">function update() {
    game.physics.arcade.collide(ball, paddle);
}
</pre>

<p>В качестве аргументов, мы передаём два объекта, между которыми проверяются коллизии — в нашем случае, мячик и платформа. Вроде, сработало, но не совсем так, как мы ожидали — когда мячик сталкивается с платформой, последняя падает за пределы экрана! А мы, всего лишь, хотим, чтобы мячик отскакивал от платформы, а платформа, при этом, оставалась на месте. Мы можем использовать свойство <code>immovable</code>, для того, чтобы платформа не двигалась, когда мячик бьётся об неё. Для этого добавьте следующую строку кода в конец функции <code>create()</code>:</p>

<pre class="brush: js">paddle.body.immovable = true;
</pre>

<p>Вот! Теперь всё работает, как надо.</p>

<h2 id="Управляем_платформой">Управляем платформой</h2>

<p>Следующая проблема заключается в том, что мы не можем двигать платформу. Чтобы сделать это мы можем воспользоваться вводом <code>input</code> (мышь или сенсорный экран, в зависимости от платформы) и расположить нашу платформу в месте расположения курсора. Добавьте следующую строку кода в функцию <code>update()</code>, как показано ниже:</p>

<pre class="brush: js">function update() {
    game.physics.arcade.collide(ball, paddle);
    paddle.x = game.input.x;
}
</pre>

<p>Теперь, каждый кадр координата <code>x</code> платформы будет соответствовать координате <code>x</code> курсора. Однако, при старте игры, положение нашей платформы не по центру экрана, из-за того, что положение курсора не определено. Чтобы это исправить, давайте добавим платформе координату <code>x</code> по умолчанию, на случай, если положение курсора не определено. Обновите предыдущую строку кода:</p>

<pre class="brush: js">paddle.x = game.input.x || game.world.width*0.5;
</pre>

<p>Если вы этого ещё не сделали, то обновите страницу <code>index.html</code> и попробуйте то, что у нас получилось!</p>

<h2 id="Расположение_мячика">Расположение мячика</h2>

<p>Теперь давайте разместим мячик на платформе. Так же, как и платформу, расположим мячик по середине экрана по горизонтали, с небольшим отступом от нижней грани экрана по вертикали. Для этого переместим якорь мячика в его середину. Найдите строку <code>ball = game.add.sprite( ... )</code> и заметите её на следующие две:</p>

<pre class="brush: js">ball = game.add.sprite(game.world.width*0.5, game.world.height-25, 'ball');
ball.anchor.set(0.5);</pre>

<p>Скорость оставим такую же, но изменим направление по оси <code>y</code>, изменив второй параметр со 150 на -150, и теперь мяч будет двигаться вверх. Найдите строку <code>ball.body.velocity.set( ... )</code> и измените её, как показано ниже:</p>

<pre class="brush: js">ball.body.velocity.set(150, -150);
</pre>

<p>Теперь мячик появляется по середине платформы и двигается вверх.</p>

<h2 id="Сравните_свой_код">Сравните свой код</h2>

<p>Вы можете проверить код из этого урока и поиграть с ним, чтобы лучше понять, как он работает:</p>

<p>{{JSFiddleEmbed("https://jsfiddle.net/end3r/ogqza0ye/","","400")}}</p>

<h2 id="Следующий_шаг">Следующий шаг</h2>

<p>Мы можем управлять платформой и сделали так, чтобы мячик отскакивал от неё. Но какой от этого толк, если мячик отскакивает и от нижней грани экрана? В следующей главе мы добавим <a href="https://developer.mozilla.org/ru/docs/Games/Tutorials/Создание_2D_Breakout_игры_на_Phaser/Game_over">логику проигрыша и экран "Game over"</a>.</p>

<p>{{PreviousNext("Games/Tutorials/Создание_2D_Breakout_игры_на_Phaser/Bounce_off_the_walls", "Games/Tutorials/Создание_2D_Breakout_игры_на_Phaser/Game_over")}}</p>
