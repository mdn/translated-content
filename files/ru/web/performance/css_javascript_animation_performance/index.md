---
title: Производительность CSS и JavaScript анимации
slug: Web/Performance/CSS_JavaScript_animation_performance
---

{{QuickLinksWithSubPages("Web/Performance")}}

Анимация является критичным инструментом для улучшения пользовательского опыта во многих приложениях. Существует много путей создания анимации в web, например, основанные на CSS-свойствах {{cssxref("transition","transitions")}}/{{cssxref("animation","animations")}} или на JavaScript (using {{domxref("Window.requestAnimationFrame","requestAnimationFrame()")}}). В этой статье мы проанализируем производительность CSS и JavaScript анимаций и сравним их.

## CSS transition и animation

Оба этих свойства могут использоваться для создания анимации. Каждое из них имеет своё специфичное назначение:

- CSS {{cssxref("transition","transitions")}} предоставляет простой способ создать анимацию, которая происходит при переходе от текущего состояния к конечному, например, переход от обычной кнопки к кнопке в состоянии hover. Даже если элемент в середине перехода от одного стиля к другому, новый эффект transition стартует немедленно, вместо того, чтобы дожидаться, пока запущенный ранее эффект завершится. Подробнее здесь: [Использование CSS transitions](/ru/docs/Web/Guide/CSS/Using_CSS_transitions).
- CSS {{cssxref("animation","animations")}}, с другой стороны, позволяет разработчикам создавать анимацию, основанную на ключевых кадрах (keyframes), которые указывают этапы, которые должна пройти анимация от начального до финального состояния. CSS animation состоит из двух компонент: описание свойства, которое указывает на анимацию, а так же набор ключевых кадров, которые указывают начальное, финальное и промежуточные состояния элемента. Подробнее здесь: [Использование CSS animations](/ru/docs/Web/Guide/CSS/Using_CSS_animations).

Если говорить о производительности - между этими двумя подходами нет разницы. Оба подхода основаны на одном и том же механизме, которые описаны далее.

## requestAnimationFrame

API {{domxref("Window.requestAnimationFrame","requestAnimationFrame()")}} предоставляет эффективный способ создания анимаций в JavaScript. Функция (callback), которую вы передаёте в этот метод, будет вызываться перед каждой следующей отрисовкой нового фрейма. Главное отличие от {{domxref("WindowTimers.setTimeout","setTimeout()")}}/{{domxref("WindowTimers.setInterval","setInterval()")}} в том, что здесь вам не нужно указывать время, через которое функция запустится. `requestAnimationFrame()` работает гораздо эффективнее, учитывая частоту кадров и производительность системы. Разработчики могут создавать анимацию, просто изменяя стили элемента каждый раз, когда происходит подготовка нового кадра (или когда обновляется полотно Canvas или в других случаях).

> [!NOTE]
> Подобно CSS-анимациям, `requestAnimationFrame()` приостанавливает работу, когда текущий таб браузера переводится в фоновый режим.

Для подробностей ознакомьтесь с [анимирование с JavaScript: от setinterval до requestAnimationFrame](https://hacks.mozilla.org/2011/08/animating-with-javascript-from-setinterval-to-requestanimationframe/).

## Сравнение производительности:<br>transitions и requestAnimationFrame

По факту, в большинстве случаев, производительность анимаций CSS практически идентична анимациям на JavaScript. По крайней мере в Firefox. Авторы некоторых JavaScript библиотек для анимации, например GSAP или Velocity.JS, даже берутся утверждать, что их решения могут работать быстрее, чем аналогичные решения на CSS. Такое возможно, потому что CSS transitions/animations просто заново вычисляют стили элементов в основном потоке процессора сразу перед тем, как срабатывает событие repaint, что примерно то же самое, что вычислять стили заново с помощью `requestAnimationFrame()`. Если обе анимации выполняются в одном потоке, то разницы в производительности не будет.

В следующей секции мы пройдёмся по тестам производительности, используя Firefox, чтобы увидеть, какие методы анимации работают эффективнее.

### Включение измерения частоты кадров FPS

Для начала нам нужно включить инструменты измерения частоты кадров (FPS Tools), чтобы иметь возможность видеть текущую частоту кадров

1. В поле ввода URL наберите _about:config_; Нажмите на кнопку _I'll be careful, I promise!, чтобы войти на страницу конфигурации_.
   ![](pic1.png)

2. В поле поиска введите `layers.acceleration.draw-fps`.
3. Нажмите два раза на ячейку, чтобы присвоить значение `true`. Теперь вы видите три розовых блока в верхнем левом углу окна. Первый блок указывает FPS.
   ![](pic2.png)

### Запуск теста

Для начала, в нашем тесте мы будем анимировать 1000 элементов {{htmlelement("div")}} с помощью CSS.

{{JSFiddleEmbed("https://jsfiddle.net/zt94oew2/1/","","480")}}

Нажав на кнопку, вы можете переключить метод анимации на `requestAnimationFrame()`.

Попробуйте запустить оба метода и сравнить FPS. Скорее всего, вы увидите, что частота кадров отличается - анимации с CSS заметно быстрее. В следующей главе мы разберём - почему.

### Анимация вне основного потока процесса

Браузерный JavaScript является строго однопоточным языком, то есть он не может одновременно работать над двумя задачами. В этом кроется проблема анимации с помощью JavaScript. Выполняя такую анимацию, вы занимаете процессор, который мог бы в это время заниматься другими функциями. В противоположность этому, CSS-анимации могут быть выделены в отдельный поток, то есть при выполнении таких анимаций браузер не блокирует выполнение других процессов.

Для того, чтобы выделить анимацию CSS в отдельный процесс, нам нужно убедиться, что изменяемые свойства не запускают этапы reflow/repaint (подробнее здесь: [CSS triggers](http://csstriggers.com/)). Если изменяемые CSS-свойства не делают этого, то мы можем вынести операции по вычислению стилей в отдельный поток. Наиболее известное свойство - это CSS Transform, которое выводит элемент в отдельный [слой](https://wiki.mozilla.org/Gecko:Overview#Graphics). Если элемент представляет из себя отдельный слой, то вычисление каждого следующего кадра может быть сделано на графическом процессоре (GPU). Это радикально улучшает производительность, особенно на мобильных устройства. Подробности здесь: [OffMainThreadCompositing](https://wiki.mozilla.org/Platform/GFX/OffMainThreadCompositing).

Вы можете отключить выведение анимации в отдельный поток, чтобы посмотреть, как эта особенность влияет на FPS. Для этого в настройках Firefox найдите флаг `layers.offmainthreadcomposition.async-animations`. И переключите его в `false`.

![](pic3.png)

После выключения этой опции вы увидите, что FPS при использовании CSS стал таким же, как и при использовании JS.

## Итог

Браузеры способы оптимизировать рендеринг не только программно, но и аппаратно. В целом, вам нужно стараться использовать CSS transitions/animations везде, где это возможно. Если же ваши анимации действительно сложны - помните, что писать анимацию на JavaScript нужно только с использованием `requestAnimationFrame()` .
