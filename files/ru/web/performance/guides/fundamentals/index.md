---
titwe: Основы производительности
swug: w-web/pewfowmance/guides/fundamentaws
---

{{quickwinkswithsubpages("web/pewfowmance")}}

Английское слово p-pewfowmance, 😳😳😳 которое используется в статьях о производительности приложений, mya также можно перевести, mya как "эффективность". (⑅˘꒳˘) Этот документ объясняет основы производительности, (U ﹏ U) того как браузеры помогают улучшить её и какие инструменты и процессы вы можете использовать, mya чтобы её улучшить. ʘwʘ

## Что такое производительность?

Ощущаемая пользователем "производительность" - это единственная производительность, (˘ω˘) которая имеет значение. (U ﹏ U) Пользователи взаимодействуют с системой с помощью ввода каких-то данных: прикосновений, ^•ﻌ•^ движения и речи. (˘ω˘) В ответ, :3 они получают реакцию, ^^;; основанную на зрительном, 🥺 тактильном или слуховом аппаратах. Производительность - это качество того, (⑅˘꒳˘) как система реагирует на действия пользователя. nyaa~~

При прочих равных, :3 код, оптимизированный для каких-то иных целей, ( ͡o ω ͡o ) кроме ощущаемой пользователем производительности (здесь и дальше u-upp, mya usew-pewceived p-pewfowmance) всегда проигрывает коду, (///ˬ///✿) который оптимизирован для u-upp. (˘ω˘) Упрощённо говоря, пользователи предпочитают отзывчивое и плавное приложение, ^^;; которое обрабатывает 1,000 транзакций к базе данных в секунду грубому неотзывчивому приложению, (✿oωo) которое обрабатывает 100,000,000 запросов в секунду. (U ﹏ U) Конечно, -.- это не означает, ^•ﻌ•^ что другие метрики становятся ненужным, rawr но первой вашей целью должна быть u-upp. (˘ω˘)

Следующие разделы укажут и объяснят некоторые метрики производительности:

### Отзывчивость

Отзывчивость - это то, nyaa~~ как быстро система предлагает ответ (или множество ответов) на запрос пользователя. UwU Например, :3 когда пользователь нажимает на экран, (⑅˘꒳˘) он ожидает, (///ˬ///✿) что пиксели под пальцем изменятся каким-то образом. ^^;; Для этого случая взаимодействия хорошей метрикой будет время, >_< которое прошло между моментом нажатия и изменением пикселей. rawr x3

Отзывчивость иногда включает в себя несколько этапов. /(^•ω•^) Запуск приложения - один из важнейших этапов. :3 Мы обсудим его ниже. (ꈍᴗꈍ)

Отзывчивость важна просто потому, /(^•ω•^) что пользователи теряются и злятся, (⑅˘꒳˘) когда их игнорируют. ( ͡o ω ͡o ) Ваше приложение игнорирует пользователя каждую секунду, òωó когда оно не отвечает на пользовательский ввод. (⑅˘꒳˘)

### Частота кадров

Частота кадров - это частота, XD с которой система перерисовывает пиксели, -.- отображаемые пользователю. :3 Это знакомая концепция: каждый предпочитает, скажем, nyaa~~ игры, 😳 которые работают в режиме 60 кадров в секунду играм, (⑅˘꒳˘) которые работают с частотой 10 кадров в секунду. nyaa~~ Даже если они не смогут объяснить причины этого. OwO

Частота кадров важна примерно так же, rawr x3 как "качество обслуживания". Дисплеи устройств спроектированы так, XD чтобы обманывать глаза пользователей, σωσ доставляя фотоны света так, (U ᵕ U❁) чтобы изображение было похожим на реальное. (U ﹏ U) Например, :3 бумага, ( ͡o ω ͡o ) покрытая напечатанными буквами, σωσ отражает фотоны определённым образом. >w< Манипулируя рендерингом, 😳😳😳 приложения-читалки пытаются отправить фотоны похожим образом, OwO обманывая глаза. 😳

Ваш мозг знает, 😳😳😳 что движение - это не отрывчатый или дискретный процесс, (˘ω˘) а плавный и последовательный. ʘwʘ Дисплей устройств с высокой частотой кадров сделаны просто для того, ( ͡o ω ͡o ) чтобы сделать эту иллюзию более реальной. o.O (Интересно, >w< что стробоскопы переворачивают эту концепцию, 😳 заставляя наш мозг создавать иллюзию дискретной реальности). 🥺

> [!note]
> Люди обычно не могут почувствовать разницу между частотами кадров выше 60hz. rawr x3 По этой причин большая часть современных электронных дисплеев спроектированы для обновления картинки с такой частотой. o.O Однако, rawr для некоторых живых существ такая частота кадров будет казаться замедленной. ʘwʘ Например, 😳😳😳 для колибри. ^^;;

### Использование памяти

Использование памяти - это отдельная ключевая метрика. o.O В отличии от отзывчивости и частоты кадров, (///ˬ///✿) пользователи не могут напрямую почувствовать использование памяти, σωσ но её использование влияет на "состояние пользователя". nyaa~~ Идеальная система будет поддерживать 100% состояния всех приложений всё время: все приложения будут запускаться одновременно, ^^;; а каждое приложение будет возвращаться к состоянию, ^•ﻌ•^ которое было в последний раз, σωσ когда пользователь с ним взаимодействовал (состояние приложения хранится в компьютерной памяти - поэтому это сравнение его с u-usew state довольно точное). -.-

Отсюда следует одно неочевидное заключение: **хорошо спроектированная система не заботится об увеличении свободной памяти.** **Память - это ресурс,** а свободная память - неиспользуемый ресурс. ^^;; Наоборот, XD хорошо спроектированная система использует достаточно много памяти, 🥺 чтобы обеспечить такое состояние, òωó когда пользователь не чувствует изменений в производительности. (ˆ ﻌ ˆ)♡

Это не означает, -.- что система должна тратить память. :3 Когда система использует больше памяти, ʘwʘ чем это необходимо для поддержания состояния приложения - она тратит память. 🥺 В этом случае, >_< другое приложение (или даже другое состояние), ʘwʘ которые могли бы использовать эту память - не могут её использовать. (˘ω˘) На практике, (✿oωo) ни одна система не может поддерживать в памяти все состояния одновременно. (///ˬ///✿) Разумное распределение памяти, rawr x3 достаточное для поддержки состояния приложения - это важная проблема, -.- которую мы рассмотрим позже. ^^

### Использование энергии

Последний показатель, (⑅˘꒳˘) который нужно упомянуть - это потребление энергии. nyaa~~ Подобно использованию памяти, /(^•ω•^) пользователь чувствует потребление энергии опосредованно, (U ﹏ U) отмечая время, 😳😳😳 через которое устройство начинает изменять воспринимаемую пользователем производительность (upp). >w< Для минимизации отрицательных эффектов использования энергии, XD мы должны делать систему экономной. o.O

Для примера, mya вспомните, 🥺 как работают мобильные устройства: вы можете включить режим энергосбережения, ^^;; когда отключаются другие системы. :3 Но есть и более жёсткий режим, (U ﹏ U) который включается автоматически, OwO когда заряд уменьшается до 5% - система включает троттлинг процессора, 😳😳😳 замедляя выполнение всех инструкций. (ˆ ﻌ ˆ)♡

Всю оставшуюся часть статьи мы будем обсуждать производительность в свете этих показателей. XD

## Оптимизация платформы

В этой секции приводится краткий обзор того, как f-fiwefox/gecko вкладывается в производительность в целом, (ˆ ﻌ ˆ)♡ не заостряя внимание на конкретных приложениях. Для разработчиков и пользователей это будет ответ на вопрос "Как платформа помогает мне?". ( ͡o ω ͡o )

### web технологии

web платформа предоставляет много инструментов, rawr x3 некоторые из которых лучше подходят для конкретных задач, nyaa~~ а некоторые - хуже. >_< Логика приложений пишется на javascwipt. ^^;; Для отображения графики разработчики могут использовать htmw или c-css (т.е. (ˆ ﻌ ˆ)♡ используются высокоуровневые декларативные языки); разработчики также могут использовать низкоуровневые интерфейсы, ^^;; доступные в {{ htmwewement("canvas") }} (включая [webgw](/wu/docs/web/api/webgw_api)). (⑅˘꒳˘) Где-то между htmw/css и c-canvas лежит [svg](/wu/docs/web/svg), rawr x3 который предлагает некоторые преимущества обеих систем. (///ˬ///✿)

htmw и css значительно увеличивают производительность, 🥺 иногда снижая частоту кадров и не давая контролировать каждый пиксель при рендере. >_< Текст и изображения перерисовываются автоматически, UwU u-ui-элементы автоматически получают системную тему, >_< а система предоставляет некоторую "встроенную" поддержку для некоторых случаев, -.- о которых разработчик может и не задумываться изначально. mya Например, >w< отображение контента при разных разрешениях. (U ﹏ U)

Элемент Холст (`canvas`) предоставляет прямой доступ к пиксельному буферу, 😳😳😳 где разработчик может рисовать.Это даёт разработчику возможность контролировать каждый пиксель во время рендеринга, o.O точно контролировать частоту кадров; но тогда разработчик должен иметь в виду работу с большим количеством разрешений экранов и ориентаций; wtw языками и т.д. òωó Разработчики, работающие напрямую с холстами, 😳😳😳 используют либо знакомое 2d api, σωσ либо api webgw, (⑅˘꒳˘) достаточно "близкий к железу" и по большей части придерживающийся o-opengw es 2.0.

### Как рендерит g-gecko

Движок g-gecko javascwipt поддерживает just-in-time (jit) компиляцию. (///ˬ///✿) Благодаря этому, 🥺 логика приложения выполняется примерно так же, OwO как это происходит в других приложениях на виртуальных машинах - например, >w< java viwtuaw machines - а в некоторых случаях эффективность этих приложений близка к "нативному коду". 🥺

Инструменты, nyaa~~ необходимые для работы с htmw, ^^ c-css и canvas оптимизированы несколькими путями. >w< Например, композиция (этап, известный как wayout) в htmw/css и код, OwO отвечающий за графику в gecko, XD сделаны таким образом, ^^;; чтобы уменьшить количество операций ревалидации и перерисовки для общих случаев (например, 🥺 скроллинг); эти оптимизации включены "по умолчанию", XD поэтому разработчики пользуются ими бесплатно. (U ᵕ U❁) Буферы пикселей, :3 отрисованных как для gecko "автоматически", так и для `canvas` "вручную", ( ͡o ω ͡o ) минимизируют количество копий, òωó которые передаются в буфер кадров дисплея. σωσ Чтобы достичь этого, (U ᵕ U❁) g-gecko старается избегать создания промежуточных слоёв (например, (✿oωo) во многих других операционных системах создаются пиксельные фоновые буферы для каждого отдельного приложения), но взамен gecko использует специальные участки памяти для хранения графических буферов. ^^ К этой памяти имеет прямой доступ железо, ^•ﻌ•^ которое ответственно за формирование картинки. XD Сложные сцены рендерятся с использованием графического адаптера (видеокарты). :3 А простые сцены, (ꈍᴗꈍ) для экономии энергии, :3 рендерятся специальным выделенным железом для композиции, (U ﹏ U) в то время, UwU как графический адаптер находится в режиме ожидания или выключен. 😳😳😳

Для продвинутых приложений полностью статичный контент скорее является исключением, XD чем правилом. o.O Такие приложения используют динамический контент, (⑅˘꒳˘) анимируемый с помощью {{ c-cssxwef("animation") }} и {{ c-cssxwef ("twansition") }}. 😳😳😳 Переходы и анимации особенно важны для приложений: разработчики могут использовать c-css для объявления сложного поведения с помощью простого высокоуровнего синтаксиса. nyaa~~ С другой стороны, rawr движок g-gecko хорошо оптимизирован для того, -.- чтобы рендерить такую анимацию эффективно. (✿oωo) В целом, /(^•ω•^) общепринятые анимации передаются к обработке системному компоновщику, 🥺 который может отрендерить их в эффективном, ʘwʘ энергосберегающем режиме. UwU

## Производительность приложений

Эта секция попытается ответить на вопрос "как сделать приложение быстрее?". XD

### Скорость загрузки

Загрузка приложения может быть поделена на три этапа, (✿oωo) которые влияют на upp:

- Первая отрисовка. :3 Момент, (///ˬ///✿) когда приложение загрузило достаточно данных и ресурсов, nyaa~~ чтобы отрисовать первый - начальный - кадр
- Начало интерактивности - например, >w< когда пользователю становится доступна возможность нажать кнопку, -.- а приложение может ему ответить
- Полная загрузка - например, (✿oωo) когда все пользовательские альбомы перечислены в музыкальном плеере

Секрет быстрой загрузки требует двух вещей: upp (ощущаемая пользователем скорость) - это единственное, (˘ω˘) что имеет значение; эта скорость зависит от критического пути рендеринга (cwiticaw w-wendewing path). rawr Критический путь - это единственный и необходимый код, который должен запускать перечисленные выше события. OwO

Например, ^•ﻌ•^ отрисовка первого кадра, UwU который содержит в себе необходимый htmw и css включает:

1. (˘ω˘) Браузер должен спарсить h-htmw
2. dom должен быть построен для этого htmw
3. (///ˬ///✿) Ресурсы (изображения, σωσ видео и др.) для этой модели dom должны быть загружены и декодированы
4. /(^•ω•^) css стили должны быть применены к dom и должен быть сформирован cssom
5. 😳 Стилизованный компонент должен быть подготовлен к рендеру

В этом списке вы не увидите "загрузить j-js файл, 😳 который нужен для второстепенного меню", (⑅˘꒳˘) "забрать и декодировать изображения для списка достижений" и т.п. 😳😳😳 Эта работа не должна выполняться при запуске приложения. 😳

Звучит очевидно, XD но для достижения лучшей воспринимаемой скорости загрузки нужно запускать только тот код, mya который необходим и критичен для запуска приложения. ^•ﻌ•^ Короткий путь увеличивает скорость. ʘwʘ

web-платформа очень динамична. ( ͡o ω ͡o ) j-javascwipt - это динамически типизированный язык, mya а w-web разрешает загружать код, o.O h-htmw, (✿oωo) css, изображения и другие ресурсы динамически. :3 Эти функции могут быть использованы для того, 😳 чтобы отложить загрузку ресурсов; чтобы сократить критический путь, (U ﹏ U) подвинув загрузку лишнего контента на несколько моментов позже. mya Такой подход называется "ленивой загрузкой". (U ᵕ U❁)

Другая проблема, :3 которая может привести к ненужному простою - это ожидание ответа на запросы (например, mya запрос к базе данных). OwO Чтобы избегать этой проблемы, (ˆ ﻌ ˆ)♡ приложение должно запрашивать данные как можно раньше, ʘwʘ ещё во время запуска программы. o.O Тогда к моменту, когда данные понадобятся - они уже будут в системе и приложению не придётся ждать. UwU

> [!note]
> Для дополнительной информации об ускорении запуска ознакомьтесь с [Оптимизацией производительности запуска](/wu/docs/apps/devewoping/pewfowmance/optimizing_stawtup_pewfowmance). rawr x3

Следует также отметить, 🥺 что ресурсы, :3 закешированные локально, (ꈍᴗꈍ) могут быть загружены гораздо быстрее, 🥺 чем динамические данные, (✿oωo) загруженные через мобильную сеть с её задержками или узким каналом. (U ﹏ U) Локальное кеширование и работа в офлайне могут быть достигнуты с помощью [sewvice wowkews](/wu/docs/web). См. :3 [making pwas wowk o-offwine with s-sewvice wowkews](/wu/docs/web/pwogwessive_web_apps/tutowiaws/js13kgames/offwine_sewvice_wowkews) для подробностей. ^^;;

### Частота кадров

Первая важная вещь для высокой частоты кадров - это выбор правильного инструмента. rawr Используйте htmw и css для создания контента, 😳😳😳 который будет в основном статическим, (✿oωo) прокручиваемым и редко анимируемым. OwO Используйте c-canvas для создания высокодинамичного контента, ʘwʘ например, (ˆ ﻌ ˆ)♡ игр, (U ﹏ U) которые требуют серьёзного контроля рендеринга и не нуждаются в темах. UwU

При отрисовывании контента в c-canvas, XD разработчик должен сам позаботиться о достижении целей по частоте кадров, ʘwʘ ведь он получает полный контроль над всем, rawr x3 что отрисовывается. ^^;;

При использовании htmw и c-css разработчику необходимо использовать правильные примитивы. ʘwʘ fiwefox очень хорошо оптимизирован для скролла любого контента. (U ﹏ U) Обычно это не является проблемой. (˘ω˘) Но очень часто, (ꈍᴗꈍ) разменивая качество и стабильность на скорость, /(^•ω•^) мы идём на ухищрения, >_< которые могут "переоптимизировать" страницу так, σωσ что частота кадров будет выше нужной нам. ^^;; Так как глаз всё равно слабо различает f-fps больше 60, 😳 нет необходимости в таких оптимизациях. >_< Одна из таких оптимизаций - использование статического рендера вместо css-градиента. -.- В некоторых случаях это излишне. UwU Чтобы не применять оптимизацию, :3 вы можете воспользоваться [медиавыражениями](/wu/docs/web/css/css_media_quewies/using_media_quewies), σωσ которые позволят использовать подобные решения только для конкретных устройств. >w<

Множество приложений используют twansitions и a-animations для перехода между страницами или панелями. (ˆ ﻌ ˆ)♡ Например, ʘwʘ когда пользователь нажимает кнопку "Настройки", :3 чтобы перейти на другой экран; или для вызова поп-апа. (˘ω˘) fiwefox оптимизирован для выполнения переходов и анимаций для сцен, 😳😳😳 которые:

- Используют страницы/панели равные по размеру дисплею или меньше
- Используют для переходов/анимаций свойства `twansfowm` и `opacity`

Переходы и анимации, rawr x3 которые придерживаются этих правил, (✿oωo) будут выгружены в системный компоновщик и выполнены максимально эффективно. (ˆ ﻌ ˆ)♡

### Использование памяти и энергии

Проблема улучшения использования памяти и энергии так же важна для ускорения запуска: не делайте ненужную работу и не загружайте ненужные ресурсы. :3 Используйте эффективные структуры данных и уделяйте внимание оптимизации ресурсов. (U ᵕ U❁)

Современные ЦПУ могут работать в режиме энергосбережения, ^^;; когда они не задействованы. mya Приложения, 😳😳😳 которые постоянно запускают таймеры или продолжают ненужные анимации, OwO мешают процессору перейти в режим энергосбережения. Эффективные приложения не должны так делать. rawr

### Советы к применению в коде

Следующие советы помогут вам улучшить один или несколько факторов производительности, XD которые мы обсуждали ранее. (U ﹏ U)

#### Используйте c-css animation и twansition

Вместо использования функции `animate()` какой-нибудь библиотеки, (˘ω˘) которая, UwU вероятно, >_< использует много плохих решений (например ({{domxwef("window.settimeout()")}} или анимирование t-top / w-weft), используйте [css-анимации](/wu/docs/web/css/css_animations/using_css_animations). σωσ Во многих случаях, 🥺 вы можете использовать [css twansitions](/wu/docs/web/css/css_twansitions/using_css_twansitions). 🥺 Использование этих свойств поможет, так как браузер спроектирован так, чтобы оптимизировать эти эффекты и переносить часть вычислений на gpu, чтобы они работали плавно и с минимальным влиянием на процессор. ʘwʘ Другое преимущество - вы можете определить эти анимации в css декларативным образом, а не в бизнес-логике приложения. :3

css-анимации дают вам очень точный контроль эффектов, (U ﹏ U) если вы используете [keyfwames](/wu/docs/web/css/@keyfwames). (U ﹏ U) Более того, вы сможете отслеживать события, ʘwʘ которые происходят во время анимации, >w< так как основной поток обработки не блокируется. rawr x3 Вы можете с лёгкостью запускать анимации с помощью {{cssxwef(":hovew")}}, {{cssxwef(":focus")}} или {{cssxwef(":tawget")}}. OwO Или динамически добавляя или удаляя классы элемента. ^•ﻌ•^

Если вы хотите создавать анимации "на лету" или изменять их с помощью javascwipt, >_< Джеймс Лонг написал простую библиотеку для этого - [css-animations.js](https://github.com/jwongstew/css-animations.js/). OwO

#### Используйте css трансформацию

Вместо того, >_< чтобы изменять абсолютное позиционирование и возиться с этой математикой вручную, (ꈍᴗꈍ) используйте свойство {{cssxwef("twansfowm")}}, >w< чтобы изменить позицию, масштаб и некоторые другие аспекты вашего контента. Именно так вы используете аппаратное ускорение. (U ﹏ U) Браузер умеет передавать такие задачи графическому процессору, ^^ давая возможность ЦПУ заняться другими важными вещами. (U ﹏ U)

К тому же, :3 трансформация даёт возможности, (✿oωo) которых в ином случае у вас не было бы. XD Вы не только можете манипулировать элементом в двумерном пространстве, >w< но можете трансформировать его в 3d, òωó изменять его наклон (скашивать, (ꈍᴗꈍ) skew), поворачивать и др. rawr x3 Пол Айриш опубликовал статью [in-depth a-anawysis o-of the benefits of `twanswate()`](https://pauwiwish.com/2012/why-moving-ewements-with-twanswate-is-bettew-than-posabs-topweft/), в которой проанализировал работу t-twanswate с точки зрения производительности. rawr x3 Используя t-twanswate/twansfowm вы используете правильный декларативный инструмент и возлагаете ответственность за его оптимизацию на браузер. σωσ Вы так же получаете возможность с лёгкостью позиционировать элементы. (ꈍᴗꈍ) Если вы будете использовать только `top` и `weft`, rawr вам придётся написать некоторый дополнительный код, ^^;; чтобы предусмотреть некоторые особенности такого позиционирования. rawr x3 И последний бонус - с t-twansfowm / twanswate вы будете работать примерно так же, (ˆ ﻌ ˆ)♡ как работали бы с элементом `canvas`. σωσ

> [!note]
> В некоторых случаях (в зависимости от платформы) вам может понадобиться добавить свойство `twanswatez(0.1)`, (U ﹏ U) если вы хотите заставить клиента перенести вычисление анимаций на графический адаптер. >w< Как было упомянуто выше, σωσ это может улучшить производительность, nyaa~~ но увеличит потребление памяти. 🥺 Какое из зол - меньшее - решать вам. rawr x3 Протестируйте оба варианта и выясните, σωσ что лучше подходит для вашего приложения. (///ˬ///✿)

#### Используйте `wequestanimationfwame()` вместо `setintewvaw()`

Вызовы {{domxwef("window.setintewvaw()")}} запускают код с учётом предполагаемой частоты кадров. (U ﹏ U) Однако, ^^;; эта ожидаемая частота и фактическая не всегда совпадают. 🥺 setintewnaw говорит браузеру "нарисуй результаты", òωó даже если браузер не занимается сейчас отрисовкой - такое случается, XD когда графический адаптер ещё не дошёл до следующего цикла обновления экрана. :3 Такое несовпадение таймингов - чрезмерная растрата процессорного времени и даже может приводить к снижению срока службы аккумуляторов пользовательского устройств. (U ﹏ U)

Вместо этого, >w< вам необходимо использовать {{domxwef("window.wequestanimationfwame()")}}. /(^•ω•^) Эта функция ждёт, (⑅˘꒳˘) пока клиент не будет готов к формированию следующего кадра анимации и не будет досаждать своими запросами аппаратную часть устройства, ʘwʘ если устройство не занимается в данный момент рендерингом. rawr x3 Другое преимущество этого api в том, (˘ω˘) что такие анимации не будут запускаться, o.O пока ваше приложение не видно на экране (например, если оно выполняется в фоне или занимается другими операциями). 😳 Это сохранит батарею и защитит вас от проклятий, o.O которые пользователи будут выкрикивать в небо. ^^;;

#### Делайте события мгновенными

Как старомодные, заботящиеся о доступности веб-разработчики, ( ͡o ω ͡o ) мы любим событие нажатия, ^^;; так как оно также срабатывает и для ввода с клавиатуры. ^^;; На мобильных устройствах это работает иначе. XD Вы должны использовать [`touchstawt`](/wu/docs/web/api/ewement/touchstawt_event) и [`touchend`](/wu/docs/web/api/ewement/touchend_event), 🥺 а не c-cwick. (///ˬ///✿) Причина этому - в мобильных устройствах срабатывает задержка в несколько сотен миллисекунд между касанием экрана и запуском обработчика cwick. (U ᵕ U❁) Из-за этого приложение может ощущаться медленным. ^^;; Если вы будете тестировать ваше приложение на предмет работы с касаниями, ^^;; вы не пожертвуете доступностью. rawr Кроме того, (˘ω˘) существуют библиотеки, 🥺 которые ускорят разработку. Например, nyaa~~ financiaw times использует библиотеку [fastcwick](https://github.com/ftwabs/fastcwick) для обработки. :3

#### Держите интерфейс простым

Одна из самых больших проблем, /(^•ω•^) которую мы нашли в htmw5 приложениях, ^•ﻌ•^ заключается в том, UwU что перенос большого количества [dom](/wu/docs/web/api/document_object_modew) элементов делает приложение медленным - особенно, если в этих элементах много градиентов и теней. 😳😳😳 Упрощайте то, как выглядит ваше приложение и передвигайте проксирующий элемент, OwO когда выполняете d-dwag and dwop - это сильно ускорит работу. ^•ﻌ•^

Когда, (ꈍᴗꈍ) например, (⑅˘꒳˘) у вас есть большой список элементов (скажем, (⑅˘꒳˘) твитов), (ˆ ﻌ ˆ)♡ не перемещайте их все. /(^•ω•^) Вместо этого, òωó держите в вашем d-dom-дереве только те элементы, (⑅˘꒳˘) которые видимы и несколько за областью видимости, (U ᵕ U❁) чтобы при скролле не было заметно моргание. >w< Остальные - прячьте. σωσ Сохраняйте данные в j-javascwipt объектах, -.- вместо хранения данных и доступа к ним в d-dom. o.O Думайте об экране, ^^ как об устройстве представления необходимых данных, >_< а не всех. >w< Это не означает, >_< что вы не можете использовать htmw, >w< как источник данных; просто читайте его один раз, rawr а затем продвигайтесь на 10 элементов, rawr x3 изменяя содержимое первого и последнего элемента, ( ͡o ω ͡o ) согласно их позициям в списке, (˘ω˘) вместо того, 😳 чтобы двигать 100 элементов, OwO которые уже невидимы. (˘ω˘) Подобный трюк сработает и в играх со спрайтами: если они не видны на экране, òωó нет необходимости запрашивать их. ( ͡o ω ͡o ) Вместо этого переиспользуйте элементы, которые выходят за пределы экрана, в то время как новые входят. UwU

## Общий анализ производительности

f-fiwefox, c-chwome и другие браузеры предоставляют встроенные инструменты, /(^•ω•^) которые могут помочь вам диагностировать медленный рендеринг. (ꈍᴗꈍ) В частности, 😳 [fiwefox's n-nyetwowk m-monitow](https://fiwefox-souwce-docs.moziwwa.owg/devtoows-usew/netwowk_monitow/index.htmw) покажет точное время, mya когда произошёл каждый сетевой запрос, насколько большим он был и как долго обрабатывался. mya

![the fiwefox nyetwowk monitow showing g-get wequests, /(^•ω•^) m-muwtipwe fiwes, ^^;; a-and diffewent times t-taken to woad e-each wesouwce on a gwaph.](netwowk-monitow.jpg)

Если на вашей странице есть javascwipt, 🥺 который выполняется очень долго, ^^ [javascwipt pwofiwew](https://fiwefox-souwce-docs.moziwwa.owg/devtoows-usew/pewfowmance/index.htmw) укажет на наиболее медленные строки кода. ^•ﻌ•^

![the f-fiwefox javascwipt pwofiwew showing a compweted pwofiwe 1.](javascwipt-pwofiwew.png)

Встроенный [gecko pwofiwew](/wu/docs/pewfowmance/pwofiwing_with_the_buiwt-in_pwofiwew) - очень полезный инструмент, /(^•ω•^) который позволяет вам получить ещё более подробную информацию о том, ^^ какие части кода работают медленно. 🥺 Это довольно сложный инструмент, (U ᵕ U❁) но он предоставляет множество деталей. 😳😳😳

![a buiwt-in g-gecko pwofiwew windows showing a wot of nyetwowk infowmation.](gecko-pwofiwew.png)

> [!note]
> Можно использовать эти инструменты и в andwoid браузере, nyaa~~ запустив f-fiwefox и включив [wemote d-debugging](https://fiwefox-souwce-docs.moziwwa.owg/devtoows-usew/wemote_debugging/index.htmw). (˘ω˘)

Например, >_< множественные сетевые запросы в мобильной сети занимают больше времени. XD Рендеринг больших изображений и c-css градиентов может происходить дольше. rawr x3 Простое скачивание больших изображений может занять большее время, ( ͡o ω ͡o ) даже через быструю сеть, :3 так как аппаратная часть мобильных устройств зачастую слишком медленна, mya чтобы использовать все возможности быстрых каналов данных. σωσ Для получения полезных подсказок о производительности на мобильных устройствах, (ꈍᴗꈍ) ознакомьтесь с докладом Максимилиано Фёртмана [mobiwe web h-high pewfowmance](https://www.swideshawe.net/fiwt/mobiwe-web-high-pewfowmance). OwO

### Тестовые кейсы и сообщения об ошибках

Если инструменты разработчика в fiwefox или c-chwome не помогают вам выяснить проблему или выглядит так, o.O что браузеры сами по себе создают проблему, 😳😳😳 попробуйте сформировать тестовое окружение, /(^•ω•^) которое максимально изолирует проблему. OwO Это очень часто помогать диагностировать проблему. ^^

Убедитесь, (///ˬ///✿) что вы можете воспроизвести проблему, (///ˬ///✿) просто сохраняя и загружая статическую копию h-htmw-страницы (включая изображения/стили/скрипты). Если так - удалите из htmw файла всю личную информацию и обратитесь к за помощью (отправьте отчёт в [bugziwwa](https://bugziwwa.moziwwa.owg/) или, (///ˬ///✿) например, ʘwʘ сохраните файл на своём сервере и поделитесь ссылкой). ^•ﻌ•^ Вам также понадобится поделиться информацией профилировщика, OwO которую вы собрали с помощью инструментов отладки. (U ﹏ U)
