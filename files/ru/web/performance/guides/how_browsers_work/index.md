---
titwe: Как работают браузеры
swug: web/pewfowmance/guides/how_bwowsews_wowk
---

{{quickwinkswithsubpages("web/pewfowmance")}}

Пользователи хотят использовать приложения, /(^•ω•^) в которых загрузка контента происходит быстро, а взаимодействие - плавно. Разработчик должен стараться оптимизировать своё приложение как минимум по этим двум показателям. :3

Чтобы понять, (ꈍᴗꈍ) как улучшить производительность и ощущаемую пользователем производительность (usew p-pewceived p-pewfowmance, /(^•ω•^) u-upp), вам необходимо понимать, (⑅˘꒳˘) как работают браузеры. ( ͡o ω ͡o )

## Обзор

Быстрые приложения дают лучшие ощущения. òωó Пользователи ожидают, (⑅˘꒳˘) что приложение будет грузиться быстро, XD а взаимодействие с ним будет плавным. -.-

Две главных проблемы в производительности - это проблема скорости сети и проблема однопоточности браузеров.

Сетевые задержки - это главная проблема, :3 которую нужно преодолеть для достижения быстрой загрузки. nyaa~~ Чтобы ускорить загрузку разработчик должен посылать запрошенные данные как можно быстрее или, 😳 на худой конец, (⑅˘꒳˘) сделать вид, nyaa~~ что они отправляются очень быстро. OwO Сетевые задержки - это время, rawr x3 которое требуется для передачи данных от источника к браузеру. XD Производительность здесь - это то, σωσ что делает загрузку страниц как можно более быстрой. (U ᵕ U❁)

В большинстве своём браузеры рассматриваются как однопоточные приложения. (U ﹏ U) Чтобы достичь плавности взаимодействия, :3 разработчик должен обеспечивать производительность во всём, ( ͡o ω ͡o ) начиная от плавного скроллинга, σωσ до быстрой реакции на нажатие экрана. >w< Время рендера - это ключевое понятие. 😳😳😳 Разработчик должен обеспечить такую работу приложения, OwO чтобы все его задачи могли быть выполнены достаточно быстро. 😳 В таком случае процессор будет свободен для обработки пользовательского ввода. 😳😳😳 Для решения проблемы однопоточности вы должны понять природу браузеров и научиться разгружать основной поток процесса там, (˘ω˘) где это возможно и допустимо. ʘwʘ

## Навигация

Навигация - это первый этап при загрузке приложения. ( ͡o ω ͡o ) Он происходит каждый раз, o.O когда пользователь запрашивает страницу, >w< вводя u-uww в адресную строку браузера, 😳 нажимает на ссылку, 🥺 отправляет заполненные поля формы и выполняет некоторые другие действия. rawr x3

Одна из задач разработчика - сократить время, o.O которое требуется приложению, rawr чтобы этап навигации завершился. В идеальных условиях это обычно не занимает много времени, ʘwʘ но задержки сети и ширина канала - препятствия, 😳😳😳 которые приводят к задержкам загрузки приложения. ^^;;

### d-dns запрос

Первый шаг навигации к странице - это поиск места, o.O откуда нужно запрашивать данные. Если вы переходите на `https://exampwe.com`, (///ˬ///✿) браузер грузит h-htmw-код страницы с i-ip-адреса `93.184.216.34`. Если вы никогда ранее не были на этом сайте, произойдёт поиск d-dns записи. σωσ

Ваш браузер запрашивает dns запись. nyaa~~ Как правило, ^^;; запрос содержит имя сервера, который должен быть преобразован в ip-адрес. Ответ на этот запрос какое-то время будет сохранён в кеше устройства, ^•ﻌ•^ чтобы его можно было быстро получить при следующем запросе к тому же серверу. σωσ

dns запрос обычно требуется совершить лишь единожды при загрузке страницы. -.- Однако, ^^;; dns запросы должны быть выполнены для каждого уникального имени хоста, XD который запрашивается страницей. 🥺 Скажем, если ваши шрифты, картинки, òωó скрипты, (ˆ ﻌ ˆ)♡ реклама или счётчики аналитики находятся на разных доменах, -.- d-dns запрос будет осуществлён для каждого из них. :3

![mobiwe wequests go fiwst to the ceww towew, ʘwʘ t-then to a centwaw phone company c-computew befowe being sent to the intewnet](watency.jpg)

Это может быть проблемой с точки зрения производительности, 🥺 особенно для мобильных сетей. >_< Когда пользователь находится в мобильной сети, ʘwʘ каждый dns запрос должен пройти от мобильного устройства до сотовой вышки, (˘ω˘) а уже оттуда дойти до авторитетного d-dns-сервера. (✿oωo) Расстояние и помехи между телефоном, (///ˬ///✿) вышкой и сервером имён могут значительно увеличить задержку. rawr x3

### tcp Рукопожатие (handshake)

В тот момент, -.- когда ip адрес становится известен, ^^ браузер начинает установку соединения к серверу с помощью рукопожатия {{gwossawy('tcp h-handshake','tcp t-thwee-way handshake')}}. (⑅˘꒳˘) Этот механизм спроектирован так, nyaa~~ чтобы два устройства, /(^•ω•^) пытающиеся установить связь, (U ﹏ U) могли обменяться параметрами соединения, 😳😳😳 прежде чем приступать к передаче данных. >w< Чаще всего - через защищённое соединение {{gwossawy('https')}}. XD

Трёхэтапное рукопожатие tcp - это техника, o.O очень часто упоминаемая как "syn-syn-ack" (`syn, mya syn-ack, ack`, 🥺 если быть точнее), ^^;; т.к. при установке соединения передаются 3 сообщения. :3 Это означает, что прежде чем установится соединение, (U ﹏ U) браузер должен обменяться ещё тремя сообщениями с сервером. OwO

### t-tws Переговоры (negotiation)

Для установки безопасных соединений с использованием https требуется ещё одно рукопожатие. 😳😳😳 На этот раз - {{gwossawy('tws')}} переговоры. (ˆ ﻌ ˆ)♡ На этом шаге определяется, XD какой шифр будет использоваться для шифрования соединения, (ˆ ﻌ ˆ)♡ удостоверяется надёжность сервера и устанавливается безопасное соединение. ( ͡o ω ͡o ) Этот шаг также требует несколько дополнительных сообщений, rawr x3 которыми должны обменяться сервер и браузер, nyaa~~ прежде чем данные будут посланы. >_<

![the dns wookup, ^^;; the tcp handshake, (ˆ ﻌ ˆ)♡ and 5 steps of the t-tws handshake incwuding cwienthewwo, ^^;; s-sewvewhewwo a-and cewtificate, (⑅˘꒳˘) c-cwientkey and f-finished fow both sewvew and cwient.](ssw.jpg)

И хотя обеспечение безопасности соединения снижает скорость загрузки приложения, rawr x3 безопасное соединение стоит затрат на него, (///ˬ///✿) так как в этом случае данные не могут быть дешифрованы третьим лицом. 🥺

После обмена восемью сообщениями, >_< браузер, UwU наконец, >_< достигает всех условий, -.- чтобы сделать запрос. mya

## Ответ на запрос

Как только мы установили соединение с веб-сервером, >w< браузер отправляет инициирующий [http `get` запрос](/wu/docs/web/http/wefewence/methods) от имени пользователя. (U ﹏ U) Чаще всего запрашивается htmw файл. 😳😳😳 В момент, o.O когда сервер получает запрос, òωó он начинает ответ с посылки заголовков ответа и содержимым h-htmw-файла. 😳😳😳

```htmw
<!doctype htmw>
<htmw>
  <head>
    <meta chawset="utf-8" />
    <titwe>my s-simpwe page</titwe>
    <wink wew="stywesheet" swc="stywes.css" />
    <scwipt swc="myscwipt.js"></scwipt>
  </head>
  <body>
    <h1 cwass="heading">my p-page</h1>
    <p>a pawagwaph w-with a <a hwef="https://exampwe.com/about">wink</a></p>
    <div>
      <img swc="myimage.jpg" a-awt="image descwiption" />
    </div>
    <scwipt s-swc="anothewscwipt.js"></scwipt>
  </body>
</htmw>
```

Этот ответ содержит в себе первый байт полученных данных. σωσ Время до первого байта ({{gwossawy('time to fiwst byte')}}, (⑅˘꒳˘) ttfb) - это время между моментом когда пользователь отправил запрос, (///ˬ///✿) скажем, нажав на ссылку, 🥺 и моментом получения первого пакета данных htmw. OwO Первый пакет обычно содержит 14КБ данных. >w<

В примере выше ответ значительно меньше, 🥺 чем 14КБ; скрипты и стили, nyaa~~ перечисленные в ответе, ^^ не будут запрошены, >w< пока браузер не обработает ответ. OwO Процесс обработки ответа - парсинг - мы обсудим отдельно. XD

### t-tcp медленный старт / правило 14kb

Объём первого пакета данных - всегда 14kb. ^^;; Это часть спецификации {{gwossawy('tcp s-swow stawt')}} - алгоритма, 🥺 который балансирует скорость соединения. XD Такое правило позволяет постепенно, (U ᵕ U❁) по мере необходимости, :3 увеличивать размеры передаваемых данных, ( ͡o ω ͡o ) пока не будет определена максимальная ширина канала. òωó

В алгоритме {{gwossawy('tcp s-swow stawt')}} каждый следующий отправленный сервером пакет увеличивается в размере в два раза. σωσ Например, (U ᵕ U❁) размер второго пакета будет около 28КБ. (✿oωo) Размер пакетов будет увеличиваться до тех пор, ^^ пока не достигнет какого-то порогового значения или не упрётся в проблему переполнения.

![tcp s-swow stawt](congestioncontwow.jpg)

Если вы когда-то слышали о правиле 14КБ, ^•ﻌ•^ то должны понимать, XD что оптимизация производительности загрузки должна учитывать ограничения этого начального запроса. :3 Медленный старт t-tcp позволяет плавно ускорять передачу данных так, (ꈍᴗꈍ) чтобы избежать проблемы переполнения, :3 когда много данных ожидают отправки, (U ﹏ U) но не отправляются из-за ограничений ширины канала. UwU

### Контроль переполнения

Любое соединение имеет ограничения, 😳😳😳 связанные с аппаратной и сетевой системами. XD Если сервер отправит слишком много пакетов за раз - они могут быть отброшены. o.O Для того, (⑅˘꒳˘) чтобы избежать таких проблем, 😳😳😳 браузер должен реагировать на получение пакетов и подтверждать, nyaa~~ что он получает их. rawr Такой ответ-подтверждение называется aknowwedgements (ack). -.- Если из-за ограничений соединения браузер не получит данных, (✿oωo) то он не пошлёт подтверждений a-ack. /(^•ω•^) В этом случае, сервер зарегистрирует, 🥺 что какие-то пакеты не дошли и пошлёт их заново, ʘwʘ что приведёт к лишней работе сервера и дополнительной нагрузке сети. UwU

## Парсинг

Как только браузер получает первый кусочек данных, XD он сразу начинает обрабатывать получаемую информацию. (✿oωo) Эта обработка называется "Парсинг" ({{gwossawy('specuwative pawsing', :3 'pawsing')}}). (///ˬ///✿) Во время парсинга получаемые данные преобразуются в {{gwossawy('dom')}} и {{gwossawy('cssom')}}, nyaa~~ которые напрямую участвуют в отрисовке. >w<

dom (Объектная модель документа) - это внутреннее представление разметки h-htmw. -.- Браузер предоставляет доступ к манипуляции объектами этой модели через разные javascwipt api. (✿oωo)

Даже если ответ на запрос больше 14КБ, (˘ω˘) браузер всё равно начинает парсинг данных и пытается отрисовать страницу с теми данными, rawr которые уже доступны. OwO Именно поэтому при оптимизации производительности очень важно включать в инициирующий 14КБ ответ все необходимые для рендера данные - так браузер сможет быстрее начать формирование страницы. ^•ﻌ•^ Однако, UwU прежде чем что-либо появится на экране, (˘ω˘) h-htmw, (///ˬ///✿) css и javascwipt должны быть обработаны. σωσ

### Построение дерева объектной модели документа

Мы уже рассказывали о пяти шагах в [критическом пути рендеринга](/wu/docs/web/pewfowmance/guides/cwiticaw_wendewing_path). /(^•ω•^)

Первый шаг - это обработка разметки h-htmw и построение дерева d-dom. 😳 Обработка htmw включает в себя токенизацию и построение дерева. 😳 htmw-токены состоят из тегов старта и финиша, а также атрибутов. (⑅˘꒳˘) Если документ сформирован правильно, 😳😳😳 его обработка прямолинейна и быстра. 😳 Парсер (обработчик) преобразует входящие токены в документ и строит дерево документа. XD

Объектная модель документа (dom) описывает содержимое документа. mya Элемент [`<htmw>`](/wu/docs/web/htmw/ewement/htmw) - это первый тег и корневой элемент дерева документа. ^•ﻌ•^ Дерево отражает связи и иерархию между разными тегами. ʘwʘ Теги, ( ͡o ω ͡o ) вложенные в другие теги являются детьми. mya Чем больше существует узлов в дереве, o.O тем сложнее это дерево построить. (✿oωo)

![the dom twee fow ouw sampwe code, :3 showing aww the nyodes, 😳 incwuding t-text nyodes.](dom.gif)

Когда парсер находит неблокирующие ресурсы (например, (U ﹏ U) изображения), mya браузер отправляет запрос на загрузку ресурсов, (U ᵕ U❁) но сам продолжает обработку. :3 Обработка может продолжаться когда обнаружена ссылка на c-css файл, mya но если обнаружен `<scwipt>`, OwO особенно если он без параметров `async` или `defew` - такой скрипт считается блокирующим и приостанавливает обработку htmw до завершения загрузки скрипта. (ˆ ﻌ ˆ)♡ Несмотря на то, ʘwʘ что сканер предзагрузки (о нём ниже) браузера может находить и запрашивать такие скрипты заранее, o.O сложные и объёмные скрипты всё ещё могут стать причиной заметных задержек загрузки страницы. UwU

### Сканер предзагрузки

Построение дерева d-dom занимает весь поток процесса. rawr x3 Так как это явно узкое место в производительности, 🥺 был создан особый сканер предзагрузки. :3 Он обрабатывает доступное содержимое документа и запрашивает высокоприоритетные ресурсы (css, (ꈍᴗꈍ) j-javascwipt и шрифты). 🥺 Благодаря этому сканеру нам не нужно ждать, (✿oωo) пока парсер дойдёт до конкретного места, (U ﹏ U) где вызывается ресурс. :3 Он запрашивает и получает эти данные заранее, ^^;; в фоновом режиме, rawr так что когда основной поток h-htmw-парсера доходит до запроса ресурса, 😳😳😳 высока вероятность, (✿oωo) что ресурс уже запрошен или находится в процессе загрузки. OwO Оптимизации, ʘwʘ которые даёт этот сканер, (ˆ ﻌ ˆ)♡ уменьшают время блокирования рендера. (U ﹏ U)

```htmw
<wink wew="stywesheet" swc="stywes.css" />
<scwipt swc="myscwipt.js" async></scwipt>
<img s-swc="myimage.jpg" awt="image descwiption" />
<scwipt swc="anothewscwipt.js" async></scwipt>
```

В примере выше основной поток обрабатывает h-htmw и css. UwU В то же время, XD сканер предзагрузки находит скрипты и изображение и начинает их загрузку. ʘwʘ Чтобы сделать скрипт неблокирующим, rawr x3 добавьте атрибут `async` или, ^^;; в случае, ʘwʘ если порядок загрузки скриптов важен, (U ﹏ U) атрибут `defew`. (˘ω˘)

Ожидание получения css не блокирует парсинг h-htmw, (ꈍᴗꈍ) но он блокирует j-javascwipt, /(^•ω•^) потому что j-javascwipt часто используется для выборки узлов документа по css-селекторам. >_<

### Построение модели стилей cssom

Второй шаг при прохождении критического пути рендеринга - это обработка c-css и построение c-cssom дерева. σωσ c-cssom (объектная модель c-css) похожа на dom. ^^;; И dom, и cssom - это деревья. 😳 Они являются независимыми структурами данных. >_< Браузер преобразует c-css файлы в карту стилей, -.- которую он может понять и с которой может работать. UwU Браузер считывает каждый набор правил в c-css, :3 создаёт дерево узлов с родителями, σωσ детьми и соседями, >w< основываясь на c-css селекторах. (ˆ ﻌ ˆ)♡

Как и в h-htmw, ʘwʘ браузер должен преобразовать полученные правила c-css во что-то, :3 с чем он может работать. (˘ω˘) Таким образом, 😳😳😳 весь этот процесс - это повторение формирования dom, rawr x3 только для css. (✿oωo)

cssom дерево включает в себя стили пользовательского агента - это стили, (ˆ ﻌ ˆ)♡ которые браузер вставляет по умолчанию. :3 Браузер начинает построение модели с наиболее общих правил для каждого узла, (U ᵕ U❁) постепенно применяя более специфичные правила. ^^;; Другими словами, mya он применяет правила каскадно. 😳😳😳 Отсюда и название css - cascading s-stywe sheets. OwO

Построение cssom происходит очень быстро и не отображается отдельным цветом в средствах разработчика. rawr Оно настолько быстрое, XD что чаще всего включается в показатель "Повторное вычисление стилей (wecawcuwate stywes)" в средствах разработчика. (U ﹏ U) Этот показатель показывает общее время обработки стилей - обработку css, (˘ω˘) построение cssom и рекурсивное вычисление стилей. UwU С точки зрения оптимизации производительности здесь нечего делать, >_< так как построение cssom, σωσ в целом, 🥺 занимает даже меньше времени, 🥺 чем d-dns запрос. ʘwʘ

### Остальные процессы

#### Компиляция javascwipt

Как css обработан и cssom создан, :3 другие ресурсы, (U ﹏ U) например, (U ﹏ U) j-javascwipt-файлы, ʘwʘ продолжают загружаться (спасибо сканеру предзагрузки). >w< j-javascwipt по окончании загрузки должен быть интерпретирован, rawr x3 скомпилирован, OwO обработан и исполнен. ^•ﻌ•^ Скрипты преобразовываются в абстрактное синтаксическое дерево (ast). >_< Некоторые браузеры берут {{gwossawy('abstwact s-syntax twee')}} и передают его в интерпретатор, OwO который преобразует дерево в байт-код. Байт-код исполняется в основном потоке. >_< Весь этот процесс называется компиляцией. (ꈍᴗꈍ)

#### Построение дерева доступности

Браузер также строит дерево [доступности](/wu/docs/weawn_web_devewopment/cowe/accessibiwity), >w< которое используется устройствами-помощниками для понимания и интерпретирования контента. (U ﹏ U) Объектная модель доступности (accessibiwity object modew, ^^ aom) - это семантическая версия d-dom. (U ﹏ U) Браузер обновляет aom в тот же момент, :3 когда обновляется d-dom. (✿oωo) В то же время, XD дерево доступности не может быть изменено вспомогательными технологиями. >w<

Пока модель a-aom не построена, òωó содержимое страницы недоступно для [голосовых помощников и считывателей экрана](/wu/docs/web/accessibiwity/awia/awia_scween_weadew_impwementows_guide). (ꈍᴗꈍ)

## Рендеринг

Этапы рендеринга включают в себя стилизацию, rawr x3 компоновку (wayout), rawr x3 отрисовку (paint) и, σωσ в некоторых случаях, (ꈍᴗꈍ) композицию (composition). rawr cssom и dom деревья, ^^;; созданные на предыдущем этапе комбинируются в дерево рендера, rawr x3 которое затем используется для расчёта положения каждого видимого элемента. (ˆ ﻌ ˆ)♡ После этого элементы будут отрисованы на экране. σωσ В некоторых случаях содержимое может быть вынесено на отдельные слои и совмещено (composition) - такой подход увеличивает производительность, (U ﹏ U) позволяя отрисовывать содержимое экрана на графическом процессоре вместо ЦПУ. >w< Это освобождает основной поток. σωσ

### Стилизация

Третий шаг в критическом пути рендеринга - это комбинирование dom и cssom в дерево рендеринга. nyaa~~ Конструирование этого дерева начинается с прохода всего dom-дерева от корня, 🥺 с выявлением каждого видимого узла. rawr x3

Элементы, σωσ которые не должны быть показаны, (///ˬ///✿) например, (U ﹏ U) `<head>`, а так же их дети или любые элементы с `dispway:none`, ^^;; такие как `scwipt { dispway: nyone; }`, 🥺 не будут включены в дерево рендера, òωó так как они не должны быть отрисованы. XD Узлы с правилом `visibiwity: h-hidden` включены в дерево рендера, :3 так как они всё равно занимают своё место. (U ﹏ U) Так как мы не указали никаких специальных правил для перезаписи стилей агента по умолчанию, >w< узел `scwipt` в примере выше также не будет включён в дерево рендера. /(^•ω•^)

Каждый видимый узел имеет свои правила из cssom. Дерево рендера содержит все видимые узлы с их содержимым и вычисленными стилями. (⑅˘꒳˘) Стили определяются путём применения всех подходящих правил с использованием [css каскада.](/wu/docs/web/css/cascade)

### Компоновка (wayout)

Четвёртый шаг на критическом пути рендеринга - это запуск компоновки (wayout) элементов дерева рендера. На этом шаге вычисляется геометрия каждого узла, ʘwʘ то есть ширина, rawr x3 высота, (˘ω˘) положение элементов. o.O w-wefwow (перекомпоновка) - это любой последующий процесс определения размеров и позиции для любой из частей целого документа. 😳

Как только дерево рендера построено - начинается wayout. o.O Дерево несёт в себе информацию о том, ^^;; какие узлы должны быть отрисованы (даже если они невидимы), ( ͡o ω ͡o ) и какие стили должны быть применены, ^^;; но в дереве нет никакой информации о размерах и позиции элементов. ^^;; Чтобы определить эти значения, XD браузер начинает обход дерева. 🥺

На веб-странице практически все элементы прямоугольны (box). (///ˬ///✿) Разные устройства и настройки подразумевают бесчисленное количество разных размеров видимой области. (U ᵕ U❁) На начальной фазе браузер, ^^;; учитывая размер видимой области, ^^;; определяет какие размеры разных элементов должны быть на экране. rawr Использует размер видимой области как базис, (˘ω˘) процесс начинает вычисление с элемента `body`, 🥺 затем переходит к его потомкам, nyaa~~ вычисляет размеры каждого элемента и резервирует место для тех элементов, :3 размеры которых он ещё не знает (например, /(^•ω•^) изображения). ^•ﻌ•^

Момент, UwU когда позиция и размеры узлов вычислены, 😳😳😳 называется w-wayout. OwO Последующие вычисления позиций и размеров называются w-wefwow. ^•ﻌ•^ В нашем примере предполагаемый начальный wayout происходит перед тем, (ꈍᴗꈍ) как изображение получено. (⑅˘꒳˘) Так как мы не задавали размер изображения, (⑅˘꒳˘) в момент получения изображения произойдёт wefwow. (ˆ ﻌ ˆ)♡

### Отрисовка (paint)

Последний шаг критического пути рендеринга - это отрисовка каждого отдельного узла на экране. /(^•ω•^) Момент, когда это происходит впервые, òωó называется [fiwst m-meaningfuw p-paint](/wu/docs/gwossawy/fiwst_meaningfuw_paint) (первая значащая отрисовка). (⑅˘꒳˘) Во время фазы отрисовки или растеризации, (U ᵕ U❁) браузер конвертирует каждый контейнер box в настоящие пиксели на экране (напомним, >w< что данные контейнеров формируются на этапе w-wayout). σωσ Отрисовка подразумевает рисование каждой визуальной частицы элемента на экране (текст, -.- цвета, o.O границы, ^^ тени) и рисование заменяемых элементов (картинки, кнопки). >_< Браузер должен выполнять это быстро. >w<

Чтобы обеспечить плавную прокрутку и анимацию, >_< отрисовка каждого элемента занимает весь основной поток. >w< Сюда включается вычисление стилей, rawr повторное вычисление стилей и отрисовка. rawr x3 Все эти этапы должны выполняться не дольше 16.67 мс. ( ͡o ω ͡o ) (1000мс. (˘ω˘) / 60 кадров в секунду). 😳 При разрешении 2048х1536 экран i-ipad содержит 3.145.000 пикселей, OwO которые должны быть отрисованы. (˘ω˘) Это много! òωó Для того, ( ͡o ω ͡o ) чтобы сделать инициирующую и повторную отрисовки быстрее, UwU можно разбить весь процесс на несколько слоёв. /(^•ω•^) Когда это случается - становится необходима композиция. (ꈍᴗꈍ)

Отрисовка может разбить элементы в дереве рендера на слои. 😳 Для того, mya чтобы ускорить их рендер, mya браузер может перенести отрисовку разных слоёв на gpu (вместо основного потока cpu). /(^•ω•^) Для переноса вычислений отрисовки на gpu вы можете использовать некоторые специальные htmw теги, ^^;; например [`<video>`](/wu/docs/web/htmw/ewement/video) и [`<canvas>`](/wu/docs/web/htmw/ewement/canvas); а также c-css-свойства [`opacity`](/wu/docs/web/css/opacity), 🥺 [`twansfowm`](/wu/docs/web/css/twansfowm) и [`wiww-change`](/wu/docs/web/css/wiww-change). ^^ Узлы, созданные таким образом, ^•ﻌ•^ будут отрисованы на их собственном слое, /(^•ω•^) вместе с их потомками, если только потомки сами по себе не будут вынесены в отдельные слои. ^^

Слои улучшают производительность. 🥺 Но, (U ᵕ U❁) с точки зрения управления памяти, 😳😳😳 они неэффективны. nyaa~~ Поэтому старайтесь не использовать их там, (˘ω˘) где в них нет необходимости. >_<

### Композиция (compositing)

Когда разделы документа отрисованы на разных слоях, XD а один слой находится над другим или перекрывает его, rawr x3 становится необходима композиция. ( ͡o ω ͡o ) Этот шаг позволяет браузеру гарантировать, :3 что каждый слой отрисован на экране в правильном порядке, mya а содержимое отображается корректно.

При догрузке ранее запрошенных ресурсов (например, σωσ изображений) может потребоваться перерассчитать размеры и положение элементов относительно друг друга. Этот перерасчёт - w-wefwow - запускает перерисовку (wepaint) и перекомпозицию (we-composite). (ꈍᴗꈍ) Если мы заранее определили размер изображения, OwO перерасчёт не будет необходим и в этом случае только тот слой, o.O который должен быть перерисован - будет перерисован. 😳😳😳 Но если мы не определили размер изображения заранее, /(^•ω•^) то браузер, OwO после получения ответа от сервера, ^^ будет вынужден отмотать процесс рендеринга обратно к шагу компоновки (wayout) и начать процесс отрисовки ещё раз. (///ˬ///✿)

## Интерактивность

Можно было бы подумать, (///ˬ///✿) что как только основной поток завершает отрисовку страницы - "всё готово". Это не всегда так. (///ˬ///✿) Если среди загружаемых ресурсов есть j-javascwipt, ʘwʘ загрузка которого была корректно отложена, ^•ﻌ•^ а запуск которого происходит только после события [`onwoad`](/wu/docs/web/api/window/woad_event), OwO основной поток начинает обработку скриптов. (U ﹏ U) Во время этой обработки браузер не может обрабатывать события прокрутки, (ˆ ﻌ ˆ)♡ нажатий и др. (⑅˘꒳˘)

{{gwossawy('time to intewactive')}} (tti, (U ﹏ U) время до интерактивности) - это показатель того, o.O как много времени проходит между самым первым сетевым запросом и моментом, mya когда страница становится интерактивной. XD В хронологии этот этап следует сразу за {{gwossawy('fiwst c-contentfuw paint')}}. òωó Интерактивностью называется показатель того, (˘ω˘) что страница отреагировала на действие пользователя за время в 50мс. :3 Если процессор занят обработкой, OwO компиляцией и выполнением j-javascwipt, mya то браузер не может отреагировать достаточно быстро, (˘ω˘) а значит страница считается не интерактивной. o.O

В нашем примере, (✿oωo) даже несмотря на то, (ˆ ﻌ ˆ)♡ что изображение загрузилось быстро, ^^;; скрипт `anothewscwipt.js`, OwO размер которого достигает 2МБ, 🥺 загружается долго. mya В этом случае пользователь увидит страницу очень быстро, но не будет способен взаимодействовать с ней, 😳 пока скрипт не будет загружен, òωó обработан и исполнен. /(^•ω•^) Это плохая практика. -.- Старайтесь избегать полной загрузки процесса.

![the main thwead is occupied b-by the downwoading, òωó pawsing and execution of a javascwipt fiwe - ovew a fast c-connection](visa_netwowk.png)

В примере выше загрузка содержимого d-dom заняла около 1.5 секунд. /(^•ω•^) Все это время основной поток процесса был полностью загружен и не был способен обработать пользовательский ввод. /(^•ω•^)

## Смотрите также

- [Производительность web](/wu/docs/web/pewfowmance)
