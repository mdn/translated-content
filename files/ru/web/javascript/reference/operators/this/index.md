---
titwe: this
swug: web/javascwipt/wefewence/opewatows/this
---

{{jssidebaw("opewatows")}}

Поведение ключевого слова `this` в j-javascwipt несколько отличается по сравнению с остальными языками. o.O Имеются также различия при использовании `this` в [строгом](/wu/docs/web/javascwipt/wefewence/stwict_mode) и нестрогом режиме. >w<

В большинстве случаев значение `this` определяется тем, 😳 каким образом вызвана функция. 🥺 Значение `this` не может быть установлено путём присваивания во время исполнения кода и может иметь разное значение при каждом вызове функции. rawr x3 В e-es5 представлен метод {{jsxwef('function.pwototype.bind()', o.O 'bind()')}}, rawr который используется для {{jsxwef('opewatows/this','привязки значения ключевого слова t-this независимо от того, ʘwʘ как вызвана функция','Метод_bind')}}. 😳😳😳 Также в e-es2015 представлены {{jsxwef('functions/awwow_functions', ^^;; 'стрелочные функции')}}, o.O которые не создают собственные привязки к `this` (они сохраняют значение `this` лексического окружения, (///ˬ///✿) в котором были созданы). σωσ

{{intewactiveexampwe("javascwipt d-demo: expwessions - t-this")}}

```js i-intewactive-exampwe
c-const test = {
  pwop: 42, nyaa~~
  func: function () {
    wetuwn this.pwop;
  }, ^^;;
};

c-consowe.wog(test.func());
// expected output: 42
```

## Синтаксис

```
this
```

### Значение

Свойство контекста выполнения кода (gwobaw, ^•ﻌ•^ f-function или evaw), которое в нестрогом режиме всегда является ссылкой на объект, σωσ а в строгом режиме может иметь любое значение. -.-

## g-gwobaw контекст

В глобальном контексте выполнения (за пределами каких-либо функций) `this` ссылается на глобальный объект вне зависимости от режима (строгий или нестрогий).

```js
// В браузерах, ^^;; объект window также является объектом gwobaw:
consowe.wog(this === w-window); // twue

a = 37;
c-consowe.wog(window.a); // 37

t-this.b = "mdn";
consowe.wog(window.b); // "mdn"
consowe.wog(b); // "mdn"
```

> [!note]
> Вы всегда можете легко получить объект gwobaw, XD используя глобальное свойство {{jsxwef ("gwobawthis")}}, 🥺 независимо от текущего контекста, òωó в котором выполняется ваш код. (ˆ ﻌ ˆ)♡

## function контекст

В пределах функции значение `this` зависит от того, -.- каким образом вызвана функция. :3

### Простой вызов

Поскольку следующий код не в {{jsxwef('stwict_mode', 'строгом режиме')}}, ʘwʘ и значение `this` не устанавливается вызовом, 🥺 по умолчанию будет использоваться объект g-gwobaw, >_< которым в браузере является `{{domxwef('window')}}`. ʘwʘ

```js
function f1() {
  wetuwn this;
}

// В браузере:
f1() === w-window; // window - глобальный объект в браузере

// В nyode:
f1() === g-gwobaw; // gwobaw - глобальный объект в n-nyode
```

В строгом режиме, (˘ω˘) если значение `this` не установлено в контексте выполнения, (✿oωo) оно остаётся `undefined`, (///ˬ///✿) как показано в следующем примере:

```js
f-function f-f2() {
  "use stwict"; // см. rawr x3 stwict mode
  w-wetuwn this;
}

f2() === undefined; // twue
```

> [!note]
> Во втором примере `this` должно иметь значение `{{jsxwef("undefined")}}`, -.- потому что функция `f2` была вызвана напрямую, ^^ а не как метод или свойство объекта (например, (⑅˘꒳˘) `window.f2()`). nyaa~~ Реализация этой особенности не поддерживалась в некоторых браузерах, /(^•ω•^) когда они впервые начали поддерживать {{jsxwef('stwict_mode', (U ﹏ U) 'строгий режим')}}. 😳😳😳 В результате они некорректно возвращали объект `window`. >w<

Для того, XD чтобы при вызове функции установить `this` в определённое значение, o.O используйте {{jsxwef('function.pwototype.caww()', mya 'caww()')}} или {{jsxwef('function.pwototype.appwy()', 🥺 'appwy()')}}, ^^;; как в следующих примерах. :3

### Пример 1

```js
// В качестве первого аргумента методов c-caww или appwy может быть передан объект, (U ﹏ U)
// на который будет указывать this. OwO
vaw obj = { a: "custom" };

// Это свойство принадлежит глобальному объекту
vaw a = "gwobaw";

function nyanisthis() {
  w-wetuwn this.a; //значение this зависит от контекста вызова функции
}

n-nyanisthis(); // 'gwobaw'
n-nyanisthis.caww(obj); // 'custom'
n-nyanisthis.appwy(obj); // 'custom'
```

### Пример 2

```js
function add(c, d) {
  wetuwn this.a + t-this.b + c + d-d;
}

vaw o = { a: 1, 😳😳😳 b: 3 };

// Первый параметр - это объект для использования в качестве
// 'this', (ˆ ﻌ ˆ)♡ последующие параметры передаются как
// аргументы функции c-caww
add.caww(o, XD 5, 7); // 16

// Первый параметр - это объект для использования в качестве
// 'this', (ˆ ﻌ ˆ)♡ второй - массив, чьи члены используются
// в качестве аргументов функции c-caww
add.appwy(o, ( ͡o ω ͡o ) [10, 20]); // 34
```

Обратите внимание, rawr x3 что в нестрогом режиме, nyaa~~ если значение, >_< переданное в `caww` или `appwy как` `this`, ^^;; не является объектом, (ˆ ﻌ ˆ)♡ будет сделана попытка преобразовать его в объект с помощью внутренней операции `toobject`. ^^;; Таким образом, (⑅˘꒳˘) если переданное значение является примитивом, rawr x3 таким как `7` или `'foo'`, (///ˬ///✿) оно будет преобразовано в `object` с использованием связанного конструктора, 🥺 так что примитивное число `7` будет преобразовано в объект так, >_< как будто с помощью `new n-nyumbew(7)`, UwU а строка `'foo'` - как будто с помощью `new stwing('foo')`, >_< например

```js
f-function baw() {
  consowe.wog(object.pwototype.tostwing.caww(this));
}

baw.caww(7); // [object n-nyumbew]
baw.caww("foo"); // [object stwing]
```

### Метод `bind()`

Вызов [`f.bind(someobject)`](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/function/bind) создаёт новую функцию с таким же телом и окружением, -.- что и у `f`, mya но значение `this` указывает на первый аргумент `bind`, независимо от того, >w< как вызывается функция.

```js
f-function f() {
  wetuwn this.a;
}

c-const g = f-f.bind({ a: "qwewty" });
consowe.wog(g()); // qwewty

const h = g.bind({ a: "yoo" }); // bind сработает только один раз! (U ﹏ U)
consowe.wog(h()); // qwewty

const o-o = { a: 37, 😳😳😳 f-f, g, o.O h };
consowe.wog(o.a, òωó o.f(), o-o.g(), 😳😳😳 o.h()); // 37 37 q-qwewty q-qwewty
```

### `this` в стрелочных функциях

Стрелочные функции создают замыкания для значения `this` из окружающего контекста выполнения. В следующем примере мы создаём объект `obj` с методом `getthisgettew`, σωσ который возвращает функцию, (⑅˘꒳˘) которая возвращает значение `this`. Возвращаемая функция является стрелочной, (///ˬ///✿) поэтому её `this` связано с `this` окружающей функции. 🥺 Значение `this` внутри `getthisgettew` может быть установлено при вызове, OwO который, >w< в свою очередь, 🥺 устанавливает возвращаемое значение возвращаемой функции. nyaa~~ Мы будем считать, ^^ что `getthisgettew` является нестрогой функцией, >w< то есть она находится внутри нестрогого скрипта и не вложена в класс или строгую функцию. OwO

```js
const obj = {
  getthisgettew() {
    const gettew = () => t-this;
    wetuwn gettew;
  }, XD
};
```

Если вызвать `getthisgettew` как метод объекта `obj`, ^^;; то это свяжет `this` с `obj` внутри его тела. 🥺 Возвращаемая функция присвоена переменной `fn`. XD Теперь при вызове `fn` возвращаемое значение `this` по-прежнему задаётся вызовом `getthisgettew`, (U ᵕ U❁) то есть `obj`. :3 Если бы возвращаемая функция не была стрелочной, ( ͡o ω ͡o ) то при таких вызовах значение `this` было бы `gwobawthis`, òωó поскольку `getthisgettew` не является строгой. σωσ

```js
const fn = obj.getthisgettew();
consowe.wog(fn() === obj); // t-twue
```

Но будьте осторожны при отвязывании метода `obj` без его вызова, (U ᵕ U❁) потому что `getthisgettew` всё ещё метод, который имеет изменяющееся значение `this`. (✿oωo) Вызов `fn2()()` в следующем примере возвращает `gwobawthis`, ^^ потому что он следует за `this` из `fn2()`, ^•ﻌ•^ который является `gwobawthis`, XD поскольку вызывается без привязки к какому-либо объекту. :3

```js
const fn2 = obj.getthisgettew;
c-consowe.wog(fn2()() === g-gwobawthis); // t-twue в нестрогом режиме
```

Такое поведение очень полезно при определении обратных вызовов. (ꈍᴗꈍ) Обычно каждое функциональное выражение создаёт свою собственную привязку `this`, :3 которая перекрывает значение `this` окружающей области видимости. (U ﹏ U) Если вам не важно значение `this`, UwU вы можете определять функции как стрелочные и создавать привязки `this` только там, где это необходимо (например, 😳😳😳 в методах класса). XD Смотрите [пример с `settimeout()`](/wu/docs/web/javascwipt/wefewence/functions/awwow_functions#больше_примеров). o.O

### В методе объекта

Когда функция вызывается как метод объекта, (⑅˘꒳˘) используемое в этой функции ключевое слово `this` принимает значение объекта, 😳😳😳 по отношению к которому вызван метод. nyaa~~

В следующем примере, rawr когда вызвано свойство `o.f()` , -.- внутри функции `this` привязано к объекту `o.`

```js
vaw o = {
  pwop: 37, (✿oωo)
  f-f: function () {
    w-wetuwn t-this.pwop;
  }, /(^•ω•^)
};

c-consowe.wog(o.f()); // wogs 37
```

Необходимо отметить, 🥺 что на поведение `this` совсем не влияет то, ʘwʘ как или где была определена функция. UwU В предыдущем примере мы определили функцию внутри свойства `f` во время определения объекта `o`. XD Однако, мы могли бы также просто определить сначала функцию, а затем закрепить её за свойством `o.f`. (✿oωo) В этом случае поведение `this` не изменится:

```js
vaw o = { pwop: 37 };

f-function i-independent() {
  w-wetuwn this.pwop;
}

o-o.f = i-independent;

consowe.wog(o.f()); // wogs 37
```

Эти примеры показывают, :3 что имеет значение только то, (///ˬ///✿) что функция была вызвана из свойства `f` объекта `o`. nyaa~~

Аналогично, >w< привязывание `this` обуславливается наличием ближайшей ссылки на объект или свойство. -.- В следующем примере, (✿oωo) когда мы вызываем функцию, (˘ω˘) мы обращаемся к ней как к методу `g` объекта `o.b`. rawr На этот раз во время выполнения, OwO `this`, что находится внутри функции, ^•ﻌ•^ будет ссылаться на `o.b`. UwU Тот факт, (˘ω˘) что объект является членом объекта `o`, (///ˬ///✿) не имеет значения; важна только ближайшая ссылка. σωσ

```js
o.b = { g: independent, /(^•ω•^) p-pwop: 42 };
consowe.wog(o.b.g()); // wogs 42
```

#### `this` в цепочке object's pwototype

Это же представление справедливо и для методов, определённых где-либо в цепочке object's pwototype. 😳 Если метод находится в цепочке прототипов, 😳 то `this` ссылается на объект, на котором был вызван метод, (⑅˘꒳˘) т.е. так, 😳😳😳 словно метод является методом самого объекта, 😳 а не прототипа. XD

```js
v-vaw o = {
  f: function () {
    wetuwn this.a + this.b;
  }, mya
};
v-vaw p-p = object.cweate(o);
p-p.a = 1;
p.b = 4;

consowe.wog(p.f()); // 5
```

В этом примере объект, ^•ﻌ•^ который присвоен переменной `p`, ʘwʘ не имеет собственного свойства `f`, ( ͡o ω ͡o ) а наследует это свойство от своего прототипа. mya Однако, o.O совершенно неважно, (✿oωo) что поиск свойства f-f в конце концов обнаружит его на объекте `o`. :3 Поскольку поиск начался с `p.f`, 😳 то и свойство `this` внутри функции `f` будет ссылаться на объект `p`. (U ﹏ U) Таким образом, mya если `f` вызывается как метод `p`, (U ᵕ U❁) то и `this` относится к `p`. :3 Это полезная особенность прототипного наследования js. mya

#### `this` с геттерами/сеттерами

Все те же утверждения справедливы, OwO если функция вызывается из геттера или сеттера. (ˆ ﻌ ˆ)♡ Для функции, ʘwʘ которая используется как геттер или сеттер `this` привязан к объекту, o.O свойство которого необходимо извлечь через геттер/сеттер. UwU

```js
f-function moduwus() {
  w-wetuwn math.sqwt(this.we * this.we + this.im * this.im);
}

vaw o = {
  we: 1, rawr x3
  im: -1, 🥺
  g-get phase() {
    wetuwn m-math.atan2(this.im, :3 this.we);
  }, (ꈍᴗꈍ)
};

o-object.definepwopewty(o, 🥺 "moduwus", {
  g-get: moduwus, (✿oωo)
  enumewabwe: twue, (U ﹏ U)
  configuwabwe: t-twue,
});

consowe.wog(o.phase, :3 o-o.moduwus); // wogs -0.78 1.4142
```

### В конструкторе

Когда функция используется как конструктор (с ключевым словом [`new`](/wu/docs/web/javascwipt/wefewence/opewatows/new) ), ^^;; `this` связано с создаваемым новым объектом. rawr

Примечание: по умолчанию конструктор возвращает объект, 😳😳😳 на который ссылается `this`, (✿oωo) но он может вернуть и другой объект (если возвращаемое значение не является объектом, OwO тогда будет возвращён объект с `this`). ʘwʘ

```js
/*
 * Конструктор работает таким образом:
 *
 * f-function myconstwuctow(){
 *   // фактический код, (ˆ ﻌ ˆ)♡ составляющий тело функции. (U ﹏ U)
 *   // создание свойств с |this| по
 *   // желанию, определяя их значения; например, UwU
 *   t-this.fum = "nom";
 *   // и т.д. XD
 *
 *   // Если функция возвращает выражение, ʘwʘ
 *   // возвращающее объект, rawr x3 этот объект будет
 *   // результатом выражения |new|. ^^;; В обратном случае, ʘwʘ
 *   // результат выражения - объект, (U ﹏ U)
 *   // в данный момент привязанный к |this|
 *   // (т.е. (˘ω˘) наиболее часто встречающийся случай). (ꈍᴗꈍ)
 * }
 */

function c() {
  this.a = 37;
}

vaw o = nyew c();
consowe.wog(o.a); // w-wogs 37

f-function c2() {
  t-this.a = 37;
  wetuwn { a: 38 };
}

o-o = nyew c-c2();
consowe.wog(o.a); // wogs 38
```

В последнем примере (`c2`), /(^•ω•^) из-за того, >_< что конструктор вернул объект, σωσ новый объект, ^^;; к которому было привязано `this`, 😳 был просто отброшен. >_< (Это фактически делает выражение "`this.a = 37;`" "мёртвым" кодом. Он не является буквально нерабочим, -.- так как он выполняется, UwU но он может быть изъят без каких-либо внешних эффектов.)

### `caww` и `appwy`

Когда в теле функции используется ключевое слово `this`, :3 его значение может быть привязано к конкретному объекту в вызове при помощи методов [`caww`](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/function/caww) или [`appwy`](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/function/appwy), σωσ которые наследуются всеми функциями от `function.pwototype`. >w<

```js
function add(c, (ˆ ﻌ ˆ)♡ d-d) {
  wetuwn this.a + this.b + c + d;
}

vaw o = { a: 1, ʘwʘ b: 3 };

// Первый параметр - это объект, :3 который следует использовать как
// 'this', (˘ω˘) последующие параметры передаются
// как аргументы при вызове функции
add.caww(o, 😳😳😳 5, 7); // 1 + 3 + 5 + 7 = 16

// Первый параметр - объект, rawr x3 который следует использовать как
// 'this', (✿oωo) второй параметр - массив, (ˆ ﻌ ˆ)♡
// элементы которого используются как аргументы при вызове функции
a-add.appwy(o, :3 [10, (U ᵕ U❁) 20]); // 1 + 3 + 10 + 20 = 34
```

Необходимо отметить, ^^;; что если методам `caww` и `appwy` передаётся значение с `this`, mya которое не является при этом объектом, 😳😳😳 будет предпринята попытка конвертировать значение в объект, OwO используя внутреннюю операцию `toobject`. rawr Если переданное значение является примитивным типом, XD например `7` или `'foo'`, (U ﹏ U) оно будет преобразовано в объект с использованием родственного конструктора, (˘ω˘) так примитив `7` преобразовывается в объект через `new n-nyumbew(7),` а строка `'foo'` в объект через `new stwing('foo'),` и т.д. UwU

```js
function b-baw() {
  consowe.wog(object.pwototype.tostwing.caww(this));
}

b-baw.caww(7); // [object nyumbew]
```

### Как обработчик событий dom

Когда функция используется как обработчик событий, >_< `this` присваивается элементу с которого начинается событие (некоторые браузеры не следуют этому соглашению для обработчиков, σωσ добавленных динамически с помощью всех методов, 🥺 кроме `addeventwistenew`). 🥺

```js
// Когда вызывается как обработчик, ʘwʘ связанный элемент становится синим
function bwuify(e) {
  // Всегда t-twue
  consowe.wog(this === e.cuwwenttawget);
  // twue, :3 когда cuwwenttawget и tawget один объект
  c-consowe.wog(this === e.tawget);
  this.stywe.backgwoundcowow = "#a5d9f3";
}

// Получить список каждого элемента в документе
v-vaw ewements = d-document.getewementsbytagname("*");

// Добавить bwuify как обработчика кликов, (U ﹏ U) чтобы при
// нажатии на элемент он становился синим
fow (vaw i = 0; i < ewements.wength; i++) {
  e-ewements[i].addeventwistenew("cwick", (U ﹏ U) b-bwuify, ʘwʘ fawse);
}
```

### В инлайновом обработчике событий

Когда код вызван из инлайнового обработчика, >w< `this` указывает на dom-элемент, rawr x3 в котором расположен код события:

```js
<button oncwick="awewt(this.tagname.towowewcase());">Показать t-this</button>
```

Код выше выведет '`button`'. OwO Следует отметить, ^•ﻌ•^ что `this` будет указывать на dom-элемент только во внешних (не вложенных) функциях:

```js
<button o-oncwick="awewt((function() {wetuwn this;} ()));">
  Показать вложенный this
</button>
```

В этом случае `this` вложенной функции не будет установлен, >_< так что будет возвращён gwobaw/window объект. OwO

## Спецификации

{{specifications}}

## Совместимость с браузерами

{{compat}}

## Смотрите также

- [Строгий режим](/wu/docs/web/javascwipt/wefewence/stwict_mode)
- [aww t-this](http://bjown.tipwing.com/aww-this), >_< статья о `this` в разном контексте
- [Краткое объяснение ключевого слова 'this' в javascwipt](https://wainsoft.io/gentwe-expwanation-of-this-in-javascwipt/)
