---
title: delete
slug: Web/JavaScript/Reference/Operators/delete
translation_of: Web/JavaScript/Reference/Operators/delete
---
<div>{{jsSidebar("Operators")}}</div>

<h2 id="Summary">Аннотация</h2>

<p>Оператор <code>delete</code> удаляет свойство из объекта.</p>

<table class="standard-table">
 <thead>
  <tr>
   <th class="header" colspan="2" scope="row">Оператор</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Реализован в:</td>
   <td>JavaScript 1.2</td>
  </tr>
  <tr>
   <td>Версия ECMAScript:</td>
   <td>ECMA-262 1-ый выпуск</td>
  </tr>
 </tbody>
</table>

<h2 id="Syntax">Синтаксис</h2>

<p><code>delete <em>выражение</em></code></p>

<p>где результат вычисления <em>выражения</em> должен быть ссылкой на свойство (объекта), например:</p>

<pre class="syntaxbox">delete <em>object.property</em>
delete <em>object</em>['<em>property</em>']
delete <em>object</em>[<em>index</em>]
delete <em>property</em> // удаляет свойства глобального объекта, или,
                // используя инструкцию <em>with</em>, свойства объекта, на который ссылается инструкция
</pre>

<p>Если результат вычисления <em>выражения</em> не является свойством (объекта), <code>delete</code> ничего не делает.</p>

<h3 id="Parameters">Параметры</h3>

<dl>
 <dt><code>object</code></dt>
 <dd>Имя объекта или выражение, результатом вычисления которого является объект.</dd>
 <dt><code>property</code></dt>
 <dd>Удаляемое свойство.</dd>
 <dt><code>index</code></dt>
 <dd>Целое число, представляющее собой индекс массива, который должен быть удалён.</dd>
</dl>

<h3 id="Returns">Возвращаемое значение</h3>

<p>Возвращает false, только если свойство существует в самом объекте, а не в его прототипах, и не может быть удалено. Во всех остальных случаях возвращает true.</p>

<h2 id="Description">Описание</h2>

<p>Если оператор <code>delete</code> успешно выполняет удаление, он полностью удаляет свойство из объекта. Однако, если свойство с таким же именем существует в цепочке прототипов, объект унаследует это свойство из прототипа.</p>

<p><code>delete</code> эффективен только применительно к свойствам объектов. Он не оказывает никакого влияния на имена переменных и функций.<br>
 Присвоение значения свойству без указания объекта (без оператора var) иногда неверно характеризуется, как глобальная переменная, (например <code>x = 5</code>). На самом деле происходит присвоение значения свойству глобального объекта.</p>

<p><code>delete</code> не может удалить определённые свойства встроенных объектов (таких как Object, Array, Math и так далее). В спецификации ECMA-262 они обозначены как <em>DontDelete.</em></p>

<pre class="brush: js">x = 42;         // создаёт свойство x в глобальном объекте
var y = 43;     // объявляет новую переменную, y
myobj = {};
myobj.h = 4;    // создаёт свойство h в myobj
myobj.k = 5;    // создаёт свойство k в myobj

delete x;       // возвращает true  (x - свойство глобального объекта и может быть удалено)
delete y;       // возвращает false (delete не влияет на имена переменных)
delete Math.PI; // возвращает false (delete не влияет на определённые встроенные свойства)
delete myobj.h; // возвращает true  (свойства, определённые пользователем могут быть удалены)

with(myobj) {
    delete k;   // возвращает true  (эквивалентно delete myobj.k)
}

delete myobj;   // возвращает true  (myobj это свойство глобального объекта, не переменная, поэтому может быть удалено)</pre>

<p>Если объект наследует свойство от прототипа и не имеет собственного свойства с таким же именем, свойство не может быть удалено при обращении через этот объект. Однако можно удалить это свойство напрямую в прототипе.</p>

<pre class="brush: js">function Foo(){}
Foo.prototype.bar = 42;
var foo = new Foo();
delete foo.bar;           // возвращает true, но безрезультатно, так как bar - наследуемое свойство
alert(foo.bar);           // выводит 42, свойство все ещё наследуется
delete Foo.prototype.bar; // удаляет свойство из прототипа
alert(foo.bar);           // выводит "undefined", свойство больше не наследуется</pre>

<h3 id="Deleting_array_elements">Удаление элементов массива</h3>

<p>Когда с помощью оператора delete удаляется элемент массива, длина массива не меняется. Например, если вы удалите a{{ mediawiki.external(3) }}, a{{ mediawiki.external(4) }} по прежнему a{{ mediawiki.external(4) }}, а a{{ mediawiki.external(3) }} не определено. Так будет даже если вы удалите последний элемент массива (<code>delete a{{ mediawiki.external('a.length-1') }}</code>).</p>

<p>Когда оператор <code>delete</code> удаляет элемент массива, этот элемент больше не существует в массиве. В следующем примере, trees{{ mediawiki.external(3) }} удаляется с помощью <code>delete</code>.</p>

<pre class="brush: js">var trees = ["redwood","bay","cedar","oak","maple"];

delete trees[3];
if (3 in trees) {
    // этот участок кода не выполнится
}</pre>

<p>Если вы хотите, чтобы элемент массива существовал, но имел значение undefined, используйте значение <code>undefined</code> вместо оператора <code>delete</code>. В следующем примере, trees{{ mediawiki.external(3) }} принимает значение undefined, но элемент массива все ещё существует:</p>

<pre class="brush: js">var trees = ["redwood","bay","cedar","oak","maple"];
trees[3]=undefined;
if (3 in trees) {
    // этот участок кода выполнится
}</pre>

<h2 id="Проблема_кроссбраузерности">Проблема кроссбраузерности</h2>

<p>Несмотря на то, что стандарт ECMAScript оставляет порядок итерации по свойствам объектов на усмотрение реализующей стороны, может оказаться так, что все основные браузеры поддерживают порядок итерации, основанный на принципе "свойство добавленное в объект раньше идёт раньше" (по крайней мере для свойств не находящихся в прототипе). Однако, в случае с Internet Explorer, когда кто-нибудь использует <code>delete</code> с каким-либо свойством, это приводит к некоторым неожиданным результатам, заставляя другие браузеры отказаться от использования простых объектов, таких как литералы объектов, в качестве ассоциативных массивов. В Internet Explorer, когда значение свойства установлено в undefined, после удаления этого свойства, если кто-нибудь позже добавит свойство с таким же именем, оно окажется в своей <em>старой</em> позиции, а не в конце итерационной последовательности, как ожидается.</p>

<p>Поэтому, если вы хотите симулировать упорядоченный ассоциативный массив в кроссбраузерной среде, вам придётся либо использовать два отдельных массива (один для ключей и один для значений), либо построить массив из объектов с одним свойством и так далее.</p>

<h2 id="Specification">Внешние ссылки</h2>

<ul>
 <li>Глубокий <a href="http://perfectionkills.com/understanding-delete/">анализ оператора delete</a></li>
</ul>
