---
title: delete
slug: Web/JavaScript/Reference/Operators/delete
---

{{jsSidebar("Operators")}}

## Аннотация

Оператор `delete` удаляет свойство из объекта.

<table class="standard-table">
  <thead>
    <tr>
      <th class="header" colspan="2" scope="row">Оператор</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Реализован в:</td>
      <td>JavaScript 1.2</td>
    </tr>
    <tr>
      <td>Версия ECMAScript:</td>
      <td>ECMA-262 1-ый выпуск</td>
    </tr>
  </tbody>
</table>

## Синтаксис

`delete выражение`

где результат вычисления _выражения_ должен быть ссылкой на свойство (объекта), например:

```
delete object.property
delete object['property']
delete object[index]
delete property // удаляет свойства глобального объекта, или,
                // используя инструкцию with, свойства объекта, на который ссылается инструкция
```

Если результат вычисления _выражения_ не является свойством (объекта), `delete` ничего не делает.

### Параметры

- `object`
  - : Имя объекта или выражение, результатом вычисления которого является объект.
- `property`
  - : Удаляемое свойство.
- `index`
  - : Целое число, представляющее собой индекс массива, который должен быть удалён.

### Возвращаемое значение

Возвращает false, только если свойство существует в самом объекте, а не в его прототипах, и не может быть удалено. Во всех остальных случаях возвращает true.

## Описание

Если оператор `delete` успешно выполняет удаление, он полностью удаляет свойство из объекта. Однако, если свойство с таким же именем существует в цепочке прототипов, объект унаследует это свойство из прототипа.

`delete` эффективен только применительно к свойствам объектов. Он не оказывает никакого влияния на имена переменных и функций.
Присвоение значения свойству без указания объекта (без оператора var) иногда неверно характеризуется, как глобальная переменная, (например `x = 5`). На самом деле происходит присвоение значения свойству глобального объекта.

`delete` не может удалить определённые свойства встроенных объектов (таких как Object, Array, Math и так далее). В спецификации ECMA-262 они обозначены как _DontDelete._

```js
x = 42; // создаёт свойство x в глобальном объекте
var y = 43; // объявляет новую переменную, y
myobj = {};
myobj.h = 4; // создаёт свойство h в myobj
myobj.k = 5; // создаёт свойство k в myobj

delete x; // возвращает true  (x - свойство глобального объекта и может быть удалено)
delete y; // возвращает false (delete не влияет на имена переменных)
delete Math.PI; // возвращает false (delete не влияет на определённые встроенные свойства)
delete myobj.h; // возвращает true  (свойства, определённые пользователем могут быть удалены)

with (myobj) {
  delete k; // возвращает true  (эквивалентно delete myobj.k)
}

delete myobj; // возвращает true  (myobj это свойство глобального объекта, не переменная, поэтому может быть удалено)
```

Если объект наследует свойство от прототипа и не имеет собственного свойства с таким же именем, свойство не может быть удалено при обращении через этот объект. Однако можно удалить это свойство напрямую в прототипе.

```js
function Foo() {}
Foo.prototype.bar = 42;
var foo = new Foo();
delete foo.bar; // возвращает true, но безрезультатно, так как bar - наследуемое свойство
alert(foo.bar); // выводит 42, свойство все ещё наследуется
delete Foo.prototype.bar; // удаляет свойство из прототипа
alert(foo.bar); // выводит "undefined", свойство больше не наследуется
```

### Удаление элементов массива

Когда с помощью оператора delete удаляется элемент массива, длина массива не меняется. Например, если вы удалите `a[3]`, `a[4]` по прежнему `a[4]`, а `a[3]` не определено. Так будет даже если вы удалите последний элемент массива (`delete a[a.length-1]`).

Когда оператор `delete` удаляет элемент массива, этот элемент больше не существует в массиве. В следующем примере, `trees[3]` удаляется с помощью `delete`.

```js
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
delete trees[3];
console.log(3 in trees); // false
```

Если вы хотите, чтобы элемент массива существовал, но имел значение undefined, используйте значение `undefined` вместо оператора `delete`. В следующем примере, `trees[3]` принимает значение undefined, но элемент массива все ещё существует:

```js
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
trees[3] = undefined;
console.log(3 in trees); // true
```

## Проблема кроссбраузерности

Несмотря на то, что стандарт ECMAScript оставляет порядок итерации по свойствам объектов на усмотрение реализующей стороны, может оказаться так, что все основные браузеры поддерживают порядок итерации, основанный на принципе "свойство добавленное в объект раньше идёт раньше" (по крайней мере для свойств не находящихся в прототипе). Однако, в случае с Internet Explorer, когда кто-нибудь использует `delete` с каким-либо свойством, это приводит к некоторым неожиданным результатам, заставляя другие браузеры отказаться от использования простых объектов, таких как литералы объектов, в качестве ассоциативных массивов. В Internet Explorer, когда значение свойства установлено в undefined, после удаления этого свойства, если кто-нибудь позже добавит свойство с таким же именем, оно окажется в своей _старой_ позиции, а не в конце итерационной последовательности, как ожидается.

Поэтому, если вы хотите симулировать упорядоченный ассоциативный массив в кроссбраузерной среде, вам придётся либо использовать два отдельных массива (один для ключей и один для значений), либо построить массив из объектов с одним свойством и так далее.

## Внешние ссылки

- Глубокий [анализ оператора delete](http://perfectionkills.com/understanding-delete/)
