---
title: Блок
slug: Web/JavaScript/Reference/Statements/block
---

{{jsSidebar("Statements")}}

**Блок инструкций** (или **сложная инструкция** в других языках) используется для группировки нуля или более инструкций. Блок отделяется парой фигурных скобок и может опционально быть {{jsxref("Statements/label", "поименован")}}:

## Синтаксис

```
[имя:] {
  инструкция_1;
  инструкция_2;
  ...
  инструкция_n;
}
```

- `инструкция_1`, `инструкция_2`, `инструкция_n`
  - : Инструкции, сгруппированные внутри блока инструкций.
- имя
  - : Необязательное {{jsxref("Statements/label", "имя")}} для визуальной идентификации или использования как точки выхода для оператора {{jsxref("Statements/break", "break")}}.

## Описание

Эта инструкция широко используется с операторами управления потоком (н., {{jsxref("Statements/if...else", "if...else")}}, {{jsxref("Statements/for", "for")}}, {{jsxref("Statements/while", "while")}}). Например:

```js
while (x < 10) {
  x++;
}
```

Обратите внимание, что блок инструкций не заканчивается точкой с запятой.

Блок инструкций часто называется **сложной (составной) инструкцией** в других языках. Он позволяет вам использовать несколько операторов там, где JavaScript ожидает один оператор. Помещение инструкций в блок - это распространённая практика в JavaScript. Противоположное поведение - использование [пустого оператора](/ru/docs/Web/JavaScript/Reference/Statements/Empty) там, где никаких действий не нужно, а оператор требуется.

### Правила области видимости блока

#### С использованием `var`

Переменные, объявленные через `var`, **не** **имеют** блочной области видимости. Переменные, введённые внутри блока, имеют областью видимости содержащую их функцию или скрипт, и последствия записи в них значения распространяются за границы, собственно, блока, в котором они объявлены. Другими словами, блок инструкций не вводит новую область видимости. Хотя "отдельно стоящие" блоки не являются нарушением синтаксиса, не стоит использовать отдельно стоящие блоки в JavaScript, потому что они не делают то, чего вы от них ожидаете, если вы ожидаете, что они будут себя вести аналогично блокам в C или Java. Например:

```js example-bad
var x = 1;
{
  var x = 2;
}
console.log(x); // выводит 2
```

Тут выводится 2, потому что оператор `var x` внутри блока - в той же области видимости, что и оператор `var x` перед блоком. В C или Java подобный код вывел бы 1.

#### С `let` и `const`

Наоборот, идентификаторы, объявленные с помощью {{jsxref("Statements/let", "let")}} и {{jsxref("Statements/const", "const")}} **имеют** блочную область видимости:

```js
let x = 1;
{
  let x = 2;
}
console.log(x); // выводит 1
```

`x = 2` ограничено рамками области видимости блока, в котором оно было определено.

То же самое и для `const`:

```js
const c = 1;
{
  const c = 2;
}
console.log(c); // выводит 1 и не выбрасывает SyntaxError...
```

Обратите внимание, что объявленная внутри блока `const c = 2` _не_ кидает `SyntaxError: Identifier 'c' has already been declared` (`идентификатор 'c' уже был объявлен`) потому что она может быть объявлена единожды внутри блока.

## Спецификации

{{Specifications}}

## Совместимость с браузерами

{{Compat}}

## Смотрите также

- {{jsxref("Statements/while", "while")}}
- {{jsxref("Statements/if...else", "if...else")}}
- {{jsxref("Statements/let", "let")}}
