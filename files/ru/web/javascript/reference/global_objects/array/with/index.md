---
title: Array.prototype.with()
slug: Web/JavaScript/Reference/Global_Objects/Array/with
l10n:
  sourceCommit: 85d7482697cc2bf407c58e809a2a754180d6714c
---

{{JSRef}}

Метод **`with()`** экземпляров {{jsxref("Array")}} возвращает новый массив, в котором элемент по указанному индексу заменён указанным значением. Является копирующей версией замены значения элемента с помощью [скобочной записи](/ru/docs/Web/JavaScript/Reference/Operators/Property_accessors#скобочная_запись).

## Синтаксис

```js-nolint
arrayInstance.with(index, value)
```

### Параметры

- `index`
  - : Индекс элемента, значение которого надо изменить.
    - Отрицательный индекс позволяет обращаться к элементам с конца массива — если `-array.length <= index < 0`, то используется `index + array.length`.
    - Если индекс находится за пределами допустимых значений, будет вызвана ошибка {{jsxref("RangeError")}}.
- `value`
  - : Новое значение изменяемого элемента.

### Возвращаемое значение

Новый массив, в котором значение элемента с индексом `index` изменено на новое значение `value`.

### Выбрасываемые исключения

- {{jsxref("RangeError")}}
  - : Если `index >= array.length` или `index < -array.length`.

## Описание

Метод `with()` меняет значение элемента массива по заданному индексу, возвращая новый массив с изменённым значением элемента. Исходный массив не меняется. Позволяет создавать цепочку вызовов.

Сочетая `with()` с {{jsxref("Array/at", "at()")}}, вы можете удобно работать с массивами, используя отрицательные индексы для чтения и записи.

Метод `with()`никогда не возвращает разреженный массив. Если исходный массив разреженный, в новом массиве пустые слоты заменяются на `undefined`.

Метод `with()` — это generic. Он получает доступ к элементам массива только через свойство length и элементы с числовыми ключом. Это означает, что он так же может быть вызван на массивоподобных объектах.

## Примеры

### Создание нового массива с одним изменённым элементом

```js
const arr = [1, 2, 3, 4, 5];
console.log(arr.with(2, 6)); // [1, 2, 6, 4, 5]
console.log(arr); // [1, 2, 3, 4, 5]
```

### Создание цепочки вызовов

С методом `with()` вы можете изменить значение одного элемента исходного массива и затем вызвать на получившемся массиве другие методы.

```js
const arr = [1, 2, 3, 4, 5];
console.log(arr.with(2, 6).map((x) => x ** 2)); // [1, 4, 36, 16, 25]
```

### Использование with() с разреженными массивами

Метод `with()` удаляет пустые слоты в массивах.

```js
const arr = [1, , 3, 4, , 6];
console.log(arr.with(0, 2)); // [2, undefined, 3, 4, undefined, 6]
```

### Вызов with() на псевдомассивах

Метод `with()` создаёт и возвращает новый массив. Он читает свойство `length` и обращается к каждому свойству, ключ которого является неотрицательным числом меньшим `length`. По мере обращения к каждому свойству псевдомассива, элементу массива с индексом, равным ключу этого свойства, присваивается значение этого свойства. В итоге элементу массива с индексом `index` присваивается `value`.

```js
const arrayLike = {
  length: 3,
  unrelated: "foo",
  0: 5,
  2: 4,
  3: 3, // игнорируется, так как длина равна трём
};
console.log(Array.prototype.with.call(arrayLike, 0, 1));
// [ 1, undefined, 4 ]
```

## Спецификации

{{Specifications}}

## Совместимость с браузерами

{{Compat}}

## Смотрите также

- [Полифил `Array.prototype.with` в `core-js`](https://github.com/zloirock/core-js#change-array-by-copy)
- [Упорядоченные наборы данных](/ru/docs/Web/JavaScript/Guide/Indexed_collections)
- {{jsxref("Array.prototype.toReversed()")}}
- {{jsxref("Array.prototype.toSorted()")}}
- {{jsxref("Array.prototype.toSpliced()")}}
- {{jsxref("Array.prototype.at()")}}
- {{jsxref("TypedArray.prototype.with()")}}
