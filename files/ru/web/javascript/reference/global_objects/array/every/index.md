---
title: Array.prototype.every()
slug: Web/JavaScript/Reference/Global_Objects/Array/every
---

{{JSRef}}

## Сводка

Метод **`every()`** проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.

> [!NOTE]
> Метод возвращает `true` при любом условии для пустого массива.

## Синтаксис

```
arr.every(callback(currentValue[, index[, array]])[, thisArg])
```

### Параметры

- `callback`

  - : Функция проверки каждого элемента, принимает три аргумента:

    - `currentValue`
      - : Текущий обрабатываемый элемент массива.
    - `index`{{Optional_inline}}
      - : Индекс текущего обрабатываемого элемента массива.
    - `array`{{Optional_inline}}
      - : Массив, по которому осуществляется проход.

- `thisArg`{{Optional_inline}}
  - : Необязательный параметр. Значение, используемое в качестве `this` при выполнении функции `callback`.

### Возвращаемое значение

**`true`** если функция проверки возвращает {{Glossary("truthy")}} значение для каждого элемента массива. Иначе, **`false`**.

## Описание

Метод `every()` вызывает переданную функцию `callback` один раз для каждого элемента, присутствующего в массиве до тех пор, пока не найдёт такой, для которого `callback` вернёт _ложное_ значение (значение, становящееся равным `false` при приведении его к типу {{jsxref("Boolean")}}). Если такой элемент найден, метод `every()` немедленно вернёт `false`. В противном случае, если `callback` вернёт `true` для всех элементов массива, метод `every()` вернёт `true`. Функция `callback` вызывается только для индексов массива, имеющих присвоенные значения; она не вызывается для индексов, которые были удалены или которым значения никогда не присваивались.

Функция `callback` вызывается с тремя аргументами: значением элемента, индексом элемента и массивом, по которому осуществляется проход.

Если в метод `every()` был передан параметр `thisArg`, при вызове `callback` он будет использоваться в качестве значения `this`. В противном случае в качестве значения `this` будет использоваться значение {{jsxref("Global_Objects/undefined", "undefined")}}. В конечном итоге, значение `this`, наблюдаемое из функции `callback`, определяется согласно [обычным правилам определения `this`, видимого из функции](/ru/docs/Web/JavaScript/Reference/Operators/this).

Метод `every()` не изменяет массив, для которого он был вызван.

Диапазон элементов, обрабатываемых методом `every()`, устанавливается до первого вызова функции `callback`. Элементы, добавленные в массив после начала выполнения метода `every()`, не будут посещены функцией `callback`. Если существующие элементы массива изменятся, значения, переданные в функцию `callback`, будут значениями на тот момент времени, когда метод `every()` посетит их; удалённые элементы посещены не будут.

Метод `every()` действует подобно квантору всеобщности в математике. В частности, он вернёт `true` для пустого массива. Это так называемая [бессодержательная истина (vacuously true)](http://en.wikipedia.org/wiki/Vacuous_truth#Vacuous_truths_in_mathematics) — все элементы [пустого множества](http://ru.wikipedia.org/wiki/Пустое_множество) ([англ.](http://en.wikipedia.org/wiki/Empty_set#Common_problems)) удовлетворяют любому заданному условию.

## Примеры

### Пример: проверка размера всех элементов массива

Следующий пример проверяет, являются ли все элементы массива числами, большими 10.

```js
function isBigEnough(element, index, array) {
  return element >= 10;
}
[12, 5, 8, 130, 44].every(isBigEnough); // false
[12, 54, 18, 130, 44].every(isBigEnough); // true
```

### Пример: использование стрелочных функций

[Стрелочные функции](/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions) предоставляют более краткий синтаксис для подобных проверок.

```js
[12, 5, 8, 130, 44].every((elem) => elem >= 10); // false
[12, 54, 18, 130, 44].every((elem) => elem >= 10); // true
```

## Полифил

Метод `every()` был добавлен к стандарту ECMA-262 в 5-м издании; поэтому он может не присутствовать в других реализациях стандарта. Вы можете работать с ним, добавив следующий код в начало ваших скриптов, он позволяет использовать `every()` в реализациях, которые не поддерживают этот метод. Этот алгоритм является точно тем, что описан в ECMA-262 5-го издания; и предполагает что {{jsxref("Object")}} и {{jsxref("TypeError")}} имеют свои первоначальные значения и что `callback.call` вычисляется в оригинальное значение {{jsxref("Function.prototype.call()")}}.

```js
if (!Array.prototype.every) {
  Array.prototype.every = function (callbackfn, thisArg) {
    "use strict";
    var T, k;

    if (this == null) {
      throw new TypeError("this is null or not defined");
    }

    // 1. Положим O равным результату вызова ToObject над значением
    //    this, переданным в качестве аргумента.
    var O = Object(this);

    // 2. Положим lenValue равным результату вызова внутреннего метода Get
    //    объекта O с аргументом "length".
    // 3. Положим len равным ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. Если IsCallable(callbackfn) равен false, выкинем исключение TypeError.
    if (typeof callbackfn !== "function") {
      throw new TypeError();
    }

    // 5. Если thisArg присутствует, положим T равным thisArg; иначе положим T равным undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Положим k равным 0.
    k = 0;

    // 7. Пока k < len, будем повторять
    while (k < len) {
      var kValue;

      // a. Положим Pk равным ToString(k).
      //   Это неявное преобразование для левостороннего операнда в операторе in
      // b. Положим kPresent равным результату вызова внутреннего метода
      //    HasProperty объекта O с аргументом Pk.
      //   Этот шаг может быть объединён с шагом c
      // c. Если kPresent равен true, то
      if (k in O) {
        // i. Положим kValue равным результату вызова внутреннего метода Get
        //    объекта O с аргументом Pk.
        kValue = O[k];

        // ii. Положим testResult равным результату вызова внутреннего метода Call
        //     функции callbackfn со значением T в качестве this и списком аргументов,
        //     содержащим kValue, k и O.
        var testResult = callbackfn.call(T, kValue, k, O);

        // iii. Если ToBoolean(testResult) равен false, вернём false.
        if (!testResult) {
          return false;
        }
      }
      k++;
    }
    return true;
  };
}
```

## Спецификации

{{Specifications}}

## Совместимость с браузерами

{{Compat}}

## Смотрите также

- {{jsxref("Array.prototype.forEach()")}}
- {{jsxref("Array.prototype.some()")}}
- {{jsxref("Array.prototype.find()")}}
- {{jsxref("TypedArray.prototype.every()")}}
