---
title: Intl
slug: Web/JavaScript/Reference/Global_Objects/Intl
---

{{JSRef}}

## Сводка

Объект **`Intl`** является пространством имён для API интернационализации ECMAScript, предоставляющим языка-зависимое сравнение строк, форматирование чисел и дат со временем. Конструкторы объектов {{jsxref("Global_Objects/Collator", "Collator")}}, {{jsxref("Global_Objects/NumberFormat", "NumberFormat")}} и {{jsxref("Global_Objects/DateTimeFormat", "DateTimeFormat")}} являются свойствами объекта `Intl`. На этой странице описаны эти свойства, а также общая функциональность конструкторов интернационализации и других языка-зависимых функций.

## Свойства

- {{jsxref("Global_Objects/Collator", "Intl.Collator")}}
  - : Конструктор _сортировщиков_ — объектов, включающих языка-зависимое сравнение строк.
- {{jsxref("Global_Objects/DateTimeFormat", "Intl.DateTimeFormat")}}
  - : Конструктор объектов, включающих языка-зависимое форматирование даты и времени.
- {{jsxref("Global_Objects/NumberFormat", "Intl.NumberFormat")}}
  - : Конструктор объектов, включающих языка-зависимое форматирование чисел.

## Methods

- {{jsxref("Intl.getCanonicalLocales()")}}
  - : Returns canonical locale names.

## Идентификация и согласование локали

Конструкторы интернационализации, а также некоторые языка-зависимые методы других конструкторов (перечисленные в разделе [Смотрите также](#see_also)) используют общий шаблон для идентификации локалей и определения используемой локали: они все принимают аргументы `locales` и `options` и согласовывают запрошенную локаль (локали) с поддерживаемыми локалями согласно алгоритму, определённому свойством `options.localeMatcher`.

### Аргумент `locales`

Аргумент `locales` должен быть либо строкой, содержащей [языковую метку BCP 47](http://tools.ietf.org/html/rfc5646), либо массивом таких языковых меток. Если аргумент `locales` не предоставлен или не определён, используется локаль по умолчанию среды выполнения.

Языковая метка BCP 47 однозначно определяет язык или локаль (разница между ними весьма расплывчата). В своей самой общей форме она может содержать в следующем порядке: код языка, код письменности и код страны, разделённые символами дефиса. Примеры:

- `"hi"`: хинди.
- `"de-AT"`: немецкий, используемый в Австрии.
- `"zh-Hans-CN"`: упрощённый китайский, используемый в Китае.

Подмётки, определяющие языки, письменности, страны (регионы) и (используется не часто) варианты в языковых метках BCP 47 могут быть найдены в [Реестре языковых подмёток IANA](http://www.iana.org/assignments/language-subtag-registry).

BCP 47 также позволяет использовать расширения, и одно из них имеет значение для функций интернационализации JavaScript: это расширение `"u"` (Unicode). Оно может использоваться для запрашивания настраиваемого языка-зависимого поведения объектов {{jsxref("Global_Objects/Collator", "Collator")}}, {{jsxref("Global_Objects/NumberFormat", "NumberFormat")}} или {{jsxref("Global_Objects/DateTimeFormat", "DateTimeFormat")}}. Примеры:

- `"de-DE-u-co-phonebk"`: использовать вариант телефонной книги немецкого порядка сортировки, который расширяет гласные с умляутами до пар символов: ä → ae, ö → oe, ü → ue.
- `"th-TH-u-nu-thai"`: использовать тайские цифры (๐, ๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙) при форматировании чисел.
- `"ja-JP-u-ca-japanese"`: использовать японский календарь при форматировании даты и времени, так что 2013 год выражается 25-м годом периода Хэйсей или 平成 25.

### Согласование локали

Аргумент `locales`, после вырезания всех расширений Unicode, интерпретируется как приоритетный запрос из приложения. Среда выполнения сравнивает его с доступными локалями в выбирает наилучшую из имеющихся. Существует два алгоритма сравнения: сопоставление `"lookup"` (поиск) следует алгоритму поиска, определённому в [BCP 47](http://tools.ietf.org/html/rfc4647#section-3.4); сопоставление `"best fit"` (наилучший подходящий) позволяет среде выполнения предоставлять локаль, которая, как минимум, но возможно и лучше, подходит для запроса, нежели локаль, найденная с помощью алгоритма поиска. Если приложение не предоставляет аргумент `locales` или среда выполнения не имеет локали, соответствующей запросу, то используется локаль по умолчанию для среды выполнения. Метод сопоставления можно выбрать с помощью свойства аргумента `options` (смотрите ниже).

Если выбранная языковая метка содержит подстроку расширения Unicode, это расширение будет использоваться для настройки сконструированного объекта или поведения функции. Каждый конструктор или функция поддерживают только определённое подмножество ключей, определённых расширением Unicode, и поддерживаемые значения часто зависят от языковой метки. Например, ключ `"co"` (сравнение) поддерживается только объектом {{jsxref("Global_Objects/Collator", "Collator")}}, а его значение `"phonebk"` поддерживается только для немецкого языка.

### Аргумент `options`

Аргумент `options` должен быть объектом со свойствами, которые различаются для конструкторов и функций. Если аргумент `options` не предоставлен или не определён, для всех свойств используются значения по умолчанию.

Одно свойство поддерживается для всех языка-зависимых конструкторов: свойство `localeMatcher`, чьим значением должна быть одна из строк `"lookup"` или `"best fit"` и которое выбирает один из алгоритмов сопоставления локалей, описанных выше.

## Спецификации

{{Specifications}}

## Совместимость с браузерами

{{Compat}}

## Смотрите также

- Введение: [API интернационализации ECMAScript](http://norbertlindenberg.com/2012/12/ecmascript-internationalization-api/index.html)
- Конструкторы

  - {{jsxref("Collator", "Intl.Collator")}}
  - {{jsxref("DateTimeFormat", "Intl.DateTimeFormat")}}
  - {{jsxref("NumberFormat", "Intl.NumberFormat")}}

- Методы

  - {{jsxref("String.prototype.localeCompare()")}}
  - {{jsxref("Number.prototype.toLocaleString()")}}
  - {{jsxref("Date.prototype.toLocaleString()")}}
  - {{jsxref("Date.prototype.toLocaleDateString()")}}
  - {{jsxref("Date.prototype.toLocaleTimeString()")}}
