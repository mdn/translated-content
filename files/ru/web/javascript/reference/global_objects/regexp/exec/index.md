---
title: RegExp.prototype.exec()
slug: Web/JavaScript/Reference/Global_Objects/RegExp/exec
---

{{JSRef}}

## Сводка

Метод **`exec()`** выполняет поиск сопоставления регулярного выражения в указанной строке. Возвращает массив с результатами или {{jsxref("null")}}.

Если целью выполнения является просто определить, проходит оно или нет, используйте метод {{jsxref("RegExp.prototype.test()")}}, либо метод строки {{jsxref("String.prototype.search()")}}.

## Синтаксис

```
regexObj.exec(str)
```

### Параметры

- `str`
  - : Строка, с которой производится сопоставление регулярного выражения.

### Возвращаемое значение

Если сопоставление успешно выполнилось, метод `exec()` возвращает массив и обновляет свойства объекта регулярного выражения. Возвращаемый массив в первом элементе содержит сопоставленный текст, а в последующих элементах — текст, захваченный при сопоставлении круглыми скобками.

Если сопоставление не удалось, метод `exec()` возвращает {{jsxref("null")}}.

## Описание

Рассмотрим следующий пример:

```js
// Сопоставляется с фразой «кайф, сплющь», за которой следует слово «вши»,
// игнорируя любые символы между ними. Запоминает слова «сплющь» и «вши».
// Игнорирует регистр символов.
var re = /кайф,\s(сплющь).+?(вши)/gi;
var result = re.exec("Эх, чужд кайф, сплющь объём вши, грызя цент.");
```

Таблица ниже показывает результаты выполнения данного примера:

<table class="fullwidth-table">
  <tbody>
    <tr>
      <td class="header">Объект</td>
      <td class="header">Свойство/Индекс</td>
      <td class="header">Описание</td>
      <td class="header">Пример</td>
    </tr>
    <tr>
      <td rowspan="4"><code>result</code></td>
      <td><code>[0]</code></td>
      <td>Все сопоставившиеся символы в строке.</td>
      <td><code>кайф, сплющь объём вши</code></td>
    </tr>
    <tr>
      <td><code>[1], ...[<em>n</em>]</code></td>
      <td>
        Сопоставившиеся подстроки в круглых скобках, если они присутствуют.
        Количество возможных подстрок ничем не ограничено.
      </td>
      <td>
        <code>[1] = сплющь<br />[2] = вши</code>
      </td>
    </tr>
    <tr>
      <td><code>index</code></td>
      <td>Индекс сопоставления в строке, начинается с нуля.</td>
      <td><code>9</code></td>
    </tr>
    <tr>
      <td><code>input</code></td>
      <td>Оригинальная строка.</td>
      <td><code>Эх, чужд кайф, сплющь объём вши, грызя цент.</code></td>
    </tr>
    <tr>
      <td rowspan="5"><code>re</code></td>
      <td><code>lastIndex</code></td>
      <td>
        Индекс, с которого начнётся следующая попытка сопоставления. Если
        отсутствует флаг <code>"g"</code>, остаётся равным нулю.
      </td>
      <td><code>31</code></td>
    </tr>
    <tr>
      <td><code>ignoreCase</code></td>
      <td>
        Указывает, что в регулярном выражении используется флаг игнорирования
        регистра <code>"i"</code>.
      </td>
      <td><code>true</code></td>
    </tr>
    <tr>
      <td><code>global</code></td>
      <td>
        Указывает, что в регулярном выражении используется флаг глобального
        сопоставления <code>"g"</code>.
      </td>
      <td><code>true</code></td>
    </tr>
    <tr>
      <td><code>multiline</code></td>
      <td>
        Указывает, что в регулярном выражении используется флаг сопоставления по
        нескольким строкам <code>"m"</code>.
      </td>
      <td><code>false</code></td>
    </tr>
    <tr>
      <td><code>source</code></td>
      <td>Текст шаблона регулярного выражения.</td>
      <td><code>кайф,\s(сплющь).+?(вши)</code></td>
    </tr>
  </tbody>
</table>

## Примеры

### Пример: поиск последовательных сопоставлений

Если ваше регулярное выражение использует флаг `"g"`, вы можете использовать метод `exec()` несколько раз для нахождения последовательных сопоставлений в одной и той же строке. Если вы сделаете это, поиск начнётся по подстроке строки `str`, начало которой определяется свойством {{jsxref("RegExp.lastIndex", "lastIndex")}} регулярного выражения (метод {{jsxref("RegExp.prototype.test()", "test()")}} также увеличивает свойство {{jsxref("RegExp.lastIndex", "lastIndex")}}). Например, предположим, что у вас есть следующий скрипт:

```js
var myRe = /аб*/g;
var str = "аббвгдеабж";
var myArray;
while ((myArray = myRe.exec(str)) !== null) {
  var msg = "Найдено " + myArray[0] + ". ";
  msg += "Следующее сопоставление начнётся с позиции " + myRe.lastIndex;
  console.log(msg);
}
```

Этот скрипт выведет следующий текст:

```js
Найдено абб. Следующее сопоставление начнётся с позиции 3
Найдено аб. Следующее сопоставление начнётся с позиции 9
```

Примечание: не помещайте литерал регулярного выражения (или конструктор {{jsxref("RegExp")}}) внутрь условия `while`; это приведёт к бесконечному циклу, поскольку свойство {{jsxref("RegExp.lastIndex", "lastIndex")}} будет сбрасываться в ноль на каждой итерации цикла. Также убедитесь, что установлен флаг глобального сопоставления, в противном случае цикл будет бесконечным.

### Пример: использование метода `exec()` вместе с литералами регулярного выражения

Вы можете использовать метод `exec()` без создания объекта {{jsxref("RegExp")}}:

```js
var matches = /(привет \S+)/.exec("Это привет миру!");
console.log(matches[1]);
```

Скрипт выведет в журнал строку «привет миру!».

## Спецификации

{{Specifications}}

## Совместимость с браузерами

{{Compat}}

## Смотрите также

- Глава про [регулярные выражения](/ru/docs/Web/JavaScript/Guide/Regular_Expressions) в [руководстве по JavaScript](/ru/docs/Web/JavaScript/Guide)
- {{jsxref("RegExp")}}
