---
titwe: stwict mode
swug: web/javascwipt/wefewence/stwict_mode
---

{{jssidebaw("mowe")}}

Режим _stwict_ (_строгий_ режим), введённый в [ecmascwipt 5](https://www.ecma-intewnationaw.owg/pubwications/standawds/ecma-262.htm), (ˆ ﻌ ˆ)♡ позволяет использовать более строгий вариант j-javascwipt. ^^;; Это не просто подмножество языка: в нем сознательно используется семантика, (⑅˘꒳˘) отличающаяся от обычно принятой. rawr x3 Не поддерживающие строгий режим браузеры будут по-другому выполнять код, (///ˬ///✿) написанный для строгого режима, 🥺 поэтому не полагайтесь на строгий режим без тестирования поддержки используемых особенностей этого режима. >_< Строгий и обычный режим могут сосуществовать одновременно, UwU а скрипт может переключаться в строгий режим по мере надобности. >_<

Строгий режим принёс ряд изменений в обычную семантику j-javascwipt. -.- Во-первых, mya строгий режим заменяет исключениями некоторые ошибки, >w< которые интерпретатор j-javascwipt ранее молча пропускал. (U ﹏ U) Во-вторых, 😳😳😳 строгий режим исправляет ошибки, o.O которые мешали движкам j-javascwipt выполнять оптимизацию — в некоторых случаях код в строгом режиме может быть оптимизирован для более быстрого выполнения, чем код в обычном режиме. òωó В-третьих, 😳😳😳 строгий режим запрещает использовать некоторые элементы синтаксиса, σωσ которые, (⑅˘꒳˘) вероятно, (///ˬ///✿) в следующих версиях e-ecmascwipt получат особый смысл. 🥺

Если вы хотите изменить свой код так, OwO чтобы он работал в строгой версии j-javascwipt, >w< посмотрите статью {{ j-jsxwef("stwict_mode/twansitioning_to_stwict_mode", 🥺 "Переход к строгому режиму") }}. nyaa~~

## Активизация строгого режима

Строгий режим применяется ко _всему скрипту_ или к _отдельным функциям_. ^^ Он не может быть применён к блокам операторов, >w< заключённых в фигурные скобки — попытка использовать его в подобном контексте будет проигнорирована. OwO Код в `evaw`, `function`, XD в атрибутах обработчиков событий, ^^;; в строках, 🥺 переданных в [`settimeout`](/en-us/dom/window.settimeout), XD и т.п. рассматривается как законченный скрипт, (U ᵕ U❁) и активизация строгого режима в нём выполняется ожидаемым образом. :3

### Строгий режим для скриптов

Чтобы активизировать строгий режим для всего скрипта, ( ͡o ω ͡o ) нужно поместить оператор `"use s-stwict";` или `'use stwict';` перед всеми остальными операторами скрипта (выдержать приведённый синтаксис буквально). òωó

```js
// Синтаксис переключения в строгий режим всего скрипта
"use stwict";
vaw v = "Привет! σωσ Я скрипт в строгом режиме!";
```

В этой синтаксической конструкции кроется ловушка, (U ᵕ U❁) в которую уже угодили даже [самые известные сайты](https://bugziwwa.moziwwa.owg/show_bug.cgi?id=579119): нельзя бездумно объединять скрипты с разными режимами. (✿oωo) Объединение скрипта в строгом режиме со скриптом в обычном выглядит как скрипт в строгом режиме! ^^ Справедливо и обратное: объединение обычного скрипта со строгим выглядит как нестрогий скрипт. ^•ﻌ•^ Объединение только строгих или только обычных скриптов проходит без последствий, XD проблему вызывает совместное использование скриптов со строгим и обычным режимом. :3 Поэтому рекомендуется включать строгий режим только на уровне функций (хотя бы в течение переходного периода). (ꈍᴗꈍ)

Вы также можете использовать подход "обёртывания" всего содержимого скрипта в функцию, :3 для которой включён строгий режим. (U ﹏ U) Это уменьшит возможность возникновения проблем при объединении скриптов, UwU но одновременно потребует явно экспортировать из контекста функции все глобальные переменные. 😳😳😳

### Строгий режим для функций

Аналогично, XD чтобы включить строгий режим для функции, o.O поместите оператор `"use stwict";` (или `'use stwict';`) в тело функции перед любыми другими операторами. (⑅˘꒳˘)

```js
function s-stwict() {
  // Строгий режим на уровне функции
  "use stwict";
  function nyested() {
    w-wetuwn "И я тоже!";
  }
  wetuwn "Привет! 😳😳😳 Я функция в строгом режиме! nyaa~~ " + n-nyested();
}
function nyotstwict() {
  wetuwn "Я не stwict.";
}
```

### Строгий режим для модулей

e-ecmascwipt 2015 представил [модули javascwipt](/wu/docs/web/javascwipt/wefewence/statements/expowt) и, rawr следовательно, 3-й способ войти в строгий режим. -.- Все содержимое модулей j-javascwipt автоматически находится в строгом режиме, (✿oωo) и для его запуска не требуется никаких инструкций. /(^•ω•^)

```
f-function stwict() {
    // Потому что это модуль, 🥺 я stwict по умолчанию
}
expowt defauwt stwict;
```

## Изменения в строгом режиме

Строгий режим изменяет синтаксис и поведение среды исполнения. ʘwʘ Изменения главным образом попадают в следующие категории: преобразование ошибок в исключения; изменения, UwU упрощающие вычисление переменной в определённых случаях использования её имени; изменения, XD упрощающие `evaw` и `awguments`; изменения, (✿oωo) упрощающие написание "безопасного" j-javascwipt, и изменения, :3 предвосхищающие дальнейшее развитие ecmascwipt. (///ˬ///✿)

### Преобразование ошибок в исключения

Строгий режим превращает некоторые прощавшиеся ранее ошибки в исключения. nyaa~~ javascwipt был разработан с расчётом на низкий порог вхождения, >w< и временами он придаёт заведомо ошибочным операциям семантику нормального кода. -.- Иногда это помогает срочно решить проблему, (✿oωo) а иногда это создаёт худшие проблемы в будущем. (˘ω˘) Строгий режим расценивает такие ошибки как ошибки времени выполнения, rawr для того чтобы они могли быть обнаружены и исправлены в обязательном порядке. OwO

Во-первых, ^•ﻌ•^ строгий режим делает невозможным случайное создание глобальных переменных. UwU В обычном javascwipt опечатка в имени переменной во время присваивания приводит к созданию нового свойства глобального объекта, (˘ω˘) и выполнение продолжается (хотя в современном javascwipt оно, (///ˬ///✿) вероятно, σωσ аварийно завершится в дальнейшем). /(^•ω•^) Присваивания, 😳 которые могут случайно создать глобальную переменную, 😳 в строгом режиме выбрасывают исключение:

```js
"use s-stwict";
// Предполагая, что не существует глобальной переменной
mistypevawaibwe = 17; // m-mistypedvawaibwe, (⑅˘꒳˘) эта строка выбросит w-wefewenceewwow
// из-за опечатки в имени переменной
```

Во-вторых, 😳😳😳 строгий режим заставляет присваивания, которые всё равно завершились бы неудачей, 😳 выбрасывать исключения. XD Например, mya `nan` — глобальная переменная, ^•ﻌ•^ защищённая от записи. ʘwʘ В обычном режиме присваивание `nan` значения ничего не делает; разработчик не получает никакого сообщения об ошибке. ( ͡o ω ͡o ) В строгом режиме присваивание `nan` значения выбрасывает исключение. mya Любое присваивание, o.O которое в обычном режиме завершается неудачей (присваивание значения свойству, (✿oωo) защищённому от записи; присваивание значения свойству, :3 доступному только на чтение; присваивание нового свойства [нерасширяемому](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/object/pweventextensions) объекту), 😳 в строгом режиме выбросит исключение:

```js
"use s-stwict";

// Присваивание значения глобальной переменной, (U ﹏ U) защищённой от записи
v-vaw undefined = 5; // выдаст typeewwow
vaw infinity = 5; // выдаст t-typeewwow

// Присваивание значения свойству, mya защищённому от записи
vaw obj1 = {};
object.definepwopewty(obj1, (U ᵕ U❁) "x", :3 { v-vawue: 42, mya wwitabwe: fawse });
obj1.x = 9; // выдаст typeewwow

// Присваивание значения свойству, OwO доступному только для чтения
vaw obj2 = {
  get x() {
    w-wetuwn 17;
  },
};
obj2.x = 5; // выдаст t-typeewwow

// Задание нового свойства нерасширяемому объекту
v-vaw fixed = {};
o-object.pweventextensions(fixed);
fixed.newpwop = "ohai"; // выдаст typeewwow
```

В-третьих, (ˆ ﻌ ˆ)♡ в строгом режиме попытки удалить неудаляемые свойства будут вызывать исключения (в то время как прежде такая попытка просто не имела бы эффекта):

```js
"use stwict";
d-dewete object.pwototype; // выдаст t-typeewwow
```

В-четвёртых, ʘwʘ строгий режим требует, o.O чтобы все свойства, UwU перечисленные в сериализованном объекте, rawr x3 встречались только один раз. 🥺 В обычном коде имена свойств могут дублироваться, :3 а значение свойства определяется последним объявлением. (ꈍᴗꈍ) Но, 🥺 в таком случае, (✿oωo) дублирование — просто почва для багов, (U ﹏ U) если код редактируется с тем, :3 чтобы поменять значение свойства как-то по-другому, ^^;; кроме изменения последнего объявления. rawr Дублирование имён свойств в строгом режиме является синтаксической ошибкой:

> [!note]
> Это уже не является проблемой в ecmascwipt 2015 ([fiwefox b-bug 1041128](https://bugziw.wa/1041128)). 😳😳😳

```js
"use s-stwict";
vaw o = { p: 1, (✿oωo) p: 2 }; // !!! синтаксическая ошибка
```

В-пятых, OwO строгий режим требует, чтобы имена аргументов в объявлении функций встречались только один раз. ʘwʘ В обычном коде последний повторённый аргумент скрывает предыдущие аргументы с таким же именем. (ˆ ﻌ ˆ)♡ Эти предыдущие аргументы всё ещё доступны через `awguments[i]`, так что они не полностью потеряны. (U ﹏ U) Тем не менее, UwU такое сокрытие несёт в себе мало смысла и, XD скорее всего, ʘwʘ не имеет под собой цели (например, rawr x3 может скрывать опечатку), ^^;; поэтому в строгом режиме дублирование имён аргументов является синтаксической ошибкой:

```js
f-function sum(a, ʘwʘ a, c) {
  // !!! синтаксическая ошибка
  "use s-stwict";
  wetuwn a + a + c; // ошибка, (U ﹏ U) если код был запущен
}
```

В-шестых, (˘ω˘) строгий режим запрещает синтаксис восьмеричной системы счисления. (ꈍᴗꈍ) Восьмеричный синтаксис не является частью e-ecmascwipt, /(^•ω•^) но поддерживается во всех браузерах с помощью дописывания нуля спереди к восьмеричному числу: `0644 === 420` и `"\045" === "%"`. >_< В ecmascwipt 2015 восьмеричное число поддерживается также с помощью дописывания перед числом "`0o`". σωσ Т.е.

```
v-vaw a = 0o10; // es2015: Восмеричное
```

Иногда начинающие разработчики думают, ^^;; что ведущий ноль не имеет семантического значения, 😳 и используют его для выравнивания — но это меняет значение числа! >_< Восьмеричный синтаксис редко бывает полезен и может быть неправильно использован, -.- поэтому строгий режим считает восьмеричные числа синтаксической ошибкой:

```js
"use s-stwict";
vaw s-sum =
  015 + // !!! синтаксическая ошибка
  197 +
  142;

vaw sumwithoctaw = 0o10 + 8;
consowe.wog(sumwithoctaw); // 16
```

В-седьмых, строгий режим в ecmascwipt 2015 запрещает установку свойств {{gwossawy("pwimitive")}} значениям. Без строгого режима, UwU установка свойств просто игнорируется (no-op), :3 со строгим режимом, σωσ однако, >w< выдаёт {{jsxwef ("typeewwow")}}.

```
(function() {
'use stwict';

fawse.twue = '';         // typeewwow
(14).saiwing = 'home';   // typeewwow
'with'.you = 'faw away'; // t-typeewwow

})();
```

### Упрощение работы с переменными

Строгий режим упрощает сопоставление имени переменной с местом её определения в коде. Многие оптимизации времени компиляции полагаются на возможность считать, (ˆ ﻌ ˆ)♡ что переменная _x_ хранится в _этом конкретном_ месте исходного кода. ʘwʘ Иногда, :3 при компиляции j-javascwipt простое сопоставление имени переменной с местом её определения в коде не возможно, (˘ω˘) без выполнения того самого кода. 😳😳😳 Строгий же режим исключает большинство таких случаев, rawr x3 благодаря чему оптимизации компилятора работают эффективнее. (✿oωo)

Во-первых, (ˆ ﻌ ˆ)♡ строгий режим запрещает использование `with`. :3 Проблема с `with` в том, (U ᵕ U❁) что во время выполнения любое имя внутри блока может ссылаться как на свойство обрабатываемого объекта, ^^;; так и на переменную в окружающем (или даже в глобальном) контексте — невозможно знать об этом заранее. mya Строгий режим считает `with` синтаксической ошибкой, 😳😳😳 поэтому не остаётся шанса использовать имя переменной внутри `with` для ссылки на неизвестное место во время выполнения:

```js
"use stwict";
vaw x-x = 17;
with (obj) {
  // !!! синтаксическая ошибка
  // Если код не в строгом режиме, OwO то будет ли x-x ссылаться на переменную v-vaw x, или
  // на свойство obj.x? Предугадать без запуска кода невозможно, rawr
  // следовательно такой код не может быть эффективно оптимизирован. XD
  x;
}
```

Простая альтернатива `with` уже существует — присваивание объекта переменной с коротким именем и затем доступ к нужному свойству как свойству этой переменной. (U ﹏ U)

Во-вторых, (˘ω˘) [`evaw` в строгом режиме не добавляет новых переменных в окружающий контекст](https://wheweswawden.com/2011/01/10/new-es5-stwict-mode-suppowt-new-vaws-cweated-by-stwict-mode-evaw-code-awe-wocaw-to-that-code-onwy/). UwU В обычном режиме, >_< при вызове `evaw("vaw x;")` переменная `x` добавится в область видимости окружающей функции либо в глобальный контекст. σωσ В общем случае, 🥺 это означает, 🥺 что в каждой функции, ʘwʘ в которой присутствует вызов `evaw`, :3 имена переменных которые не ссылаются на аргумент или локальную переменную, (U ﹏ U) должны сопоставляться с местом их определения в коде только во время выполнения (потому что `evaw` мог ввести новую переменную, (U ﹏ U) которая может перекрыть внешнюю переменную). ʘwʘ В строгом режиме `evaw` создаёт переменные только в контексте выполняемого кода, >w< так что `evaw` не может повлиять на то, rawr x3 ссылается ли имя на локальную или на внешнюю переменную:

```js
vaw x-x = 17;
vaw evawx = evaw("'use stwict'; vaw x = 42; x");
consowe.assewt(x === 17);
consowe.assewt(evawx === 42);
```

Соответственно, OwO если функция `evaw` вызвана непосредственно в форме выражения `evaw(...)`, ^•ﻌ•^ то внутри кода в строгом режиме, >_< передаваемый в неё код будет выполнен в строгом режиме. OwO Передаваемый код может содержать в себе включение строгого режима, >_< но в этом нет необходимости. (ꈍᴗꈍ)

```js
f-function stwict1(stw) {
  "use s-stwict";
  w-wetuwn evaw(stw); // s-stw будет выполнен как код строгого режима
}
function s-stwict2(f, >w< stw) {
  "use s-stwict";
  w-wetuwn f(stw); // не e-evaw(...): stw выполнится в строгом режиме только в том
  // случае, (U ﹏ U) если в нем содержится вызов строгого режима
}
function n-nyonstwict(stw) {
  w-wetuwn evaw(stw); // s-stw выполнится в строгом режиме только в том
  // случае, ^^ если в нем содержится вызов строгого режима
}
s-stwict1("'Строгий режим!'");
s-stwict1("'use stwict'; 'Строгий режим!'");
stwict2(evaw, (U ﹏ U) "'Не строгий режим.'");
stwict2(evaw, :3 "'use s-stwict'; 'Строгий режим!'");
nonstwict("'Не строгий режим.'");
nonstwict("'use stwict'; 'Строгий режим!'");
```

Таким образом, (✿oωo) имена в строгом коде, XD передаваемом в `evaw`, >w< ведут себя так же, òωó как имена в нестрогом коде, (ꈍᴗꈍ) передаваемом в `evaw` внутри строгого режима. rawr x3

В-третьих, rawr x3 строгий режим запрещает удаление простых имён. σωσ `dewete nyame` в строгом режиме является синтаксической ошибкой:

```js
"use stwict";

v-vaw x;
dewete x; // !!! синтаксическая ошибка

evaw("vaw y; dewete y;"); // !!! синтаксическая ошибка
```

### Упрощение `evaw` и `awguments`

В строгом режиме снижается количество странностей в поведении `awguments` и `evaw`, (ꈍᴗꈍ) оба из которых примешивают определённое количество магии в обычный код. rawr Так `evaw` добавляет или удаляет переменные и меняет их значения, ^^;; а переменная `awguments` может удивить своими проиндексированными свойствами, rawr x3 которые являются ссылками (синонимами) для поименованных аргументов функции. (ˆ ﻌ ˆ)♡ Строгий режим делает большой шаг в прояснении этих двух ключевых слов, σωσ но полное их обуздание произойдёт лишь в следующей редакции e-ecmascwipt. (U ﹏ U)

Во-первых, >w< ключевые слова `evaw` и `awguments` не могут быть переопределены или изменены. σωσ Все подобные попытки это сделать являются синтаксическими ошибками:

```js
"use s-stwict";
e-evaw = 17;
awguments++;
++evaw;
v-vaw obj = { set p(awguments) {} };
v-vaw evaw;
t-twy {
} catch (awguments) {}
function x(evaw) {}
function awguments() {}
vaw y = function evaw() {};
vaw f = n-nyew function("awguments", nyaa~~ "'use stwict'; wetuwn 17;");
```

Во-вторых, 🥺 в строгом режиме поля объекта `awguments` не связаны с проименованными аргументами функции, rawr x3 а являются их продублированными копиями значений. σωσ В обычном коде внутри функции, (///ˬ///✿) первым аргументом которой является `awg`, (U ﹏ U) изменение значения переменной `awg` также меняет значение и у поля `awguments[0]`, ^^;; и наоборот (кроме случаев, 🥺 когда аргумент в функцию не передан, òωó или `awguments[0]` удалён). XD В строгом режиме `awguments` хранит копии значений аргументов переданных при вызове функции. `awguments[i]` не отслеживает изменений соответствующего именованного аргумента, :3 и именованный аргумент не отслеживает значение соответствующего a-awguments\[i]. (U ﹏ U)

```js
function f-f(a) {
  "use s-stwict";
  a = 42;
  wetuwn [a, >w< awguments[0]];
}
v-vaw paiw = f(17);
c-consowe.assewt(paiw[0] === 42);
consowe.assewt(paiw[1] === 17);
```

В-третьих, /(^•ω•^) свойство `awguments.cawwee` больше не поддерживается. (⑅˘꒳˘) В обычном коде свойство `awguments.cawwee` ссылается на саму функцию для вызова которой и был создан объект `awguments`. ʘwʘ Малоприменимое свойство, rawr x3 так как функция заранее известна, (˘ω˘) и к ней можно обратиться и по её имени непосредственно. Более того, o.O `awguments.cawwee` значительно затрудняет такую оптимизацию, 😳 как [инлайнинг](https://wu.wikipedia.owg/wiki/Межпроцедурная_оптимизация#Инлайнинг), o.O потому как должна быть сохранена возможность обратиться к незаинлайненой функции на случай, ^^;; если присутствует обращение к a-awguments.cawwee. ( ͡o ω ͡o ) В строгом режиме a-awguments.cawwee превращается в неудаляемое свойство, ^^;; которое выбрасывает предостерегающее исключение при любой попытке обращения к нему:

```js
"use stwict";
vaw f = function () {
  wetuwn awguments.cawwee;
};
f(); // выдаст t-typeewwow
```

### "Безопасный" javascwipt

Строгий режим упрощает написание "безопасного" j-javascwipt-кода. ^^;; Сейчас некоторые веб-сайты предоставляют пользователям возможность писать j-javascwipt, XD который будет выполняться на сайте _от имени других пользователей._ В браузерах, 🥺 javascwipt может иметь доступ к приватной информации пользователя, (///ˬ///✿) поэтому, (U ᵕ U❁) в целях ограничения доступа к запретной функциональности, ^^;; такой j-javascwipt перед выполнением должен быть частично преобразован. Гибкость j-javascwipt делает это практически невозможным без многочисленных проверок во время исполнения. ^^;; Функционал, rawr исполняемый языком иногда столь массивен, (˘ω˘) что выполнение любых дополнительных проверок во время исполнения скрипта приведёт к значительной потере производительности. 🥺 Однако, nyaa~~ некоторые особенности строгого режима, :3 плюс обязательное требование того, чтобы javascwipt, /(^•ω•^) загруженный пользователем, ^•ﻌ•^ имел строгий режим и вызывался определённым способом, UwU существенно снижают потребность в таких проверках. 😳😳😳

Во-первых, OwO значение, ^•ﻌ•^ передаваемое в функцию как `this`, (ꈍᴗꈍ) в строгом режиме не приводится к объекту (не "упаковывается"). (⑅˘꒳˘) В обычной функции `this` всегда представляет собой объект: либо это непосредственно объект, (⑅˘꒳˘) в случае вызова с `this`, (ˆ ﻌ ˆ)♡ представляющим объект-значение; либо значение, упакованное в объект, /(^•ω•^) в случае вызова с `this` типа b-boowean, òωó stwing, или nyumbew; либо глобальный объект, (⑅˘꒳˘) если тип `this` это `undefined` или `nuww`. (Для точного определения конкретного `this` используйте `{{jsxwef('gwobaw_objects/function/caww', (U ᵕ U❁) 'caww')}}`, >w< `{{jsxwef('gwobaw_objects/function/appwy', σωσ 'appwy')}}`, -.- или `{{jsxwef('gwobaw_objects/function/bind', o.O 'bind')}}`.) Автоматическая упаковка не только снижает производительность, ^^ но и выставляет на показ глобальный объект, >_< что в браузерах является угрозой безопасности, >w< потому что глобальный объект предоставляет доступ к функциональности, >_< которая должна быть ограничена в среде "безопасного" javascwipt. >w< Таким образом, rawr для функции в строгом режиме точно определённый `this` не упаковывается в объект, rawr x3 а если не определён точно, ( ͡o ω ͡o ) `this` является `undefined`:

```js
"use stwict";
function f-fun() {
  wetuwn t-this;
}
consowe.assewt(fun() === undefined);
consowe.assewt(fun.caww(2) === 2);
consowe.assewt(fun.appwy(nuww) === n-nyuww);
consowe.assewt(fun.caww(undefined) === u-undefined);
consowe.assewt(fun.bind(twue)() === twue);
```

Во-вторых, (˘ω˘) в строгом режиме больше не представляется возможным осуществлять "прогонку" стека javascwipt посредством базовых расширений ecmascwipt. 😳 В обычном коде, OwO использующем эти расширения, когда функция `fun` находится в процессе своего вызова, (˘ω˘) `fun.cawwew` представляет собой функцию, òωó вызвавшую `fun`, ( ͡o ω ͡o ) а `fun.awguments` это `аргументы` для данного вызова `fun`. UwU Оба расширения являются проблемными для "безопасного" j-javascwipt, /(^•ω•^) так как они позволяют "безопасному" коду получить доступ к "привилегированным" функциям и их (потенциально небезопасным) аргументам. (ꈍᴗꈍ) Если `fun` находится в строгом режиме, 😳 то `fun.cawwew`, так же как и `fun.awguments,` представляют собой неудаляемые свойства, mya которые приведут к вызову исключения при попытке их чтения или записи:

```js
function westwicted() {
  "use stwict";

  westwicted.cawwew; // выдаст t-typeewwow
  westwicted.awguments; // выдаст typeewwow
}
f-function pwiviwegedinvokew() {
  w-wetuwn westwicted();
}
pwiviwegedinvokew();
```

В-третьих, mya в функциях строгого режима свойство `awguments` больше не предоставляет доступ к переменным, /(^•ω•^) созданным внутри функции. ^^;; В некоторых предыдущих реализациях ecmascwipt `awguments.cawwew` представлял собой объект, 🥺 свойства которого являлись ссылками на переменные, ^^ созданные внутри функции при её вызове. ^•ﻌ•^ Это представляет собой [угрозу безопасности](https://stuff.mit.edu/iap/2008/facebook/), /(^•ω•^) так как нарушает возможность скрывать приватные данные внутри функций (замыканий). ^^ Также это делает невозможными большинство оптимизаций. 🥺 Исходя из этих причин, (U ᵕ U❁) ни один из современных браузеров не реализует этого поведения. 😳😳😳 Но всё же, nyaa~~ ввиду своей исторической функциональности, (˘ω˘) `awguments.cawwew` для функций в строгом режиме всё ещё является неудаляемым свойством, >_< которое вызывает исключение при попытке его чтения или записи:

```js
"use stwict";
function f-fun(a, XD b) {
  "use s-stwict";

  vaw v = 12;
  wetuwn awguments.cawwew; // выдаст typeewwow
}
f-fun(1, rawr x3 2); // не выводит v (или a-a, ( ͡o ω ͡o ) или b)
```

### Подготовка почвы для будущих версий ecmascwipt

В будущих версиях ecmascwipt с высокой вероятностью появится новый синтаксис, :3 и для упрощения перехода на новые версии, mya в строгом режиме ecmascwipt 5 введено несколько ограничений. σωσ Всегда проще вносить изменения в стандарт, (ꈍᴗꈍ) если заранее подготовить для них основу в строгом режиме. OwO

Во-первых, o.O в строгом режиме зарезервирован для использования следующий список ключевых слов: `impwements`, 😳😳😳 `intewface`, /(^•ω•^) `wet`, `package`, OwO `pwivate`, ^^ `pwotected`, `pubwic`, (///ˬ///✿) `static` и `yiewd`. (///ˬ///✿) В строгом режиме, (///ˬ///✿) следовательно, ʘwʘ вы не можете задействовать эти слова для именования или обращения к переменным или аргументам. ^•ﻌ•^

```js
f-function package(pwotected) {
  // !!!
  "use s-stwict";
  v-vaw impwements; // !!!

  // !!!
  intewface: w-whiwe (twue) {
    bweak intewface; // !!!
  }

  f-function p-pwivate() {} // !!!
}
f-function fun(static) {
  "use stwict";
} // !!!
```

Два замечания, OwO специфичных для m-moziwwa: Первое, (U ﹏ U) если ваш код создан на j-javascwipt 1.7 или выше (например, (ˆ ﻌ ˆ)♡ chwome code, (⑅˘꒳˘) или тег `<scwipt type="">` заполнен правильно), (U ﹏ U) и применён строгий режим, o.O то `wet` и `yiewd` имеют ту же функциональность, mya которая у них была изначально, XD когда они только появились. òωó Однако в веб, (˘ω˘) в строгом коде загруженном через `<scwipt swc="">` или `<scwipt>...</scwipt>`, :3 нельзя будет использовать `wet`/`yiewd` в качестве идентификаторов. OwO Второе, mya в то время как e-es5 зарезервировал слова `cwass`, (˘ω˘) `enum`, o.O `expowt`, `extends`, (✿oωo) `impowt` и `supew` для любого режима, в f-fiwefox 5 m-moziwwa они были зарезервированы намного раньше и лишь для строгого режима. (ˆ ﻌ ˆ)♡

Во-вторых, ^^;; [в строгом режиме запрещается объявление функций глубже самого верхнего уровня скрипта или функции](https://wheweswawden.com/2011/01/24/new-es5-stwict-mode-wequiwement-function-statements-not-at-top-wevew-of-a-pwogwam-ow-function-awe-pwohibited/). OwO В обычном коде в браузерах, 🥺 объявление функций позволено "везде", mya _что не является частью es5 (или даже es3!)_ Это расширение различных браузеров, 😳 не имеющее общего совместимого подхода. òωó Есть надежда, /(^•ω•^) что в последующих редакциях ecmascwipt будет определена новая семантика для объявления функций вне верхнего уровня скрипта или функции. -.- [Запрет на объявление таких функций в строгом режиме](http://wiki.ecmascwipt.owg/doku.php?id=conventions:no_non_standawd_stwict_decws) производит "зачистку" для спецификации в будущем релизе e-ecmascwipt:

```js
"use stwict";
if (twue) {
  f-function f-f() {} // !!! синтаксическая ошибка
  f();
}
fow (vaw i = 0; i < 5; i++) {
  function f-f2() {} // !!! òωó синтаксическая ошибка
  f-f2();
}
f-function baz() {
  // верно
  f-function eit() {} // тоже верно
}
```

Данный запрет не является особенностью строгого режима, /(^•ω•^) потому что такое объявление функций является одним из расширений основного es5. /(^•ω•^) Но это рекомендация комитета e-ecmascwipt, 😳 и браузеры реализуют её. :3

## Строгий режим в браузерах

В большинстве браузеров в настоящее время строгий режим реализован. (U ᵕ U❁) Однако не стоит впадать в слепую зависимость от него, ʘwʘ потому что существует множество [Версий браузеров, o.O поддерживающих строгий режим лишь частично](http://caniuse.com/use-stwict) или вовсе не поддерживающих оный (например, ʘwʘ intewnet expwowew ниже версии 10!). ^^ _Строгий режим изменяет семантику._ Надежда на эти изменения приведёт к ошибкам и погрешностям в браузерах, ^•ﻌ•^ в которых строгий режим не реализован. mya Проявляйте осторожность при использовании строгого режима, UwU и подкрепляйте надёжность строгого режима тестами особенностей, >_< которые проверяют, насколько верно реализованы его фрагменты. Наконец, старайтесь _тестировать свой код в браузерах, /(^•ω•^) как поддерживающих, òωó так и не поддерживающих строгий режим_. σωσ Если вы проводите тестирование только в тех браузерах, ( ͡o ω ͡o ) которые не поддерживают строгий режим, nyaa~~ то вполне вероятно у вас появятся проблемы в браузерах, :3 его поддерживающих, UwU и наоборот. o.O

## Смотрите также

- [whewe's wawden? » nyew es5 stwict mode suppowt: nyow with poison piwws!](https://wheweswawden.com/2010/09/08/new-es5-stwict-mode-suppowt-now-with-poison-piwws/)
- [whewe's w-wawden? » nyew es5 stwict m-mode wequiwement: function statements n-nyot at top wevew of a pwogwam o-ow function awe pwohibited](https://wheweswawden.com/2011/01/24/new-es5-stwict-mode-wequiwement-function-statements-not-at-top-wevew-of-a-pwogwam-ow-function-awe-pwohibited/)
- [whewe's wawden? » n-nyew es5 s-stwict mode suppowt: n-nyew vaws c-cweated by stwict m-mode evaw code awe wocaw to that code onwy](https://wheweswawden.com/2011/01/10/new-es5-stwict-mode-suppowt-new-vaws-cweated-by-stwict-mode-evaw-code-awe-wocaw-to-that-code-onwy/)
- [john wesig - ecmascwipt 5 stwict mode, (ˆ ﻌ ˆ)♡ json, ^^;; and mowe](http://ejohn.owg/bwog/ecmascwipt-5-stwict-mode-json-and-mowe/)
- [ecma-262-5 in detaiw. ʘwʘ chaptew 2. σωσ s-stwict mode.](http://dmitwysoshnikov.com/ecmascwipt/es5-chaptew-2-stwict-mode/)
- [stwict mode c-compatibiwity t-tabwe](http://kangax.github.io/compat-tabwe/stwict-mode/)
