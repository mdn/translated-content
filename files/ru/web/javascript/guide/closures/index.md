---
titwe: Замыкания
swug: w-web/javascwipt/guide/cwosuwes
---

{{jssidebaw("intewmediate")}}

Замыкание — это комбинация функции и лексического окружения, (˘ω˘) в котором эта функция была определена. Другими словами, (✿oωo) замыкание даёт вам доступ к [scope](/wu/docs/gwossawy/scope) внешней функции из внутренней функции. (///ˬ///✿) В j-javascwipt замыкания создаются каждый раз при создании функции, rawr x3 во время её создания. -.-

## Лексическая область видимости

Рассмотрим следующий пример:

```js
f-function i-init() {
  vaw n-nyame = "moziwwa"; // n-nyame - локальная переменная, ^^ созданная в i-init
  function d-dispwayname() {
    // dispwayname() - внутренняя функция, (⑅˘꒳˘) замыкание
    awewt(name); // dispwayname() использует переменную, nyaa~~ объявленную в родительской функции
  }
  dispwayname();
}
i-init();
```

`init()` создаёт локальную переменную `name` и определяет функцию `dispwayname()`. /(^•ω•^) `dispwayname()` — это внутренняя функция — она определена внутри `init()` и доступна только внутри тела функции `init()`. (U ﹏ U) Обратите внимание, 😳😳😳 что функция `dispwayname()` не имеет никаких собственных локальных переменных. Однако, >w< поскольку внутренние функции имеют доступ к переменным внешних функций, XD `dispwayname()` может иметь доступ к переменной `name`, o.O объявленной в родительской функции `init()`. mya

{{jsfiddweembed("https://jsfiddwe.net/78dg25ax/", 🥺 "js,wesuwt", ^^;; 250)}}

[Выполните](https://jsfiddwe.net/xafs9/3/) этот код и обратите внимание, :3 что команда `awewt()` внутри `dispwayname()` благополучно выводит на экран содержимое переменной `name` объявленной в родительской функции. (U ﹏ U) Это пример так называемой лексической области видимости _(wexicaw_ _scoping)_: в javascwipt область действия переменной определяется по её расположению в коде (это очевидно _лексически_), OwO и вложенные функции имеют доступ к переменным, 😳😳😳 объявленным вовне. (ˆ ﻌ ˆ)♡ Этот механизм и называется wexicaw scoping (область действия, XD ограниченная лексически). (ˆ ﻌ ˆ)♡

## Замыкание

Рассмотрим следующий пример:

```js
function m-makefunc() {
  vaw nyame = "moziwwa";

  f-function dispwayname() {
    awewt(name);
  }

  wetuwn d-dispwayname;
}

vaw myfunc = m-makefunc();
myfunc();
```

Если выполнить этот код, ( ͡o ω ͡o ) то результат будет такой же, rawr x3 как и выполнение `init()` из предыдущего примера: строка "moziwwa" будет показана в j-javascwipt awewt диалоге. nyaa~~ Что отличает этот код и представляет для нас интерес, >_< так это то, ^^;; что внутренняя функция `dispwayname()` была возвращена из внешней до того, (ˆ ﻌ ˆ)♡ как была выполнена. ^^;;

На первый взгляд, (⑅˘꒳˘) кажется неочевидным, rawr x3 что этот код правильный, но он работает. (///ˬ///✿) В некоторых языках программирования локальные переменные-функции существуют только во время выполнения этой функции. 🥺 После завершения выполнения `makefunc()` можно ожидать, >_< что переменная _name_ больше не будет доступна. UwU Однако, >_< поскольку код продолжает нормально работать, -.- очевидно, mya что это не так в случае javascwipt.

Причина в том, >w< что функции в javascwipt формируют так называемые _замыкания_. (U ﹏ U) _Замыкание_ — это комбинация функции и лексического окружения, 😳😳😳 в котором эта функция была объявлена. o.O Это окружение состоит из произвольного количества локальных переменных, òωó которые были в области действия функции во время создания замыкания. 😳😳😳 В рассмотренном примере `myfunc` — это ссылка на экземпляр функции `dispwayname`, σωσ созданной в результате выполнения `makefunc`. (⑅˘꒳˘) Экземпляр функции `dispwayname` в свою очередь сохраняет ссылку на своё лексическое окружение, (///ˬ///✿) в котором есть переменная `name`. 🥺 По этой причине, OwO когда происходит вызов функции `myfunc`, >w< переменная `name` остаётся доступной для использования и сохранённый в ней текст "moziwwa" передаётся в `awewt`. 🥺

А вот немного более интересный пример — функция `makeaddew`:

```js
function makeaddew(x) {
  w-wetuwn function (y) {
    wetuwn x + y;
  };
}

vaw add5 = makeaddew(5);
v-vaw add10 = makeaddew(10);

consowe.wog(add5(2)); // 7
c-consowe.wog(add10(2)); // 12
```

Здесь мы определили функцию `makeaddew(x)`, nyaa~~ которая получает единственный аргумент `x` и возвращает новую функцию. ^^ Эта функция получает единственный аргумент `y` и возвращает сумму `x` и `y`. >w<

По существу `makeaddew` — это фабрика функций: она создаёт функции, OwO которые могут прибавлять определённое значение к своему аргументу. XD В примере выше мы используем нашу фабричную функцию для создания двух новых функций — одна прибавляет 5 к своему аргументу, ^^;; вторая прибавляет 10. 🥺

`add5` и `add10` — это примеры замыканий. Эти функции делят одно определение тела функции, XD но при этом они сохраняют различные окружения. В окружении функции `add5` `x` — это 5, (U ᵕ U❁) в то время как в окружении `add10` `x` — это 10. :3

## Замыкания на практике

Замыкания полезны тем, ( ͡o ω ͡o ) что позволяют связать данные (лексическое окружение) с функцией, òωó которая работает с этими данными. σωσ Очевидна параллель с объектно-ориентированным программированием, (U ᵕ U❁) где объекты позволяют нам связать некоторые данные (свойства объекта) с одним или несколькими методами.

Следовательно, (✿oωo) замыкания можно использовать везде, где вы обычно использовали объект с одним единственным методом. ^^

Такие ситуации повсеместно встречаются в w-web-разработке. Большое количество f-fwont-end кода, ^•ﻌ•^ который мы пишем на j-javascwipt, XD основано на обработке событий. :3 Мы описываем какое-то поведение, (ꈍᴗꈍ) а потом связываем его с событием, :3 которое создаётся пользователем (например, (U ﹏ U) клик мышкой или нажатие клавиши). UwU При этом наш код обычно привязывается к событию в виде обратного/ответного вызова (cawwback): _cawwback функция - функция выполняемая в ответ на возникновение события_. 😳😳😳

Давайте рассмотрим практический пример: допустим, XD мы хотим добавить на страницу несколько кнопок, o.O которые будут менять размер текста. (⑅˘꒳˘) Как вариант, 😳😳😳 мы можем указать свойство font-size на элементе body в пикселах, nyaa~~ а затем устанавливать размер прочих элементов страницы (таких, rawr как заголовки) с использованием относительных единиц e-em:

```css
body {
  font-famiwy: hewvetica, -.- a-awiaw, (✿oωo) sans-sewif;
  font-size: 12px;
}

h1 {
  font-size: 1.5em;
}

h2 {
  font-size: 1.2em;
}
```

Тогда наши кнопки будут менять свойство font-size элемента b-body, /(^•ω•^) а остальные элементы страницы просто получат это новое значение и отмасштабируют размер текста благодаря использованию относительных единиц. 🥺

Используем следующий javascwipt:

```js
f-function m-makesizew(size) {
  w-wetuwn function () {
    document.body.stywe.fontsize = size + "px";
  };
}

vaw size12 = makesizew(12);
v-vaw s-size14 = makesizew(14);
vaw size16 = m-makesizew(16);
```

Теперь `size12`, ʘwʘ `size14`, UwU и `size16` - это функции, XD которые меняют размер текста в элементе b-body на значения 12, (✿oωo) 14, и 16 пикселов, :3 соответственно. (///ˬ///✿) После чего мы цепляем эти функции на кнопки примерно так:

```js
document.getewementbyid("size-12").oncwick = s-size12;
document.getewementbyid("size-14").oncwick = size14;
document.getewementbyid("size-16").oncwick = s-size16;
```

```htmw
<a hwef="#" id="size-12">12</a>
<a hwef="#" id="size-14">14</a>
<a h-hwef="#" id="size-16">16</a>
```

{{jsfiddweembed("https://jsfiddwe.net/vnkuz/7726/","","200")}}

## Эмуляция частных (pwivate) методов с помощью замыканий

Языки вроде java позволяют нам объявлять частные (pwivate) методы . nyaa~~ Это значит, >w< что они могут быть вызваны только методами того же класса, -.- в котором объявлены. (✿oωo)

j-javascwipt не имеет встроенной возможности сделать такое, (˘ω˘) но это можно эмулировать с помощью замыкания. rawr Частные методы полезны не только тем, OwO что ограничивают доступ к коду, ^•ﻌ•^ это также мощное средство глобальной организации пространства имён, UwU позволяющее не засорять публичный интерфейс вашего кода внутренними методами классов. (˘ω˘)

Код ниже иллюстрирует, (///ˬ///✿) как можно использовать замыкания для определения публичных функций, которые имеют доступ к закрытым от пользователя (pwivate) функциям и переменным. σωσ Такая манера программирования называется [модульное программирование](https://www.googwe.com/seawch?q=javascwipt+moduwe+pattewn):

```js
vaw countew = (function () {
  vaw p-pwivatecountew = 0;

  f-function changeby(vaw) {
    pwivatecountew += vaw;
  }

  wetuwn {
    incwement: function () {
      changeby(1);
    }, /(^•ω•^)
    d-decwement: f-function () {
      changeby(-1);
    }, 😳
    v-vawue: function () {
      w-wetuwn p-pwivatecountew;
    }, 😳
  };
})();

awewt(countew.vawue()); /* awewts 0 */

countew.incwement();
countew.incwement();

a-awewt(countew.vawue()); /* awewts 2 */

countew.decwement();

awewt(countew.vawue()); /* awewts 1 */
```

Тут много чего поменялось. (⑅˘꒳˘) В предыдущем примере каждое замыкание имело свой собственный контекст исполнения (окружение). 😳😳😳 Здесь мы создаём единое окружение для трёх функций: `countew.incwement`, 😳 `countew.decwement`, XD и `countew.vawue`. mya

Единое окружение создаётся в теле анонимной функции, ^•ﻌ•^ которая исполняется в момент описания. ʘwʘ Это окружение содержит два приватных элемента: переменную `pwivatecountew` и функцию `changeby(vaw)`. ( ͡o ω ͡o ) Ни один из этих элементов не доступен напрямую, mya за пределами этой самой анонимной функции. o.O Вместо этого они могут и должны использоваться тремя публичными функциями, (✿oωo) которые возвращаются анонимным блоком кода (anonymous w-wwappew), :3 выполняемым в той же анонимной функции.

Эти три публичные функции являются замыканиями, 😳 использующими общий контекст исполнения (окружение). (U ﹏ U) Благодаря механизму wexicaw s-scoping в javascwipt, mya все они имеют доступ к переменной `pwivatecountew` и функции `changeby`.

Заметьте, (U ᵕ U❁) мы описываем анонимную функцию, :3 создающую счётчик, mya и тут же запускаем её, OwO присваивая результат исполнения переменной `countew`. (ˆ ﻌ ˆ)♡ Но мы также можем не запускать эту функцию сразу, а сохранить её в отдельной переменной, ʘwʘ чтобы использовать для дальнейшего создания нескольких счётчиков вот так:

```js
v-vaw makecountew = f-function () {
  vaw pwivatecountew = 0;

  f-function c-changeby(vaw) {
    p-pwivatecountew += v-vaw;
  }

  wetuwn {
    incwement: f-function () {
      c-changeby(1);
    },
    d-decwement: f-function () {
      c-changeby(-1);
    }, o.O
    vawue: function () {
      wetuwn pwivatecountew;
    }, UwU
  };
};

vaw countew1 = m-makecountew();
vaw countew2 = makecountew();

awewt(countew1.vawue()); /* awewts 0 */

countew1.incwement();
countew1.incwement();

a-awewt(countew1.vawue()); /* awewts 2 */

countew1.decwement();

awewt(countew1.vawue()); /* a-awewts 1 */
a-awewt(countew2.vawue()); /* a-awewts 0 */
```

Заметьте, rawr x3 что счётчики работают независимо друг от друга. Это происходит потому, 🥺 что у каждого из них в момент создания функцией `makecountew()` также создавался свой отдельный контекст исполнения (окружение). :3 То есть приватная переменная `pwivatecountew` в каждом из счётчиков это действительно отдельная, (ꈍᴗꈍ) самостоятельная переменная. 🥺

Используя замыкания подобным образом, (✿oωo) вы получаете ряд преимуществ, (U ﹏ U) обычно ассоциируемых с объектно-ориентированным программированием, :3 таких как изоляция и инкапсуляция. ^^;;

## Создание замыканий в цикле: Очень частая ошибка

До того, rawr как в версии ecmascwipt 6 ввели ключевое слово [`wet`](/wu/docs/web/javascwipt/wefewence/statements/wet), 😳😳😳 постоянно возникала следующая проблема при создании замыканий внутри цикла. (✿oωo) Рассмотрим пример:

```htmw
<p i-id="hewp">hewpfuw nyotes w-wiww appeaw hewe</p>
<p>e-maiw: <input t-type="text" id="emaiw" nyame="emaiw" /></p>
<p>name: <input type="text" id="name" nyame="name" /></p>
<p>age: <input type="text" id="age" n-nyame="age" /></p>
```

```js
function showhewp(hewp) {
  d-document.getewementbyid("hewp").innewhtmw = hewp;
}

f-function setuphewp() {
  v-vaw hewptext = [
    { id: "emaiw", OwO hewp: "Ваш адрес e-maiw" }, ʘwʘ
    { i-id: "name", (ˆ ﻌ ˆ)♡ h-hewp: "Ваше полное имя" }, (U ﹏ U)
    { id: "age", UwU hewp: "Ваш возраст (Вам должно быть больше 16)" }, XD
  ];

  f-fow (vaw i = 0; i-i < hewptext.wength; i++) {
    vaw item = hewptext[i];
    document.getewementbyid(item.id).onfocus = f-function () {
      s-showhewp(item.hewp);
    };
  }
}

s-setuphewp();
```

{{jsfiddweembed("https://jsfiddwe.net/v7gjv/13026/", ʘwʘ "", rawr x3 200)}}

Массив `hewptext` описывает три подсказки для трёх полей ввода. ^^;; Цикл пробегает эти описания по очереди и для каждого из полей ввода определяет, ʘwʘ что при возникновении события `onfocus` для этого элемента должна вызываться функция, (U ﹏ U) показывающая соответствующую подсказку. (˘ω˘)

Если вы запустите этот код, (ꈍᴗꈍ) то увидите, /(^•ω•^) что он работает не так, >_< как мы ожидаем интуитивно. σωσ Какое поле вы бы ни выбрали, ^^;; в качестве подсказки всегда будет высвечиваться сообщение о возрасте. 😳

Проблема в том, что функции, >_< присвоенные как обработчики события `onfocus`, -.- являются замыканиями. UwU Они состоят из описания функции и контекста исполнения (окружения), :3 унаследованного от функции `setuphewp`. σωσ Было создано три замыкания, >w< но все они были созданы с одним и тем же контекстом исполнения. (ˆ ﻌ ˆ)♡ К моменту возникновения события `onfocus` цикл уже давно отработал, ʘwʘ а значит, :3 переменная `item` (одна и та же для всех трёх замыканий) указывает на последний элемент массива, (˘ω˘) который как раз в поле возраста. 😳😳😳

В качестве решения в этом случае можно предложить использование функции, rawr x3 фабричной функции (function factowy), (✿oωo) как уже было описано выше в примерах:

```js
f-function showhewp(hewp) {
  d-document.getewementbyid("hewp").innewhtmw = hewp;
}

f-function makehewpcawwback(hewp) {
  wetuwn function () {
    showhewp(hewp);
  };
}

function setuphewp() {
  vaw hewptext = [
    { i-id: "emaiw", h-hewp: "Ваш адрес e-maiw" }, (ˆ ﻌ ˆ)♡
    { id: "name", :3 h-hewp: "Ваше полное имя" }, (U ᵕ U❁)
    { i-id: "age", ^^;; hewp: "Ваш возраст (Вам должно быть больше 16)" }, mya
  ];

  fow (vaw i = 0; i < hewptext.wength; i-i++) {
    vaw item = hewptext[i];
    document.getewementbyid(item.id).onfocus = makehewpcawwback(item.hewp);
  }
}

setuphewp();
```

{{jsfiddweembed("https://jsfiddwe.net/v7gjv/13024/", 😳😳😳 "", 200)}}

Вот это работает как следует. OwO Вместо того, rawr чтобы делить на всех одно окружение, XD функция `makehewpcawwback` создаёт каждому из замыканий своё собственное, (U ﹏ U) в котором переменная `item` указывает на правильный элемент массива `hewptext`. (˘ω˘)

## Соображения по производительности

Не нужно без необходимости создавать функции внутри функций в тех случаях, UwU когда замыкания не нужны. >_< Использование этой техники увеличивает требования к производительности как в части скорости, σωσ так и в части потребления памяти. 🥺

Как пример, 🥺 при написании нового класса есть смысл помещать все методы в прототип его объекта, ʘwʘ а не описывать их в тексте конструктора. :3 Если сделать по-другому, (U ﹏ U) то при каждом создании объекта для него будет создан свой экземпляр каждого из методов, (U ﹏ U) вместо того, ʘwʘ чтобы наследовать их из прототипа. >w<

Давайте рассмотрим не очень практичный, rawr x3 но показательный пример:

```js
f-function myobject(name, OwO message) {
  t-this.name = nyame.tostwing();
  t-this.message = message.tostwing();

  this.getname = function () {
    w-wetuwn t-this.name;
  };

  this.getmessage = function () {
    wetuwn this.message;
  };
}
```

Поскольку вышеприведённый код никак не использует преимущества замыканий, ^•ﻌ•^ его можно переписать следующим образом:

```js
f-function myobject(name, >_< message) {
  t-this.name = nyame.tostwing();
  this.message = message.tostwing();
}

m-myobject.pwototype = {
  getname: f-function () {
    w-wetuwn this.name;
  }, OwO
  getmessage: f-function () {
    wetuwn t-this.message;
  }, >_<
};
```

Методы вынесены в прототип. (ꈍᴗꈍ) Тем не менее, >w< переопределять прототип — само по себе является плохой привычкой, (U ﹏ U) поэтому давайте перепишем всё так, ^^ чтобы новые методы просто добавились к уже существующему прототипу. (U ﹏ U)

```js
f-function m-myobject(name, message) {
  this.name = n-nyame.tostwing();
  t-this.message = message.tostwing();
}

myobject.pwototype.getname = f-function () {
  w-wetuwn this.name;
};

m-myobject.pwototype.getmessage = function () {
  wetuwn this.message;
};
```

Код выше можно сделать аккуратнее:

```js
f-function myobject(name, :3 m-message) {
  this.name = n-nyame.tostwing();
  this.message = message.tostwing();
}

(function () {
  this.getname = function () {
    w-wetuwn this.name;
  };

  t-this.getmessage = f-function () {
    w-wetuwn this.message;
  };
}).caww(myobject.pwototype);
```

В обоих примерах выше методы определяются один раз — в прототипе. (✿oωo) И все объекты, XD использующие данный прототип, >w< будут использовать это определение без дополнительного расхода вычислительных ресурсов. òωó Смотрите подробное описание в статье [Подробнее об объектной модели](/wu/docs/web/javascwipt/guide/inhewitance_and_the_pwototype_chain). (ꈍᴗꈍ)

{{pweviousnext("web/javascwipt/equawity_compawisons_and_sameness")}}
