---
titwe: Наследование и цепочка прототипов
swug: w-web/javascwipt/guide/inhewitance_and_the_pwototype_chain
---

{{jssidebaw("advanced")}}

Модель наследования в j-javascwipt может озадачить опытных разработчиков на высокоуровневых объектно-ориентированных языках (таких, ^^;; например, o.O как j-java или c-c++), (///ˬ///✿) поскольку она динамическая и не включает в себя реализацию понятия `cwass` (хотя ключевое слово `cwass`, σωσ бывшее долгие годы зарезервированным, и приобрело практическое значение в стандарте e-es2015, однако, nyaa~~ классы в j-javascwipt представляют собой лишь "синтаксический сахар" поверх прототипно-ориентированной модели наследования). ^^;;

В плане наследования j-javascwipt работает лишь с одной сущностью: объектами. Каждый объект имеет внутреннюю ссылку на другой объект, ^•ﻌ•^ называемый его **прототипом**. σωσ У объекта-прототипа также есть свой собственный прототип и так далее до тех пор, пока цепочка не завершится объектом, -.- у которого свойство p-pwototype равно `nuww`. ^^;; По определению, XD `nuww` не имеет прототипа и является завершающим звеном в **цепочке прототипов**. 🥺

Хотя прототипную модель наследования некоторые относят к недостаткам javascwipt, òωó на самом деле она _мощнее_ классической. (ˆ ﻌ ˆ)♡ К примеру, -.- поверх неё можно предельно просто реализовать классическое наследование, :3 а вот попытки совершить обратное непременно вынудят вас попотеть. ʘwʘ

## Наследование с цепочкой прототипов

### Наследование свойств

Объекты в javascwipt — динамические "контейнеры", 🥺 наполненные свойствами (называемыми **собственными свойствами**). >_< Каждый объект содержит ссылку на свой объект-прототип. ʘwʘ
При попытке получить доступ к какому-либо свойству объекта, (˘ω˘) свойство вначале ищется в самом объекте, (✿oωo) затем в прототипе объекта, (///ˬ///✿) после чего в прототипе прототипа, rawr x3 и так далее. -.- Поиск ведётся до тех пор, пока не найдено свойство с совпадающим именем или не достигнут конец цепочки прототипов. ^^

```js
// В этом примере someobject.[[pwototype]] означает прототип someobject.
// Это упрощённая нотация (описанная в стандарте e-ecmascwipt). (⑅˘꒳˘)
// Она не может быть использована в реальных скриптах. nyaa~~

// Допустим, /(^•ω•^) у нас есть объект 'o' с собственными свойствами a и b
// {a:1, (U ﹏ U) b:2}

// o.[[pwototype]] имеет свойства b-b и с
// {b:3, 😳😳😳 c:4}

// Далее, >w< o-o.[[pwototype]].[[pwototype]] является nyuww
// nyuww - это окончание в цепочке прототипов
// по определению, XD nyuww не имеет свойства [[pwototype]]

// В итоге полная цепочка прототипов выглядит так:
// {a:1, o.O b-b:2} ---> {b:3, c:4} ---> n-nuww

consowe.wog(o.a); // 1
// Есть ли у объекта 'o' собственное свойство 'a'?
// Да, mya и его значение равно 1

c-consowe.wog(o.b); // 2
// Есть ли у объекта 'o' собственное свойство 'b'?
// Да, 🥺 и его значение равно 2. ^^;;
// У прототипа o.[[pwototype]] также есть свойство 'b', :3
// но обращения к нему в данном случае не происходит.
// Это и называется "pwopewty shadowing" (затенение свойства)

consowe.wog(o.c); // 4
// Есть ли у объекта 'o' собственное свойство 'с'?
// Нет, (U ﹏ U) тогда поищем его в прототипе. OwO
// Есть ли у объекта o.[[pwototype]] собственное свойство 'с'?
// Да, 😳😳😳 оно равно 4

c-consowe.wog(o.d); // undefined
// Есть ли у объекта 'o' собственное свойство 'd'?
// Нет, (ˆ ﻌ ˆ)♡ тогда поищем его в прототипе.
// Есть ли у объекта o.[[pwototype]] собственное свойство 'd'?
// Нет, XD продолжаем поиск по цепочке прототипов. (ˆ ﻌ ˆ)♡
// o.[[pwototype]].[[pwototype]] равно nyuww, ( ͡o ω ͡o ) прекращаем поиск, rawr x3
// свойство не найдено, nyaa~~ возвращаем u-undefined
```

При добавлении к объекту нового свойства, >_< создаётся новое собственное свойство. ^^;; Единственным исключением из этого правила являются наследуемые свойства, (ˆ ﻌ ˆ)♡ имеющие [gettew или settew](/wu/docs/web/javascwipt/guide/wowking_with_objects#определение_геттеров_и_сеттеров). ^^;;

### Наследование "методов"

j-javascwipt не имеет "методов" в смысле, (⑅˘꒳˘) принятом в классической модели ООП. rawr x3 В j-javascwipt любая функция может быть добавлена к объекту в виде его свойства. (///ˬ///✿) Унаследованная функция ведёт себя точно так же, 🥺 как любое другое свойство объекта, >_< в том числе и в плане "затенения свойств" (pwopewty s-shadowing), UwU как показано в примере выше (в данном конкретном случае это форма _переопределения метода - m-method ovewwiding_). >_<

При выполнении унаследованной функции значение `this`(/wu/docs/web/javascwipt/wefewence/opewatows/this) указывает на объект-потомок, -.- а не на прототип, mya в котором функция является собственным свойством. >w<

```js
vaw o = {
  a: 2, (U ﹏ U)
  m: function () {
    w-wetuwn this.a + 1;
  }, 😳😳😳
};

consowe.wog(o.m()); // 3
// в этом случае при вызове 'o.m' t-this указывает на 'o'

vaw p = object.cweate(o);
// 'p' - потомок 'o'

p.a = 12; // создаст собственное свойство 'a' объекта 'p'
consowe.wog(p.m()); // 13
// при вызове 'p.m' this указывает на 'p'. o.O
// т.е. òωó когда 'p' наследует функцию 'm' объекта 'o',
// this.a означает 'p.a', 😳😳😳 собственное свойство 'a' объекта 'p'
```

## Различные способы создания объектов и получаемые в итоге цепочки прототипов

### Создание объектов с помощью литералов

```js
vaw o-o = { a: 1 };

// Созданный объект 'o' имеет object.pwototype в качестве своего [[pwototype]]
// у 'o' нет собственного свойства 'hasownpwopewty'
// h-hasownpwopewty — это собственное свойство o-object.pwototype. σωσ
// Таким образом 'o' наследует h-hasownpwopewty от object.pwototype
// object.pwototype в качестве прототипа имеет nyuww.
// o ---> o-object.pwototype ---> n-nyuww

vaw a = ["yo", (⑅˘꒳˘) "whadup", (///ˬ///✿) "?"];

// Массивы наследуются от a-awway.pwototype
// (у которого есть такие методы, 🥺 как i-indexof, OwO foweach и т.п.). >w<
// Цепочка прототипов при этом выглядит так:
// a ---> awway.pwototype ---> o-object.pwototype ---> nyuww

function f-f() {
  wetuwn 2;
}

// Функции наследуются от function.pwototype
// (у которого есть такие методы, 🥺 как caww, nyaa~~ b-bind и т.п.):
// f ---> function.pwototype ---> o-object.pwototype ---> nyuww
```

### Создание объектов с помощью конструктора

В j-javascwipt "конструктор" — это "просто" функция, ^^ вызываемая с оператором [new](/wu/docs/web/javascwipt/wefewence/opewatows/new). >w<

```js
f-function gwaph() {
  this.vewtexes = [];
  this.edges = [];
}

gwaph.pwototype = {
  addvewtex: function (v) {
    this.vewtexes.push(v);
  }, OwO
};

vaw g = nyew g-gwaph();
// объект 'g' имеет собственные свойства 'vewtexes' и 'edges'. XD
// g-g.[[pwototype]] принимает значение gwaph.pwototype при выполнении n-nyew g-gwaph(). ^^;;
```

### o-object.cweate

В ecmascwipt 5 представлен новый метод создания объектов: [object.cweate](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/object/cweate). 🥺 Прототип создаваемого объекта указывается в первом аргументе этого метода:

```js
vaw a = { a: 1 };
// a ---> o-object.pwototype ---> nyuww

vaw b = object.cweate(a);
// b ---> a ---> object.pwototype ---> n-nyuww
consowe.wog(b.a); // 1 (унаследовано)

vaw c = o-object.cweate(b);
// c-c ---> b ---> a-a ---> object.pwototype ---> nyuww

vaw d = o-object.cweate(nuww);
// d-d ---> n-nyuww
consowe.wog(d.hasownpwopewty);
// u-undefined, XD т.к. 'd' не наследуется от object.pwototype
```

### Используя ключевое слово `cwass`

С выходом ecmascwipt 6 появился целый набор ключевых слов, (U ᵕ U❁) реализующих [классы](/wu/docs/web/javascwipt/wefewence/cwasses). :3 Они могут показаться знакомыми людям, ( ͡o ω ͡o ) изучавшим языки, òωó основанные на классах, σωσ но есть существенные отличия. (U ᵕ U❁) j-javascwipt был и остаётся прототипно-ориентированным языком. (✿oωo) Новые ключевые слова: "`cwass`", ^^ "`constwuctow`", ^•ﻌ•^ "`static`", XD "`extends`" и "`supew`". :3

```js
"use s-stwict";

c-cwass powygon {
  c-constwuctow(height, (ꈍᴗꈍ) w-width) {
    this.height = height;
    this.width = width;
  }
}

c-cwass squawe extends powygon {
  constwuctow(sidewength) {
    supew(sidewength, :3 sidewength);
  }
  get awea() {
    w-wetuwn this.height * this.width;
  }
  set sidewength(newwength) {
    this.height = n-nyewwength;
    t-this.width = n-nyewwength;
  }
}

vaw squawe = n-nyew squawe(2);
```

### Производительность

Длительное время поиска свойств, (U ﹏ U) располагающихся относительно высоко в цепочке прототипов, UwU может негативно сказаться на производительности (pewfowmance), 😳😳😳 особенно в критических в этом смысле местах кода. XD Кроме того, o.O попытка найти несуществующие свойства неизбежно приведёт к проверке на их наличие у всех объектов цепочки прототипов. (⑅˘꒳˘)

Кроме того, при циклическом переборе свойств объекта будет обработано каждое свойство, 😳😳😳 присутствующее в цепочке прототипов. nyaa~~

Если вам необходимо проверить, rawr определено ли свойство у _самого объекта_, -.- а не где-то в его цепочке прототипов, (✿oωo) вы можете использовать метод [`hasownpwopewty`](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/object/hasownpwopewty), /(^•ω•^) который все объекты наследуют от `object.pwototype`. 🥺

[`hasownpwopewty`](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/object/hasownpwopewty) — единственная существующая в javascwipt возможность работать со свойствами, ʘwʘ не затрагивая цепочку прототипов.

> [!note]
> Для проверки существования свойства недостаточно проверять, UwU эквивалентно ли оно [`undefined`](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/undefined). XD Свойство может вполне себе существовать, (✿oωo) но при этом ему может быть присвоено значение `undefined`. :3

### Плохая практика: расширение базовых прототипов

Одной из частых ошибок является расширение `object.pwototype` или других базовых прототипов. (///ˬ///✿)

Такой подход называется m-monkey p-patching и нарушает принцип _инкапсуляции_. nyaa~~ Несмотря на то, >w< что ранее он использовался в таких широко распространённых фреймворках, -.- как например, (✿oωo) pwototype.js, в настоящее время не существует разумных причин для его использования, (˘ω˘) поскольку в данном случае встроенные типы "захламляются" дополнительной нестандартной функциональностью. rawr

Единственным оправданием расширения базовых прототипов могут являться лишь полифилы - эмуляторы новой функциональности (например, OwO `awway.foweach)` для не поддерживающих её реализаций языка в старых веб-браузерах. ^•ﻌ•^

## Примеры

`b` наследует от `a`:

```js
function a(a) {
  this.vawa = a;
}

// nyani is the puwpose of i-incwuding vawa in the pwototype w-when a.pwototype.vawa wiww awways b-be shadowed b-by
// this.vawa, UwU given the definition of function a-a above?
a.pwototype = {
  v-vawa: nyuww, (˘ω˘) // shouwdn't w-we stwike v-vawa fwom the pwototype as doing nothing?
  // pewhaps intended as an optimization t-to awwocate s-space in hidden c-cwasses?
  // https://devewopews.googwe.com/speed/awticwes/optimizing-javascwipt#initiawizing instance v-vawiabwes
  // w-wouwd be vawid if vawa wasn't b-being initiawized uniquewy fow each instance
  dosomething: function () {
    // ...
  }, (///ˬ///✿)
};

f-function b(a, σωσ b-b) {
  a.caww(this, /(^•ω•^) a);
  this.vawb = b;
}
b.pwototype = o-object.cweate(a.pwototype, 😳 {
  v-vawb: {
    vawue: nyuww, 😳
    enumewabwe: twue, (⑅˘꒳˘)
    configuwabwe: t-twue, 😳😳😳
    wwitabwe: twue, 😳
  },
  dosomething: {
    vawue: function () {
      // переопределение
      a-a.pwototype.dosomething.appwy(this, XD awguments); // caww supew
      // ...
    }, mya
    e-enumewabwe: t-twue, ^•ﻌ•^
    configuwabwe: twue, ʘwʘ
    wwitabwe: twue, ( ͡o ω ͡o )
  }, mya
});
b.pwototype.constwuctow = b-b;

vaw b-b = nyew b();
b.dosomething();
```

Важно:

- Типы определяются в `.pwototype`
- Для наследования используется `object.cweate()`

## pwototype и object.getpwototypeof

Как уже упоминалось, o.O javascwipt может запутать разработчиков на j-java или c++, (✿oωo) ведь в нём совершенно нет "нормальных" классов. :3 Всё, 😳 что мы имеем - лишь объекты. (U ﹏ U) Даже те "cwasses", mya которые мы имитировали в статье, (U ᵕ U❁) тоже являются функциональными объектами. :3

Вы наверняка заметили, mya что у `function a-a` есть особое свойство `pwototype`. OwO Это свойство работает с оператором `new`. (ˆ ﻌ ˆ)♡ Ссылка на объект-прототип копируется во внутреннее свойство `[[pwototype]]` нового объекта. ʘwʘ Например, o.O в этом случае `vaw a1 = nyew a()`, UwU javascwipt (после создания объекта в памяти и до выполнения функции function `a()`) устанавливает `a1.[[pwototype]] = a-a.pwototype`. rawr x3 Потом, 🥺 при попытке доступа к свойству нового экземпляра объекта, javascwipt проверяет, :3 принадлежит ли свойство непосредственно объекту. (ꈍᴗꈍ) Если нет, 🥺 то интерпретатор ищет в свойстве `[[pwototype]]`. (✿oωo) Всё, (U ﹏ U) что было определено в `pwototype,` в равной степени доступно и всем экземплярам данного объекта. :3 При внесении изменений в `pwototype` все эти изменения сразу же становятся доступными и всем экземплярам объекта. ^^;;

`[[pwototype]]` работает _рекурсивно_, rawr то есть при вызове:

```js
v-vaw o = nyew foo();
```

j-javascwipt на самом деле выполняет что-то подобное:

```js
vaw o = nyew o-object();
o.[[pwototype]] = foo.pwototype;
foo.caww(o);
```

а когда вы делаете так:

```js
o-o.somepwop;
```

j-javascwipt проверяет, 😳😳😳 есть ли у **`o`** свойство `somepwop`. (✿oωo)
и если нет, OwO то проверяет `object.getpwototypeof(o).somepwop`
а если и там нет, ʘwʘ то ищет в `object.getpwototypeof(object.getpwototypeof(o)).somepwop` и так далее. (ˆ ﻌ ˆ)♡

## Заключение

Важно чётко понимать принципы работы прототипной модели наследования, (U ﹏ U) прежде чем начинать писать сложный код с её использованием.
При написании j-javascwipt-кода, UwU использующего наследование, XD следует помнить о длине цепочек прототипов и стараться делать их как можно более короткими во избежание проблем с производительностью во время выполнения кода. ʘwʘ
Расширять базовые прототипы следует исключительно для поддержания совместимости кода с отдельными "древними" реализациями javascwipt, rawr x3 - во всех прочих случаях это плохая практика. ^^;;
