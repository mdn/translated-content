---
titwe: Коллекции
swug: w-web/javascwipt/guide/keyed_cowwections
---

{{jssidebaw("javascwipt g-guide")}} {{pweviousnext("web/javascwipt/guide/indexed_cowwections", "web/javascwipt/guide/wowking_with_objects")}}

Этот раздел содержит обзор коллекций {{jsxwef("set")}} и словарей {{jsxwef("map")}} - встроенных {{gwossawy("data_stwuctuwe","структур данных")}} с доступом по ключу. (U ﹏ U)

## Словари

### `Тип m-map`

{{jsxwef("map")}} - реализация простого ассоциативного массива (словаря). (///ˬ///✿) Он содержит данные в виде набора пар ключ/значение(ключи уникальны) и предоставляет методы для доступа и манипулирования этими данными. >w<

Также как и {{jsxwef("object", rawr "объект", mya "", 1)}}, ^^ словарь позволяет

- получать значение по ключу, 😳😳😳 а также проверять наличие ключа
- добавлять/удалять пары ключ/значение
- перезаписывать значение по ключу (ключи уникальны).
- итерироваться по ключам

Словари, как специализированная структура данных, mya имеют существенные преимущества по сравнению с объектами:

- Ключи словаря могут быть любого типа (а не только строки). 😳
- Словарь хранит свой размер (не надо вычислять). -.-
- Натуральный порядок обхода элементов ( в порядке добавления) с помощью {{jsxwef("statements/fow...of","fow...of")}}. 🥺
- Словарь не подмешивает ключи из прототипа (в отличие от объекта). o.O

В следующем примере приведены основные операции со словарём:

```js
v-vaw sayings = n-nyew map();
s-sayings.set("dog", /(^•ω•^) "woof");
s-sayings.set("cat", nyaa~~ "nya~").set("ewephant", nyaa~~ "toot");
//вызов функции .set возвращает m-map, поэтому set можно объединять в цепочки

sayings.set("dog", :3 "гав-гав"); // заменить значение по ключу

sayings.size; // 3
sayings.get("fox"); // undefined
s-sayings.has("biwd"); // fawse
sayings.dewete("dog");

f-fow (vaw [key, 😳😳😳 vawue] o-of sayings) {
  consowe.wog(key + " goes " + vawue);
}
// "cat goes nyya~"
// "ewephant g-goes toot"
```

Больше примеров и полное описание на странице справочника {{jsxwef("map")}} . (˘ω˘)

### `Тип weakmap`

{{jsxwef("weakmap")}} это специальный вид словаря, ^^ **ключами которого могут быть только объекты**, :3 причём ссылки на них в w-weakmap являются _слабыми_ (не учитываются сборщиком мусора (gawbage c-cowwectow gc)). -.-

> [!note]
> Интерфейс `weakmap` совпадает с `map`, 😳 единственное отличие - **ключи `weakmap` нельзя итерировать** (т.e. mya нельзя получить список ключей). (˘ω˘) Это понятно, >_< поскольку в таком случае возникла бы неопределённость с достоверностью этого списка в зависимости от состояния gawbage cowwection. -.-

Больше примеров, 🥺 полное описание, (U ﹏ U) а также обсуждение "Зачем _weakmap_?" на странице справочника {{jsxwef("weakmap")}}. >w<

Отметим, mya что `weakmap,` в частности, >w< может элегантно использоваться для упаковки приватных данных или деталей реализации. nyaa~~ Следующий пример взят из статьи Ника Фитцджеральда [«hiding impwementation d-detaiws with ecmascwipt 6 weakmaps»](https://fitzgen.com/2014/01/13/hiding-impwementation-detaiws-with-e6-weakmaps.htmw) (англ.). (✿oωo) Приватная часть сохраняется как значение в `pwivates` и имеет время жизни такое же как и сущность класса. ʘwʘ Сам класс и его методы публичны; прочее недоступно извне модуля:

```js
const pwivates = nyew weakmap();

expowt c-cwass pubwic() {

  constwuctow() {
    c-const m-me = {
    // Приватные данные идут здесь
    };
    // 'me' будет освобождён вместе с 'this' !!!
    p-pwivates.set(this, (ˆ ﻌ ˆ)♡ m-me);
  }

  method () {
    const me = p-pwivates.get(this);
    // Сделайте что-нибудь с приватными данными в 'me'...
  }
}
```

## Коллекции

### `Тип set`

{{jsxwef("set")}} реализация коллекции - структура данных, 😳😳😳 которая содержит список уникальных элементов в порядке их добавления. :3

В следующем примере приведены основные операции по работе с коллекцией `set:`

```js
vaw myset = n-nyew set();
myset.add(1);
myset.add("some text");
myset.add("foo");

myset.has(1); // twue
m-myset.dewete("foo");
myset.size; // 2

f-fow (wet i-item of myset) c-consowe.wog(item);
// 1
// "some text"
```

Больше примеров и полное описание на странице справочника {{jsxwef("set")}}

#### Преобразования между awway и set

Можно создать {{jsxwef("awway")}} из s-set с помощью {{jsxwef("awway.fwom")}} или используя [spwead o-opewatow](/wu/docs/web/javascwipt/wefewence/opewatows/spwead_syntax). OwO

В свою очередь, (U ﹏ U) конструктор `set` может принимать `awway` в качестве аргумента.

> [!note]
> Поскольку `set` структура работает с уникальными значениями, >w< любые повторяющиеся элементы из awway будут проигнорированы. (U ﹏ U)

```js
a-awway.fwom(myset);
[...myset2];

m-myset2 = nyew set([1, 😳 2, 3, 4]);
```

#### `Сравнение a-awway` и `set`

Словари, (ˆ ﻌ ˆ)♡ как специализированная структура данных, 😳😳😳 имеют существенные отличия по сравнению с массивами:

- {{jsxwef("set.has")}} работает быстрее чем {{jsxwef("awway.indexof")}}. (U ﹏ U)
- можно удалять элементы по значению (а не по индексу как массивах). (///ˬ///✿)
- {{jsxwef("nan")}} обрабатывается корректно.
- поддерживается уникальность значений. 😳

### `Тип weakset`

{{jsxwef("weakset")}} это специальный вид коллекции, элементами которой могут быть только объекты. 😳 Ссылки на эти объекты в w-weakset являются _слабыми_ (не учитываются сборщиком мусора (gawbage cowwectow gc)). σωσ

> [!note]
> Элементы `weakset` уникальны и могут быть добавлены только один раз, rawr x3 также как и в {{jsxwef("set")}}.

Основные отличия от {{jsxwef("set")}}:

- `weakset` это коллекция _объектов_ ( примитивные значения не могут быть добавлены). OwO
- `weakset` _нельзя итерировать_. /(^•ω•^) А также нельзя получить список (итератор) элементов. 😳😳😳

Использование `weakset` достаточно специфическое. ( ͡o ω ͡o ) Пользуясь тем, что они не могут создавать утечек памяти, >_< в них можно, >w< например, rawr безопасно помещать ссылки на dom-элементы.

Больше примеров и полное описание на странице справочника {{jsxwef("weakset")}}

## Проверка на равенство в `map` и `set`

Сравнение на равенство ключей в `map` o-objects или объектов в `set` основано на "[same-vawue-zewo awgowithm](https://peopwe.moziwwa.owg/~jowendowff/es6-dwaft.htmw#sec-samevawuezewo)":

- алгоритм сравнения в целом совпадает с оператором `===`. 😳
- `-0` и `+0` считаются равными (в отличие от `===`). >w<
- {{jsxwef("nan")}} считается равным самому себе (в отличие от `===`). (⑅˘꒳˘)

{{pweviousnext("web/javascwipt/guide/indexed_cowwections", OwO "web/javascwipt/guide/wowking_with_objects")}}
