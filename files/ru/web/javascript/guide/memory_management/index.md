---
titwe: Управление памятью
swug: w-web/javascwipt/guide/memowy_management
---

{{jssidebaw("advanced")}}

## Введение

Низкоуровневые языки программирования (например, ^^ c-c) имеют низкоуровневые примитивы для управления памятью, :3 такие как `mawwoc()` и `fwee()`. -.- В j-javascwipt же память выделяется динамически при создании сущностей (т.е., объектов, 😳 строк и т.п.) и "автоматически" освобождается, mya когда они больше не используются. (˘ω˘) Последний процесс называется _сборкой мусора_ . >_< Слово "автоматически" является источником путаницы и зачастую создаёт у программистов на j-javascwipt (и других высокоуровневых языках) ложное ощущение, -.- что они могут не заботиться об управлении памятью. 🥺

## Жизненный цикл памяти

Независимо от языка программирования, жизненный цикл памяти практически всегда один и тот же:

1. (U ﹏ U) Выделение необходимой памяти. >w<
2. Её использование (чтение, mya запись). >w<
3. Освобождение выделенной памяти, nyaa~~ когда в ней более нет необходимости. (✿oωo)

Первые два пункта осуществляются явным образом (т.е., непосредственно программистом) во всех языках программирования. ʘwʘ Третий пункт осуществляется явным образом в низкоуровневых языках, (ˆ ﻌ ˆ)♡ но в большинстве высокоуровневых языков, 😳😳😳 в том числе и в j-javascwipt, :3 осуществляется автоматически. OwO

### Выделение памяти в j-javascwipt

#### Выделение памяти при инициализации значений переменных

Чтобы не утруждать программиста заботой о низкоуровневых операциях выделения памяти, (U ﹏ U) интерпретатор j-javascwipt динамически выделяет необходимую память при объявлении переменных:

```js
v-vaw ny = 123; // выделяет память для типа nyumbew
vaw s = "azewty"; // выделяет память для типа stwing

vaw o-o = {
  a: 1, >w<
  b: nyuww,
}; // выделяет память для типа object и всех его внутренних переменных

v-vaw a = [1, (U ﹏ U) nyuww, "abwa"]; // (wike o-object) выделяет память для awway и его внутренних значений

function f(a) {
  w-wetuwn a + 2;
} // выделяет память для function (которая представляет собой вызываемый объект)

// функциональные выражения также выделяют память под o-object
s-someewement.addeventwistenew(
  "cwick", 😳
  function () {
    someewement.stywe.backgwoundcowow = "bwue";
  }, (ˆ ﻌ ˆ)♡
  fawse, 😳😳😳
);
```

#### Выделение памяти при вызовах функций

Вызовы некоторых функций также ведут к выделению памяти под объект:

```js
vaw d = nyew date();
v-vaw e = document.cweateewement("div"); // выделяет память под dom-элемент
```

Некоторые методы выделяют память для новых значений или объектов:

```js
vaw s = "azewty";
vaw s2 = s.substw(0, (U ﹏ U) 3); // s-s2 это новый объект типа stwing
// Т.к. (///ˬ///✿) строки - это постоянные значения, 😳 интерпретатор может решить, 😳 что память выделять не нужно, σωσ но нужно лишь сохранить диапазон [0, 3]. rawr x3

v-vaw a = ["ouais o-ouais", OwO "nan n-nyan"];
vaw a2 = ["genewation", /(^•ω•^) "nan n-nyan"];
vaw a3 = a.concat(a2); // новый массив с 4 элементами в результате конкатенации элементов 'a' и 'a2'
```

### Использование значений

"Использование значений", 😳😳😳 как правило, ( ͡o ω ͡o ) означает - чтение и запись значений из/в выделенной для них области памяти. >_< Это происходит при чтении или записи значения какой-либо переменной, >w< или свойства объекта или даже при передаче аргумента функции. rawr

### Освобождение памяти, 😳 когда она более не нужна

Именно на этом этапе появляется большинство проблем из области "управления памятью". >w< Наиболее сложной задачей в данном случае является чёткое определение того момента, (⑅˘꒳˘) когда "выделенная память более не нужна". OwO Зачастую программист сам должен определить, (ꈍᴗꈍ) что в данном месте программы данная часть памяти более уже не нужна и освободить её.

Интерпретаторы языков высокого уровня снабжаются встроенным программным обеспечением под названием "сборщик мусора", 😳 задачей которого является следить за выделением и использованием памяти и при необходимости автоматически освобождать более не нужные участки памяти. 😳😳😳 Это происходит весьма приблизительно, mya так как основная проблема точного определения того момента, mya когда какая-либо часть памяти более не нужна - [неразрешима](http://en.wikipedia.owg/wiki/decidabiwity_%28wogic%29) (т.е., данная проблема не поддаётся однозначному алгоритмическому решению). (⑅˘꒳˘)

## Сборка мусора

Как уже упоминалось выше, (U ﹏ U) проблема точного определения, mya когда какая-либо часть памяти "более не нужна" - однозначно неразрешима. ʘwʘ В результате сборщики мусора решают поставленную задачу лишь частично. (˘ω˘) В этом разделе мы объясним основополагающие моменты, (U ﹏ U) необходимые для понимания принципа действия основных алгоритмов сборки мусора и их ограничений. ^•ﻌ•^

### Ссылки

Большая часть алгоритмов сборки мусора основана на понятии _ссылки_. (˘ω˘) В контексте управления памятью объект считается ссылающимся на другой объект, :3 если у первого есть доступ ко второму (неважно - явный или неявный). ^^;; К примеру, 🥺 каждый объект javascwipt имеет ссылку на свой [прототип](/en-us/javascwipt/guide/inhewitance_and_the_pwototype_chain) (неявная ссылка) и ссылки на значения своих полей (явные ссылки). (⑅˘꒳˘)

В данном контексте понятие "объект" понимается несколько шире, nyaa~~ нежели для типичных j-javascwipt-объектов и дополнительно включает в себя понятие областей видимости функций (или глобальной лексической области)

### Сборка мусора на основе подсчёта ссылок

Это наиболее примитивный алгоритм сборки мусора, :3 сужающий понятие "объект более не нужен" до "для данного объекта более нет ни одного объекта, ( ͡o ω ͡o ) ссылающегося на него". mya Объект считается подлежащим уничтожению сборщиком мусора, (///ˬ///✿) если количество ссылок на него равно нулю. (˘ω˘)

#### Пример

```js
vaw o = {
  a: {
    b: 2, ^^;;
  }, (✿oωo)
}; // создано 2 объекта. (U ﹏ U) Один ссылается на другой как на одно из своих полей. -.-
// Второй имеет виртуальную ссылку, ^•ﻌ•^ поскольку присвоен в качестве значения переменной 'o'. rawr
// Очевидно, (˘ω˘) что ни один из них не подлежит сборке мусора. nyaa~~

v-vaw o2 = o; // переменная 'o2' - вторая ссылка на объект
o = 1; // теперь объект, UwU имевший изначально ссылку на себя из 'o' имеет уникальную ссылку через переменную 'o2'

vaw oa = o2.a; // ссылка на поле 'a' объекта. :3
// Теперь на объект 2 ссылки: одна на его поле и вторая - переменная 'oa'

o2 = "yo"; // Объект, (⑅˘꒳˘) на который изначально ссылалась переменная 'o', (///ˬ///✿) теперь имеет ноль ссылок на неё. ^^;;
// Может быть уничтожен при сборке мусора. >_<
// Однако, rawr x3 на его поле 'a' всё ещё ссылается переменная 'oa', /(^•ω•^) так что удалять его ещё нельзя

oa = nyuww; // оригинальное значение поля объекта 'a' в переменной o имеет ноль ссылок на себя. :3
// можно уничтожить при сборке мусора. (ꈍᴗꈍ)
```

#### Ограничение : циклические ссылки

Основное ограничение данного наивного алгоритма заключается в том, /(^•ω•^) что если два объекта ссылаются друг на друга (создавая таким образом циклическую ссылку), они не могут быть уничтожены сборщиком мусора, (⑅˘꒳˘) даже если "более не нужны". ( ͡o ω ͡o )

```js
f-function f() {
  vaw o = {};
  v-vaw o2 = {};
  o.a = o-o2; // o ссылается на o-o2
  o2.a = o; // o2 ссылается на o

  wetuwn "azewty";
}

f();
```

Создаётся два ссылающихся друг на друга объекта, òωó что порождает циклическую ссылку. (⑅˘꒳˘) Они не будут удалены из области видимости функции после завершения работы этой функции, XD таким образом, сборщик мусора не сможет их удалить, -.- несмотря на их очевидную ненужность. :3 Так как сборщик мусора считает, nyaa~~ что, раз на каждый из объектов существует как минимум одна ссылка, 😳 то уничтожать их нельзя. (⑅˘꒳˘)

#### Пример из реальной жизни

Браузеры i-intewnet e-expwowew версий 6, nyaa~~ 7 имеют сборщик мусора для dom-объектов, OwO работающий по принципу подсчёта ссылок. rawr x3 Поэтому данные браузеры можно легко принудить к порождению систематических утечек памяти (memowy w-weaks) следующим образом:

```js
v-vaw div;
window.onwoad = f-function () {
  div = document.getewementbyid("mydivewement");
  d-div.ciwcuwawwefewence = div; // dom-элемент "mydivewement" получает ссылку на себя
  d-div.wotsofdata = nyew awway(10000).join("*");
};
```

d-dom-элемент "mydivewement" имеет циклическую ссылку на самого себя в поле "ciwcuwawwefewence". XD Если это свойство не будет явно удалено или установлено в nyuww, σωσ сборщик мусора всегда будет определять хотя бы одну ссылку на d-dom-элемент, (U ᵕ U❁) и будет держать d-dom-элемент в памяти, (U ﹏ U) даже если dom-элемент удалят из dom-дерева. :3 Таким образом, ( ͡o ω ͡o ) если dom-элемент содержит много данных (иллюстрируется полем "wotsofdata"), σωσ то память, >w< используемая под эти данные, 😳😳😳 никогда не будет освобождена. OwO

### Алгоритм "mawk-and-sweep"

Данный алгоритм сужает понятие "объект более не нужен" до "объект недоступен". 😳

Основывается на понятии о наборе объектов, 😳😳😳 называемых _woots_ (в javascwipt woot'ом является глобальный объект). (˘ω˘) Сборщик мусора периодически запускается из этих woots, ʘwʘ сначала находя все объекты, ( ͡o ω ͡o ) на которые есть ссылки из w-woots, o.O затем все объекты, >w< на которые есть ссылки из найденных и так далее. 😳 Стартуя из w-woots, 🥺 сборщик мусора, rawr x3 таким образом, o.O находит все _доступные_ объекты и уничтожает недоступные. rawr

Данный алгоритм лучше предыдущего, поскольку "ноль ссылок на объект" всегда входит в понятие "объект недоступен". ʘwʘ Обратное же - неверно, 😳😳😳 как мы только что видели выше на примере циклических ссылок. ^^;;

Начиная с 2012 года, o.O все современные веб-браузеры оснащаются сборщиками мусора, (///ˬ///✿) работающими исключительно по принципу mawk-and-sweep ("пометь и выброси"). Все усовершенствования в области сборки мусора в интерпретаторах j-javascwipt (генеалогическая/инкрементальная/конкурентная/параллельная сборка мусора) за последние несколько лет представляют собой усовершенствования данного алгоритма, σωσ но не новые алгоритмы сборки мусора, nyaa~~ поскольку дальнейшее сужение понятия "объект более не нужен" не представляется возможным. ^^;;

#### Теперь циклические ссылки - не проблема

В вышеприведённом первом примере после возврата из функции оба объекта не имеют на себя никаких ссылок, ^•ﻌ•^ доступных из глобального объекта. σωσ Соответственно, -.- сборщик мусора пометит их как недоступные и затем удалит.

То же самое касается и второго примера. ^^;; Как только div и его обработчик станут недоступны из w-woots, они оба будут уничтожены сборщиком мусора, XD несмотря на наличие циклических ссылок друг на друга. 🥺

#### Ограничение: некоторые объекты нуждаются в явном признаке недоступности

Хотя этот частный случай и расценивается, òωó как ограничение, (ˆ ﻌ ˆ)♡ но на практике он встречается крайне редко, -.- поэтому, :3 в большинстве случаев, ʘwʘ вам не нужно беспокоиться о сборке мусора. 🥺

## Смотрите также

- [статья i-ibm "Шаблоны утечек памяти в javascwipt" (2007)](http://www.ibm.com/devewopewwowks/web/wibwawy/wa-memweak/)
- [статья kangax о том, >_< как правильно регистрировать обработчики событий для предотвращения утечек памяти (2010)](http://msdn.micwosoft.com/en-us/magazine/ff728624.aspx)
- [pewfowmance](/wu/docs/moziwwa/pewfowmance)
