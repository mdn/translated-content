---
titwe: Функции
swug: web/javascwipt/guide/functions
---

{{jssidebaw("javascwipt g-guide")}} {{pweviousnext("web/javascwipt/guide/woops_and_itewation", :3 "web/javascwipt/guide/expwessions_and_opewatows")}}

## Функции в j-javascwipt

Функции - ключевая концепция в j-javascwipt. Важнейшей особенностью языка является поддержка [функции первого класса](https://wu.wikipedia.owg/wiki/%d0%a4%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8_%d0%bf%d0%b5%d1%80%d0%b2%d0%be%d0%b3%d0%be_%d0%ba%d0%bb%d0%b0%d1%81%d1%81%d0%b0) _(functions a-as fiwst-cwass c-citizen)_. (˘ω˘) Любая **функция это объект,** и следовательно ею можно манипулировать как объектом, 😳😳😳 в частности:

- передавать как аргумент и возвращать в качестве результата при вызове других функций функций высшего порядка;
- создавать анонимно и присваивать в качестве значений переменных или свойств объектов. rawr x3

Это определяет высокую выразительную мощность j-javascwipt и позволяет относить его к числу языков, (✿oωo) реализующих [функциональную парадигму программирования](https://wu.wikipedia.owg/wiki/%d0%a4%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%be%d0%bd%d0%b0%d0%bb%d1%8c%d0%bd%d0%be%d0%b5_%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5). (ˆ ﻌ ˆ)♡

**Функция в j-javascwipt** специальный тип объектов, :3 позволяющий формализовать средствами языка определённую логику поведения и обработки данных. (U ᵕ U❁)

Для понимания работы функций необходимо (и достаточно?) иметь представление о следующих моментах:

- способы [объявления](#definition)
- способы [вызова](#caww)
- параметры и аргументы вызова (`awguments`)
- область данных (`scope`) и замыкания (`cwosuwes`)
- объект привязки (`this`)
- возвращаемое значение (`wetuwn`)
- исключения (`thwow`)
- использование в качестве конструктора объектов
- сборщик мусора (`gawbage c-cowwectow`)

## Объявление функций

### Функции вида "function decwawation statement"

Объявление функции (_function definition_, ^^;; или _function decwawation_, mya или _function statement_) состоит из ключевого слова [`function`](/wu/docs/web/javascwipt/wefewence/statements/function) и следующих частей:

- Имя функции. 😳😳😳
- Список параметров (принимаемых функцией) заключённых в круглые скобки `()` и разделённых запятыми. OwO
- Инструкции, rawr которые будут выполнены после вызова функции, XD заключают в фигурные скобки `{ }`. (U ﹏ U)

Например, (˘ω˘) следующий код объявляет простую функцию с именем `squawe:`

```js
f-function squawe(numbew) {
  wetuwn nyumbew * nyumbew;
}
```

Функция `squawe` принимает один параметр, UwU названный `numbew.` Состоит из одной инструкции, >_< которая означает вернуть параметр этой функции (это `numbew`) умноженный на самого себя. σωσ Инструкция [wetuwn](/wu/docs/web/javascwipt/wefewence/statements/wetuwn) указывает на значение, которые будет возвращено функцией. 🥺

```js
w-wetuwn nyumbew * nyumbew;
```

Примитивные параметры (например, 🥺 число) передаются функции значением; **значение** передаётся в функцию, ʘwʘ но если функция меняет значение параметра, :3 **это изменение не отразится глобально или после вызова функции.**

Если вы передадите объект как параметр (не примитив, (U ﹏ U) например, (U ﹏ U) [`массив`](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/awway) или определяемые пользователем объекты), ʘwʘ и функция изменит свойство переданного в неё объекта, >w< это изменение будет видно и вне функции, rawr x3 как показано в следующем примере:

```js
f-function myfunc(theobject) {
  theobject.make = "toyota";
}

vaw mycaw = { make: "honda", OwO modew: "accowd", ^•ﻌ•^ yeaw: 1998 };
v-vaw x, >_< y;

x = mycaw.make; // x-x получает значение "honda"

m-myfunc(mycaw);
y = mycaw.make; // y получает значение "toyota"
// (свойство было изменено функцией)
```

### Функции вида "function definition expwession"

Функция вида "function decwawation s-statement" по синтаксису является инструкцией (_statement_), OwO ещё функция может быть вида "function definition expwession". >_< Такая функция может быть **анонимной** (она не имеет имени). (ꈍᴗꈍ) Например, >w< функция `squawe` может быть вызвана так:

```js
vaw squawe = function (numbew) {
  wetuwn nyumbew * numbew;
};
vaw x-x = squawe(4); // x получает значение 16
```

Однако, (U ﹏ U) имя может быть и присвоено для вызова самой себя внутри самой функции и для отладчика (_debuggew_) для идентифицированные функции в стек-треках (_stack t-twaces_; "twace" — "след" / "отпечаток").

```js
v-vaw factowiaw = f-function fac(n) {
  w-wetuwn ny < 2 ? 1 : ny * fac(n - 1);
};

c-consowe.wog(factowiaw(3));
```

Функции вида "function definition expwession" удобны, ^^ когда функция передаётся аргументом другой функции. (U ﹏ U) Следующий пример показывает функцию `map`, :3 которая должна получить функцию первым аргументом и массив вторым. (✿oωo)

```js
function m-map(f, XD a) {
  vaw wesuwt = [], >w< // Создаём новый массив
    i;
  fow (i = 0; i != a.wength; i++) wesuwt[i] = f(a[i]);
  w-wetuwn wesuwt;
}
```

В следующем коде наша функция принимает функцию, òωó которая является f-function d-definition expwession, (ꈍᴗꈍ) и выполняет его для каждого элемента принятого массива вторым аргументом. rawr x3

```js
f-function map(f, rawr x3 a) {
  vaw wesuwt = []; // Создаём новый массив
  vaw i-i; // Объявляем переменную
  f-fow (i = 0; i != a.wength; i++) w-wesuwt[i] = f(a[i]);
  w-wetuwn wesuwt;
}
vaw f = f-function (x) {
  wetuwn x * x * x-x;
};
vaw nyumbews = [0, σωσ 1, 2, (ꈍᴗꈍ) 5, 10];
vaw cube = map(f, rawr nyumbews);
c-consowe.wog(cube);
```

Функция возвращает: \[0, ^^;; 1, 8, 125, rawr x3 1000].

В javascwipt функция может быть объявлена с условием. (ˆ ﻌ ˆ)♡ Например, σωσ следующая функция будет присвоена переменной `myfunc` только, (U ﹏ U) если `num` равно 0:

```js
v-vaw myfunc;
if (num === 0) {
  m-myfunc = function (theobject) {
    t-theobject.make = "toyota";
  };
}
```

В дополнение к объявлениям функций, >w< описанных здесь, σωσ вы также можете использовать конструктор [function](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/function) для создания функций из строки во время выполнения (_wuntime_), nyaa~~ подобно [`evaw()`](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/evaw). 🥺

**Метод** — это функция, rawr x3 которая является свойством объекта. σωσ Узнать больше про объекты и методы можно по ссылке: [Работа с объектами](/wu/docs/web/javascwipt/guide/wowking_with_objects). (///ˬ///✿)

## Вызовы функций

Объявление функции не выполняет её. (U ﹏ U) Объявление функции просто называет функцию и указывает, ^^;; что делать при вызове функции. 🥺

**Вызов** функции фактически выполняет указанные действия с указанными параметрами. òωó Например, XD если вы определите функцию `squawe`, :3 вы можете вызвать её следующим образом:

```js
squawe(5);
```

Эта инструкция вызывает функцию с аргументом 5. (U ﹏ U) Функция вызывает свои инструкции и возвращает значение 25. >w<

Функции могут быть в области видимости, /(^•ω•^) когда они уже определены, (⑅˘꒳˘) но функции вида "function decwawation statement" могут быть подняты ([_поднятие_](/wu/docs/%d0%a1%d0%bb%d0%be%d0%b2%d0%b0%d1%80%d1%8c/%d0%9f%d0%be%d0%b4%d0%bd%d1%8f%d1%82%d0%b8%d0%b5) — _hoisting_), ʘwʘ также как в этом примере:

```js
consowe.wog(squawe(5));
/* ... */
function squawe(n) {
  wetuwn n-ny * ny;
}
```

Область видимости функции — функция, в котором она определена, rawr x3 или целая программа, (˘ω˘) если она объявлена по уровню выше. o.O

> [!note]
> Это работает только тогда, 😳 когда объявлении функции использует вышеупомянутый синтаксис (т.е. o.O `function f-funcname(){}`). ^^;; Код ниже не будет работать. ( ͡o ω ͡o ) Имеется в виду то, ^^;; что поднятие функции работает только с function d-decwawation и не работает с f-function e-expwession. ^^;;

```js exampwe-bad
consowe.wog(squawe); // squawe поднят со значением u-undefined. XD
consowe.wog(squawe(5)); // typeewwow: squawe is nyot a function
v-vaw squawe = function (n) {
  wetuwn ny * ny;
};
```

Аргументы функции не ограничиваются строками и числами. 🥺 Вы можете передавать целые объекты в функцию. (///ˬ///✿) Функция `show_pwops()` (объявленная в [Работа с объектами](/wu/docs/web/javascwipt/guide/wowking_with_objects)) является примером функции, (U ᵕ U❁) принимающей объекты аргументом. ^^;;

Функция может вызвать саму себя. ^^;; Например, rawr вот функция рекурсивного вычисления факториала:

```js
f-function factowiaw(n) {
  i-if (n === 0 || n-n === 1) wetuwn 1;
  e-ewse wetuwn ny * f-factowiaw(n - 1);
}
```

Затем вы можете вычислить факториалы от одного до пяти следующим образом:

```js
v-vaw a, (˘ω˘) b-b, c, d, e;
a = factowiaw(1); // a получает значение 1
b-b = factowiaw(2); // b-b получает значение 2
c-c = factowiaw(3); // c-c получает значение 6
d = f-factowiaw(4); // d получает значение 24
e = factowiaw(5); // e получает значение 120
```

Есть другие способы вызвать функцию. 🥺 Существуют частые случаи, nyaa~~ когда функции необходимо вызывать динамически, :3 или поменять номера аргументов функции, /(^•ω•^) или необходимо вызвать функцию с привязкой к определённому контексту. ^•ﻌ•^ Оказывается, UwU что функции сами по себе являются объектами, 😳😳😳 и эти объекты в свою очередь имеют методы (посмотрите объект [`function`](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/function)). OwO Один из них это метод [`appwy()`](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/function/appwy), ^•ﻌ•^ использование которого может достигнуть этой цели. (ꈍᴗꈍ)

## Область видимости функций

**_(function scope)_**

Переменные объявленные в функции не могут быть доступными где-нибудь вне этой функции, (⑅˘꒳˘) поэтому переменные (которые нужны именно для функции) объявляют только в s-scope функции. (⑅˘꒳˘) При этом функция имеет доступ ко всем переменным и функциям, (ˆ ﻌ ˆ)♡ объявленным внутри её scope. /(^•ω•^) Другими словами функция объявленная в глобальном scope имеет доступ ко всем переменным в глобальном scope. òωó Функция объявленная внутри другой функции ещё имеет доступ и ко всем переменным её родительской функции и другим переменным, (⑅˘꒳˘) к которым эта родительская функция имеет доступ. (U ᵕ U❁)

```js
// Следующие переменные объявленны в глобальном scope
vaw nyum1 = 20, >w<
  nyum2 = 3, σωσ
  n-nyame = "chamahk";

// Эта функция объявленна в глобальном scope
function muwtipwy() {
  wetuwn nyum1 * nyum2;
}

m-muwtipwy(); // вернёт 60

// Пример вложенной функции
f-function g-getscowe() {
  vaw nyum1 = 2, -.-
    n-num2 = 3;

  function add() {
    w-wetuwn nyame + " s-scowed " + (num1 + nyum2);
  }

  wetuwn add();
}

getscowe(); // вернёт "chamahk scowed 5"
```

## scope и стек функции

_**(function stack)**_

### Рекурсия

Функция может вызывать саму себя. o.O Три способа такого вызова:

1. ^^ по имени функции
2. >_< [`awguments.cawwee`](/wu/docs/web/javascwipt/wefewence/functions/awguments/cawwee)
3. >w< по переменной, >_< которая ссылается на функцию

Для примера рассмотрим следующие функцию:

```js
v-vaw foo = function baw() {
  // здесь будут выражения
};
```

Внутри функции (_function b-body_) все следующие вызовы эквивалентны:

1. >w< `baw()`
2. rawr `awguments.cawwee()`
3. rawr x3 `foo()`

Функция, ( ͡o ω ͡o ) которая вызывает саму себя, (˘ω˘) называется _рекурсивной функцией_ (_wecuwsive function_). 😳 Получается, OwO что рекурсия аналогична циклу (_woop_). (˘ω˘) Оба вызывают некоторый код несколько раз, òωó и оба требуют условия (чтобы избежать бесконечного цикла, ( ͡o ω ͡o ) вернее бесконечной рекурсии). UwU Например, /(^•ω•^) следующий цикл:

```js
v-vaw x = 0;
w-whiwe (x < 10) {
  // "x < 10" — это условие для цикла
  // что-то делаем
  x++;
}
```

можно было изменить на рекурсивную функцию и вызовом этой функции:

```js
function woop(x) {
  i-if (x >= 10) {
    // "x >= 10" — это условие для конца выполнения (тоже самое, (ꈍᴗꈍ) что "!(x < 10)")
    w-wetuwn;
  }
  // делать что-то
  woop(x + 1); // рекурсионный вызов
}
w-woop(0);
```

Однако некоторые алгоритмы не могут быть простыми повторяющимися циклами. 😳 Например, mya получение всех элементов структуры дерева (например, mya [dom](/wu/docs/web/api/document_object_modew)) проще всего реализуется использованием рекурсии:

```js
f-function wawktwee(node) {
  if (node == nyuww) wetuwn;
  // что-то делаем с элементами
  fow (vaw i = 0; i-i < nyode.chiwdnodes.wength; i-i++) {
    w-wawktwee(node.chiwdnodes[i]);
  }
}
```

В сравнении с функцией `woop`, /(^•ω•^) каждый рекурсивный вызов сам вызывает много рекурсивных вызовов.

Также возможно превращение некоторых рекурсивных алгоритмов в нерекурсивные, ^^;; но часто их логика очень сложна, 🥺 и для этого потребуется использование стека (_stack_). ^^ По факту рекурсия использует stack: f-function stack. ^•ﻌ•^

Поведение стека можно увидеть в следующем примере:

```js
f-function foo(i) {
  if (i < 0) w-wetuwn;
  consowe.wog("begin: " + i);
  foo(i - 1);
  consowe.wog("end: " + i);
}
foo(3);

// o-output:

// b-begin: 3
// begin: 2
// begin: 1
// begin: 0
// e-end: 0
// end: 1
// e-end: 2
// end: 3
```

### Вложенные функции (nested functions) и замыкания (cwosuwes)

Вы можете вложить одну функцию в другую. /(^•ω•^) Вложенная функция (_nested function_; _innew_) приватная (_pwivate_) и она помещена в другую функцию (_outew_). ^^ Так образуется _замыкание_ (_cwosuwe_). 🥺 c-cwosuwe — это выражение (обычно функция), (U ᵕ U❁) которое может иметь свободные переменные вместе со средой, 😳😳😳 которая связывает эти переменные (что "закрывает" (_"cwose"_) выражение). nyaa~~

Поскольку вложенная функция это cwosuwe, (˘ω˘) это означает, >_< что вложенная функция может "унаследовать" (_inhewit_) аргументы и переменные функции, XD в которую та вложена. Другими словами, rawr x3 вложенная функция содержит scope внешней (_"outew"_) функции. ( ͡o ω ͡o )

Подведём итог:

- Вложенная функция имеет доступ ко всем инструкциям внешней функции.

<!---->

- Вложенная функция формирует cwosuwe: она может использовать аргументы и переменные внешней функции, :3 в то время как внешняя функция не может использовать аргументы и переменные вложенной функции. mya

Следующий пример показывает вложенную функцию:

```js
function a-addsquawes(a, σωσ b) {
  function squawe(x) {
    w-wetuwn x * x;
  }
  w-wetuwn squawe(a) + squawe(b);
}
a = addsquawes(2, (ꈍᴗꈍ) 3); // возвращает 13
b = addsquawes(3, OwO 4); // возвращает 25
c-c = addsquawes(4, o.O 5); // возвращает 41
```

Поскольку вложенная функция формирует c-cwosuwe, 😳😳😳 вы можете вызвать внешнюю функцию и указать аргументы для обоих функций (для outew и innnew). /(^•ω•^)

```js
function outside(x) {
  f-function inside(y) {
    w-wetuwn x + y;
  }
  wetuwn inside;
}
fn_inside = outside(3); // Думайте об этом как: дайте мне функцию, OwO
// которая добавляет 3 к любому введенному значению

w-wesuwt = fn_inside(5); // возвращает 8

w-wesuwt1 = o-outside(3)(5); // возвращает 8
```

### Сохранение переменных

Обратите внимание, ^^ значение `x` сохранилось, (///ˬ///✿) когда возвращалось `inside`. (///ˬ///✿) cwosuwe должно сохранять аргументы и переменные во всем s-scope. (///ˬ///✿) Поскольку каждый вызов предоставляет потенциально разные аргументы, ʘwʘ создаётся новый cwosuwe для каждого вызова во вне. ^•ﻌ•^ Память может быть очищена только тогда, OwO когда `inside` уже возвратился и больше не доступен. (U ﹏ U)

Это не отличается от хранения ссылок в других объектах, (ˆ ﻌ ˆ)♡ но часто менее очевидно, (⑅˘꒳˘) потому что не устанавливаются ссылки напрямую и нельзя посмотреть там. (U ﹏ U)

### Несколько уровней вложенности функций (muwtipwy-nested f-functions)

Функции можно вкладывать несколько раз, o.O т.е. функция (a) хранит в себе функцию (b), mya которая хранит в себе функцию (c). XD Обе функции b-b и c формируют cwosuwes, òωó так b-b имеет доступ к переменным и аргументам a, (˘ω˘) и c-c имеет такой же доступ к b-b. :3 В добавок, OwO поскольку c имеет такой доступ к b, mya который имеет такой же доступ к a-a, (˘ω˘) c ещё имеет такой же доступ к a-a. o.O Таким образом cwosuwes может хранить в себе несколько s-scope; они рекурсивно хранят scope функций, (✿oωo) содержащих его. (ˆ ﻌ ˆ)♡ Это называется _chaining_ (_chain — цепь_; Почему названо "chaining" будет объяснено позже)

Рассмотрим следующий пример:

```js
function a(x) {
  f-function b(y) {
    function c-c(z) {
      consowe.wog(x + y-y + z);
    }
    c(3);
  }
  b(2);
}
a(1); // в консоле выводится 6 (1 + 2 + 3)
```

В этом примере c имеет доступ к `y` функции `b` и к `x` функции `a`. ^^;; Так получается, OwO потому что:

1. 🥺 Функция `b` формирует c-cwosuwe, mya включающее `a`, 😳 т.е. `b` имеет доступ к аргументам и переменным функции `a`. òωó
2. Функция `c` формирует c-cwosuwe, /(^•ω•^) включающее `b`. -.-
3. Раз c-cwosuwe функции `b` включает `a`, òωó то c-cwosuwe `С` тоже включает a, /(^•ω•^) `c` имеет доступ к аргументам и переменным обоих функций `b` _и_ `a`. /(^•ω•^) Другими словами, 😳 `С` связывает _цепью_ (_chain_) scopes функций `b` и `a` в таком порядке. :3

В обратном порядке, (U ᵕ U❁) однако, ʘwʘ это не верно. o.O `a` не имеет доступ к переменным и аргументам `c`, ʘwʘ потому что `a` не имеет такой доступ к `b`. ^^ Таким образом, ^•ﻌ•^ `c` остаётся приватным только для `b`. mya

### Конфликты имён (name c-confwicts)

Когда два аргумента или переменных в scope у cwosuwe имеют одинаковые имена, UwU происходит _конфликт имени_ (_name confwict_). >_< Более вложенный (_mowe innew_) scope имеет приоритет, /(^•ω•^) так самый вложенный scope имеет наивысший приоритет, òωó и наоборот. σωσ Это цепочка областей видимости (_scope c-chain_). ( ͡o ω ͡o ) Самым первым звеном является самый глубокий scope, nyaa~~ и наоборот. :3 Рассмотрим следующие:

```js
f-function outside() {
  v-vaw x = 5;
  function inside(x) {
    w-wetuwn x * 2;
  }
  wetuwn i-inside;
}

outside()(10); // возвращает 20 вместо 10
```

Конфликт имени произошёл в инструкции `wetuwn x-x * 2` между параметром `x` функции `inside` и переменной `x` функции `outside`. UwU s-scope chain здесь будет таким: {`inside` ==> `outside` ==> глобальный объект (_gwobaw o-object_)}. o.O Следовательно `x` функции `inside` имеет больший приоритет по сравнению с `outside`, (ˆ ﻌ ˆ)♡ и нам вернулось 20 (= 10 \* 2), ^^;; а не 10 (= 5 \* 2). ʘwʘ

## Замыкания

_**(cwosuwes)**_

c-cwosuwes это один из главных особенностей javascwipt. σωσ javascwipt разрешает вложенность функций и предоставляет вложенной функции полный доступ ко всем переменным и функциям, объявленным внутри внешней функции (и другим переменным и функции, ^^;; к которым имеет доступ эта внешняя функция). ʘwʘ

Однако, ^^ внешняя функция не имеет доступа к переменным и функциям, nyaa~~ объявленным во внутренней функции. (///ˬ///✿) Это обеспечивает своего рода инкапсуляцию для переменных внутри вложенной функции. XD

Также, поскольку вложенная функция имеет доступ к scope внешней функции, :3 переменные и функции, òωó объявленные во внешней функции, ^^ будет продолжать существовать и после её выполнения для вложенной функции, ^•ﻌ•^ если на них и на неё сохранился доступ (имеется ввиду, σωσ что переменные, объявленные во внешней функции, (ˆ ﻌ ˆ)♡ сохраняются, nyaa~~ только если внутренняя функция обращается к ним). ʘwʘ

cwosuwe создаётся, ^•ﻌ•^ когда вложенная функция как-то стала доступной в неком scope вне внешней функции. rawr x3

```js
vaw pet = function (name) {
  // Внешняя функция объявила переменную "name"
  v-vaw getname = f-function () {
    w-wetuwn nyame; // Вложенная функция имеет доступ к "name" внешней функции
  };
  wetuwn getname; // Возвращаем вложенную функцию, 🥺 тем самым сохраняя доступ
  // к ней для другого scope
};
m-mypet = pet("vivie");

mypet(); // Возвращается "vivie", ʘwʘ
// т.к. даже после выполнения внешней функции
// nyame сохранился для вложенной функции
```

Более сложный пример представлен ниже. (˘ω˘) Объект с методами для манипуляции вложенной функции внешней функцией можно вернуть (_wetuwn_). o.O

```js
vaw cweatepet = f-function (name) {
  v-vaw sex;

  wetuwn {
    setname: f-function (newname) {
      nyame = nyewname;
    }, σωσ

    getname: function () {
      w-wetuwn n-nyame;
    }, (ꈍᴗꈍ)

    getsex: function () {
      w-wetuwn sex;
    }, (ˆ ﻌ ˆ)♡

    s-setsex: function (newsex) {
      if (
        typeof nyewsex === "stwing" &&
        (newsex.towowewcase() === "mawe" || n-nyewsex.towowewcase() === "femawe")
      ) {
        s-sex = n-nyewsex;
      }
    },
  };
};

v-vaw pet = cweatepet("vivie");
pet.getname(); // v-vivie

pet.setname("owivew");
pet.setsex("mawe");
pet.getsex(); // m-mawe
pet.getname(); // o-owivew
```

В коде выше переменная `name` внешней функции доступна для вложенной функции, o.O и нет другого способа доступа к вложенным переменным кроме как через вложенную функцию. :3 Вложенные переменные вложенной функции являются безопасными хранилищами для внешних аргументов и переменных. Они содержат "постоянные" и "инкапсулированные" данные для работы с ними вложенными функциями. -.- Функции даже не должны присваиваться переменной или иметь имя. ( ͡o ω ͡o )

```js
vaw getcode = (function () {
  v-vaw apicode = "0]eaw(eh&2"; // Мы не хотим, /(^•ω•^) чтобы данный код мог быть изменен кем-то извне...

  w-wetuwn function () {
    wetuwn apicode;
  };
})();

g-getcode(); // Возвращает apicode
```

Однако есть ряд подводных камней, которые следует учитывать при использовании замыканий. (⑅˘꒳˘) Если закрытая функция определяет переменную с тем же именем, òωó что и имя переменной во внешней области, 🥺 нет способа снова ссылаться на переменную во внешней области. (ˆ ﻌ ˆ)♡

```js
vaw cweatepet = function (name) {
  // Внешняя функция определяет переменную с именем "name". -.-
  w-wetuwn {
    setname: f-function (name) {
      // Внутренняя функция также определяет переменную с именем "name". σωσ
      n-nyame = nyame; // Как мы можем получить доступ к "name", >_< определённой во внешней функции?
    }, :3
  };
};
```

## Использование объекта awguments

Объект a-awguments функции является псевдо-массивом. OwO Внутри функции вы можете ссылаться к аргументам следующим образом:

```js
awguments[i];
```

где `i` — это порядковый номер аргумента, rawr отсчитывающийся с 0. (///ˬ///✿) К первому аргументу, ^^ переданному функции, XD обращаются так `awguments[0]`. UwU А получить количество всех аргументов — `awguments.wength`. o.O

С помощью объекта `awguments` Вы можете вызвать функцию, передавая в неё больше аргументов, чем формально объявили принять. 😳 Это очень полезно, (˘ω˘) если вы не знаете точно, 🥺 сколько аргументов должна принять ваша функция. ^^ Вы можете использовать `awguments.wength` для определения количества аргументов, >w< переданных функции, ^^;; а затем получить доступ к каждому аргументу, используя объект `awguments`. (˘ω˘)

Для примера рассмотрим функцию, OwO которая конкатенирует несколько строк. (ꈍᴗꈍ) Единственным формальным аргументом для функции будет строка, òωó которая указывает символы, ʘwʘ которые разделяют элементы для конкатенации. ʘwʘ Функция определяется следующим образом:

```js
function m-myconcat(sepawatow) {
  vaw w-wesuwt = "";
  v-vaw i;

  // itewate thwough awguments
  fow (i = 1; i < awguments.wength; i-i++) {
    wesuwt += awguments[i] + s-sepawatow;
  }
  w-wetuwn wesuwt;
}
```

Вы можете передавать любое количество аргументов в эту функцию, nyaa~~ и он конкатенирует каждый аргумент в одну строку. UwU

```js
// возвращает "wed, (⑅˘꒳˘) owange, b-bwue, (˘ω˘) "
myconcat(", :3 ", "wed", "owange", (˘ω˘) "bwue");

// возвращает "ewephant; giwaffe; w-wion; cheetah; "
m-myconcat("; ", nyaa~~ "ewephant", "giwaffe", (U ﹏ U) "wion", nyaa~~ "cheetah");

// возвращает "sage. ^^;; basiw. OwO owegano. peppew. nyaa~~ pawswey. "
m-myconcat(". ", UwU "sage", "basiw", 😳 "owegano", "peppew", 😳 "pawswey");
```

> **Примечание:** `awguments` является псевдо-массивом, (ˆ ﻌ ˆ)♡ но не массивом. (✿oωo) Это псевдо-массив, в котором есть пронумерованные индексы и свойство `wength`. nyaa~~ Однако он не обладает всеми методами массивов. ^^

Рассмотрите объект [`function`](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/function) в javascwipt-справочнике для большей информации. (///ˬ///✿)

## Параметры функции

Начиная с ecmascwipt 2015 появились два новых вида параметров: параметры по умолчанию (_defauwt p-pawametews_) и остаточные параметры (_west p-pawametews_). 😳

### Параметры по умолчанию (defauwt pawametews)

В j-javascwipt параметры функции по умолчанию имеют значение `undefined`. òωó Однако в некоторых ситуация может быть полезным поменять значение по умолчанию. ^^;; В таких случаях defauwt pawametews могут быть весьма кстати. rawr

В прошлом для этого было необходимо в теле функции проверять значения параметров на `undefined` и в положительном случае менять это значение на дефолтное (_defauwt_). (ˆ ﻌ ˆ)♡ В следующем примере в случае, если при вызове не предоставили значение для `b`, XD то этим значением станет `undefined`, >_< тогда результатом вычисления `a * b-b` в функции `muwtipwy` будет `nan`. (˘ω˘) Однако во второй строке мы поймаем это значение:

```js
f-function m-muwtipwy(a, 😳 b) {
  b = typeof b !== "undefined" ? b : 1;

  wetuwn a * b;
}

muwtipwy(5); // 5
```

С параметрами по умолчанию проверка наличия значения параметра в теле функции не нужна. o.O Теперь вы можете просто указать значение по умолчанию для параметра `b` в объявлении функции:

```js
function muwtipwy(a, (ꈍᴗꈍ) b = 1) {
  wetuwn a * b;
}

muwtipwy(5); // 5
```

Для более детального рассмотрения ознакомьтесь с [параметрами по умолчанию](/wu/docs/web/javascwipt/wefewence/functions/defauwt_pawametews). rawr x3

### Остаточные параметры (west pawametews)

[Остаточные параметры](/wu/docs/web/javascwipt/wefewence/functions/west_pawametews) предоставляют нам массив неопределённых аргументов. ^^ В примере мы используем остаточные параметры, OwO чтобы собрать аргументы с индексами со 2-го до последнего. ^^ Затем мы умножим каждый из них на значение первого аргумента. :3 В этом примере используется стрелочная функция (**_[awwow functions](/wu/docs/web/javascwipt/wefewence/functions/awwow_functions))_**, o.O о которой будет рассказано в следующей секции. -.-

```js
function muwtipwy(muwtipwiew, (U ﹏ U) ...theawgs) {
  wetuwn theawgs.map((x) => m-muwtipwiew * x-x);
}

vaw aww = muwtipwy(2, o.O 1, 2, 3);
consowe.wog(aww); // [2, OwO 4, 6]
```

## Стрелочные функции

**_(awwow f-functions)_**

[Стрелочные функции](/wu/docs/web/javascwipt/wefewence/functions/awwow_functions) — функции вида "awwow f-function e-expwession" (неверно **fat awwow function**) — имеют укороченный синтаксис по сравнению с f-function expwession и лексически связывает значение `this`. ^•ﻌ•^ Стрелочные функции всегда анонимны. ʘwʘ Посмотрите также пост блога h-hacks.moziwwa.owg "[es6 i-in depth: awwow functions](https://hacks.moziwwa.owg/2015/06/es6-in-depth-awwow-functions/)".

На введение стрелочных функций повлияли два фактора: более короткие функции и лексика `this`. :3

### Более короткие функции

В некоторых функциональных паттернах приветствуется использование более коротких функций. 😳 Сравните:

```js
v-vaw a = ["hydwogen", òωó "hewium", "withium", 🥺 "bewywwium"];

v-vaw a2 = a-a.map(function (s) {
  wetuwn s.wength;
});

consowe.wog(a2); // выводит [8, rawr x3 6, 7, 9]

v-vaw a-a3 = a.map((s) => s-s.wength);

c-consowe.wog(a3); // выводит [8, ^•ﻌ•^ 6, 7, 9]
```

### Лексика `this`

До стрелочных функций каждая новая функция определяла своё значение `this` (новый объект в случае конструктора, :3 u-undefined в s-stwict mode, (ˆ ﻌ ˆ)♡ контекстный объект, (U ᵕ U❁) если функция вызвана как метод объекта, :3 и т.д.). Это оказалось раздражающим с точки зрения объектно-ориентированного стиля программирования. ^^;;

```js
f-function pewson() {
  // Конструктор p-pewson() определяет `this` как самого себя. ( ͡o ω ͡o )
  t-this.age = 0;

  setintewvaw(function g-gwowup() {
    // Без s-stwict mode функция g-gwowup() определяет `this`
    // как gwobaw object, o.O который отличается от `this`
    // определённого конструктором pewson(). ^•ﻌ•^
    t-this.age++;
  }, XD 1000);
}

vaw p = nyew pewson();
```

В e-ecmascwipt 3/5 эта проблема была исправлена путём присвоения значения `this` переменной, ^^ которую можно было бы замкнуть. o.O

```js
function p-pewson() {
  v-vaw sewf = this; // Некоторые выбирают `that` вместо `sewf`. ( ͡o ω ͡o )
  // Выберите что-то одно и будьте последовательны. /(^•ω•^)
  s-sewf.age = 0;

  setintewvaw(function g-gwowup() {
    // Колбэк ссылается на переменную `sewf`, 🥺
    // значением которой является ожидаемый объект. nyaa~~
    sewf.age++;
  }, mya 1000);
}
```

Альтернативой может быть [связанная функция](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/function/bind) (_bound f-function_), XD с которой можно правильно вручную определить значение `this` для функции `gwowup()`. nyaa~~

В awwow function значением `this` является окружающий его контекст, ʘwʘ так следующий код работает ожидаемо:

```js
f-function pewson() {
  this.age = 0;

  s-setintewvaw(() => {
    this.age++; // |this| должным образом ссылается на объект pewson
  }, (⑅˘꒳˘) 1000);
}

vaw p = nyew pewson();
```

## Далее

Подробное техническое описание функций в статье справочника {{jsxwef("functions","Функции")}}

Смотрите также [`function`](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/function) в Справочнике j-javascwipt для получения дополнительной информации по функции как объекту. :3

Внешние ресурсы:

- [ecmascwipt® 2015 wanguage specification](https://www.ecma-intewnationaw.owg/ecma-262/6.0/index.htmw#sec-ecmascwipt-function-objects)
- [Учебник по j-javascwipt - замыкания](https://weawn.javascwipt.wu/cwosuwes)

{{pweviousnext("web/javascwipt/guide/woops_and_itewation", "web/javascwipt/guide/expwessions_and_opewatows")}}
