---
title: Навигация с клавиатуры в JavaScript
slug: Web/Accessibility/Guides/Keyboard-navigable_JavaScript_widgets
---

Как сделать для JavaScript-виджетов на основе span или div возможность навигации с клавиатуры.

### Введение

В веб-приложениях часто используется JavaScript для имитации работы различных элементов, перешедших в веб с десктопных приложений: меню, деревья, нестандартные элементы форм и панели вкладок. Все эти элементы можно назвать виджетами. В вёрстке виджеты обычно состоят из набора HTML-элементов {{ HTMLElement("div") }} и {{ HTMLElement("span") }}, которые по умолчанию не предоставляют возможности работать с ними, используя клавиатуру, в отличие от их десктопных аналогов. В данной статье описывается техника, позволяющая сделать JS-виджеты управляемыми с клавиатуры.

## Использование атрибута tabindex

Атрибут `tabindex` был представлен в спецификации HTML 4. Он позволяет задать порядок, в котором элементы будут получать фокус при навигации с клавиатуры. Текущая реализация, описанная в HTML 5 draft specs, довольно сильно отличается от первоначальной. Все распространённые браузеры теперь придерживаются новой спецификации.

По умолчанию, когда люди используют клавишу tab для просмотра веб-страницы, в фокусе оказываются только интерактивные элементы (например, ссылки, элементы управления формами). С помощью [глобального атрибута] `tabindex` (/ru/docs/Web/HTML/Reference/Global_attributes) разработчики могут сделать фокусируемыми и другие элементы. Если установить значение `0`, элемент становится фокусируемым  с помощью клавиатуры и скрипта. При установке значения `-1` элемент становится фокусируемым скриптом, но не становится частью порядка фокусировки клавиатуры.

Порядок, в котором элементы получают фокус при использовании клавиатуры, по умолчанию является исходным. В исключительных обстоятельствах разработчики могут переопределить порядок фокусирования. Для этого они могут присвоить в качестве значения атрибута `tabindex` любое положительное число.

> [!ПРИМЕЧАНИЕ]
> Избегайте использования положительных значений для `tabindex`. Элементы с положительным `tabindex` ставятся перед интерактивными элементами на странице по умолчанию, это значит, что разработчикам придётся устанавливать (и поддерживать) значения `tabindex` для всех фокусируемых элементов на странице, если они используют одно или несколько положительных значений для `tabindex`.

В данной таблице описано поведение элементов в современных браузерах в зависимости от значения атрибута `tabindex`:

<table>
  <thead>
    <tr>
      <th>атрибут <code>tabindex</code></th>
      <th>Получает фокус с помощью мыши или   JavaScript через <code>element.focus()</code></th>
      <th>Получает фокус при навигации с клавиатуры клавишей Tab</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>отсутствует</td>
      <td>Работает согласно правилам платформы для конкретного элемента (возможен для элементов управления форм, ссылок и т.п.).</td>
      <td>Работает согласно правилам платформы для конкретного элемента.</td>
    </tr>
    <tr>
      <td>Отрицательный (<code>tabindex="-1"</code>)</td>
      <td>Возможен</td>
      <td>Невозможен. Разработчик должен сделать элемент фокусируемым с помощью  <a href="/ru/docs/Web/API/HTMLElement/focus"><code>focus()</code></a> при нажатии курсорных стрелок и других клавиш клавиатуры.</td>
    </tr>
    <tr>
      <td>Ноль (<code>tabindex="0"</code>)</td>
      <td>Возможен</td>
      <td>Происходит поочерёдно, исходя из позиции элемента внутри документа (обратите внимание, что интерактивные элементы, например ссылки {{HTMLElement('a')}} имеют такое поведение по умолчанию, им не нужен атрибут).</td>
    </tr>
    <tr>
      <td>Положительный (<code>tabindex="33"</code>)</td>
      <td>Возможен</td>
      <td>Значение атрибута <code>tabindex</code> указывает очерёдность, в которой элемент получит фокус: Чем меньше значение атрибута, тем раньше элемент получит фокус (например, <code>tabindex="7"</code> получит фокус раньше <code>tabindex="11"</code>).</td>
    </tr>
  </tbody>
</table>

### Неродные (пользовательские) контролы

Родные интерактивные элементы HTML, такие как {{ HTMLElement("a") }}, {{ HTMLElement("input") }} и {{ HTMLElement("select") }}, уже доступны с клавиатуры, поэтому использование одного из них — самый быстрый способ заставить компоненты работать с клавиатурой.

Разработчики также могут сделать {{ HTMLElement("div") }} или {{ HTMLElement("span") }} доступными с клавиатуры, добавив `tabindex` равный `0`. Это особенно полезно для компонентов, использующих интерактивные элементы, которые не существуют в HTML.

Ниже представлен пример эмулирования чекбоксов. Вместо элементов input в примере используется {{HTMLElement("span")}}.

_Пример 1: Простой виджет, эмулирующий работу чекбоксов путём смены изображений. Виджет использует tabindex, чтобы обеспечить доступ с клавиатуры._

```html
<!-- Без атрибута tabindex, элементы <span> не смогут принимать фокус с клавиатуры -->
<div>
  <span role="checkbox" aria-checked="true" tabindex="0">
    <img src="checked.gif" role="presentation" alt="" />
    Добавить декоративную корзину с фруктами
  </span>
</div>
<div>
  <span role="checkbox" aria-checked="true" tabindex="0">
    <img src="checked.gif" role="presentation" alt="" />
    Добавить поющую телеграмму
  </span>
</div>
<div>
  <span role="checkbox" aria-checked="false" tabindex="0">
    <img src="unchecked.gif" role="presentation" alt="" />
    С предоплатой
  </span>
</div>
```

#### Сгруппированные контролы

Безусловно, есть необходимость создания более сложных виджетов. В качестве примеров можно привести меню, панели вкладок, различные динамические таблицы, представления для информации, имеющей древовидную структуру. Для таких контролов родительский элемент должен иметь атрибут `tabindex="0"`. В таком случае он сможет попасть в фокус с клавиатуры. Все дочерние элементы (пункты меню, отдельные вкладки, ячейки, строки) должны иметь `tabindex="-1"`, чтобы не попадать в фокус при нажатии клавиши tab. Пользователи должны иметь возможность перемещаться по дочерним элементам при помощи клавиш-стрелок на клавиатуре.

Ниже приведён пример, который демонстрирует использование этой техники для реализации вложенного меню. После того, как в фокус попадает основной элемент меню ({{HTMLElement("ul")}}), разработчик должен программно управлять фокусом, реагируя на нажатия клавиш-стрелок. Для описания техники управления фокусом внутри виджета смотрите раздел «Управление фокусом внутри сгруппированного виджета» данной статьи.

_Пример 2: Меню, использующее атрибут `tabindex` для осуществления доступа с клавиатуры._

```html
<ul id="mb1" tabindex="0">
  <li id="mb1_menu1" tabindex="-1">
    Шрифт
    <ul id="fontMenu" title="Шрифт" tabindex="-1">
      <li id="sans-serif" tabindex="-1">Sans-serif</li>
      <li id="serif" tabindex="-1">Serif</li>
      <li id="monospace" tabindex="-1">Monospace</li>
      <li id="fantasy" tabindex="-1">Fantasy</li>
    </ul>
  </li>
  <li id="mb1_menu2" tabindex="-1">
    Стиль
    <ul id="styleMenu" title="Стиль" tabindex="-1">
      <li id="italic" tabindex="-1">Наклонный</li>
      <li id="bold" tabindex="-1">Жирный</li>
      <li id="underline" tabindex="-1">Подчёркнутый</li>
    </ul>
  </li>
  <li id="mb1_menu3" tabindex="-1">
    Выравнивание
    <ul id="justificationMenu" title="Выравнивание" tabindex="-1">
      <li id="left" tabindex="-1">Слева</li>
      <li id="center" tabindex="-1">По центру</li>
      <li id="right" tabindex="-1">Справа</li>
      <li id="justify" tabindex="-1">По ширине</li>
    </ul>
  </li>
</ul>
```

#### Неактивные (disabled) контролы

Когда элемент управления становится неактивным, он не должен  попадать в фокус при нажатии на tab, что обеспечивается выставлением у элемента атрибута `tabindex="-1"`. Обратите внимание, что неактивные элементы в пределах сгруппированного виджета (например подпункты меню ) должны оставаться доступными для навигации с помощью клавиш-стрелок на клавиатуре.

### Управление фокусом внутри сгруппированного виджета

Когда пользователь уходит с виджета, а потом возвращается обратно, фокус должен вернутся на определённый элемент, у которого был фокус раньше. Например, на конкретный элемент дерева или ячейку. Есть два варианта, которыми этого можно добиться:

1. Переходящий `tabindex`: программное перемещение фокуса
2. Свойство `aria-activedescendant`: управление «виртуальным» фокусом

#### Техника первая: Переходящий tabindex

Идея данной техники заключается в выставлении атрибута `tabindex` в нулевое значение для элемента, который последним находился в фокусе. При этом если пользователь уйдёт табом с виджета, а потом вернётся обратно, элемент восстановит фокус правильно. Заметьте, что выставляя `tabindex="0"`, необходимо выставлять `tabindex="-1"` для предыдущего выделенного элемента. Эта техника требует выставлять фокус элементам программно, реагируя на нажатие клавиш.

Для этого необходимо обрабатывать событие keydown для каждого дочернего элемента виджета. Когда пользователь нажимает клавиши-стрелки на клавиатуре, чтобы переместиться на другой элемент следует:

1. программно применить фокус к другому элементу
2. изменить tabindex элемента в фокусе на 0
3. изменить tabindex предыдущего элемента на -1

По ссылке вы можете увидеть пример [WAI-ARIA tree view](https://files.paciellogroup.com/training/WWW2012/samples/Samples/aria/tree/index.html), использующий эту технику.

#### Техника вторая: aria-activedescendant

Эта техника позволяет объединить каждый отдельно взятый обработчик событий в контейнер элемента и использовать `aria-activedescendent` для слежения за «виртуальным» фокусом . (Для получения более подробной информации относительно ARIA обратите внимание на [обзор доступных веб-приложений и виджетов](/ru/docs/Web/Accessibility/An_overview_of_accessible_web_applications_and_widgets).)

Свойство `aria-activedescendant` определяет идентификатор дочернего элемента, который в данный момент находится в фокусе. Обработчик событий в контейнере должен реагировать на  нажатия клавиши и мыши, обновляя значение `aria-activedescendant` и обеспечивая соответствующий стиль текущего элемента (например, цвет рамки или фона).

## Общие рекомендации

### Использование событий фокусировки

- Не отправляйте событие [`focus`](/ru/docs/Web/API/Element/focus_event) для отправки фокуса элементу. События фокусировки DOM считаются только информационными: они генерируются системой после того, как элемент оказался в фокусе, но на самом деле не используются для установки фокуса. Вместо этого используйте `element.focus()`.
- Следите за событиями [`focus`](/ru/docs/Web/API/Element/focus_event) и [`blur`](/ru/docs/Web/API/Element/blur_event), чтобы отслеживать изменения фокуса. Не думайте, что все изменения фокуса будут происходить с помощью нажатий клавиш и мыши: вспомогательные технологии, например скринридеры, могут настроить фокусировку на любом элементе, который можно сфокусировать. Если вы хотите отслеживать статус фокусировки для всего документа, вы можете использовать [`document.activeElement`](/ru/docs/Web/API/Document/activeElement), чтобы получить активный элемент, или [`document.hasFocus`](/ru/docs/Web/API/Document/hasFocus), чтобы убедиться, что текущий документ имеет фокус.

### Убедитесь, что клавиатура и мышь работают одинаково эффективно.

Чтобы взаимодействие с пользователем было согласованным независимо от устройства ввода, обработчики событий клавиатуры и мыши должны совместно использовать код, где это уместно. Например, код, который обновляет `tabindex` или стиль, когда пользователи перемещаются с помощью клавиш-стрелок, также должен использоваться обработчиками щелчков мыши для внесения тех же изменений.

### Убедитесь, что для активации элемента можно использовать клавиатуру

Чтобы гарантировать, что для активации элементов можно использовать клавиатуру, все обработчики, привязанные к событиям мыши, также должны быть привязаны к событиям клавиатуры. Например, чтобы гарантировать, что клавиша Enter активирует элемент, если у вас есть `onclick="doSomething()"`, вы также должны привязать `doSomething()` к событию нажатия клавиши: `onkeydown="event.code === "Enter" && doSomething();"`.

### Всегда устанавливайте фокус для элементов с атрибутом tabindex="-1", которые получают фокусировку программно

Убедитесь, что элементы в фокусе имеют кольцо фокусировки. Это можно сделать с помощью свойства CSS {{cssxref("outline")}}, которое не должно быть безоговорочно установлено в значение `none` — если вы хотите предотвратить отображение ненужных колец фокусировки, используйте псевдокласс {{cssxref(":focus-visible")}}.

### Предотвратите выполнение функций браузера при использовании событий нажатия клавиш

Если ваш виджет обрабатывает  нажатие клавиши, не позволяйте браузеру также обрабатывать его (например, прокручивать экран в ответ на нажатие клавиш-стрелок), используя код возврата обработчика события. Если обработчик события возвращает значение `false`, событие не будет распространено за пределы обработчика.

Например:

```html
<span tabindex="-1">…</span>
```

```js
span.onkeydown = handleKeyDown;
```

Если `handleKeyDown()` возвращает `false`, событие будет обработано, что не позволит браузеру выполнить какие-либо действия, основанные на нажатии клавиши.

### На данный момент не полагайтесь на согласованное поведение при повторении клавиш

К сожалению, `onkeydown` может повторяться, а может и не повторяться в зависимости от того, в каком браузере и операционной системе вы работаете.

