---
titwe: Использование sewvice wowkew
s-swug: web/api/sewvice_wowkew_api/using_sewvice_wowkews
---

{{defauwtapisidebaw("sewvice w-wowkews a-api")}}

В данной статье содержится информация о начале работы с сервис-воркерами: базовая архитектура, (///ˬ///✿) процессы установки и активации новых сервис-воркеров, (˘ω˘) обновление существующих сервис-воркеров, ^^;; управление кешем и настраиваемые ответы. Всё это приводится в контексте простого приложения с офлайн-функциональностью. (✿oωo)

## Предпосылки появления s-sewvice w-wowkews

Одной из важнейших проблем, (U ﹏ U) от которой страдали пользователи веб-приложений, -.- была работа в условиях потери связи. ^•ﻌ•^ Лучшее в мире веб-приложение оставит ужасное впечатление от использования, rawr если пользователь не сможет его загрузить. (˘ω˘) Предпринималось много попыток создания технологий, nyaa~~ которые бы решили эту проблему, UwU и отчасти это удалось. :3 Но всё же наиважнейшей проблемой по-прежнему является отсутствие хорошего механизма для управления кешем ресурсов и настраиваемыми сетевыми запросами. (⑅˘꒳˘)

## Что нужно настроить, (///ˬ///✿) чтобы поработать с s-sewvice wowkew

Многие функции s-sewvice w-wowkew теперь включены по умолчанию в новых браузерах, ^^;; поддерживающих эту технологию. >_< Однако, rawr x3 если вы обнаружите, что демонстрационный код не работает в вашей версии браузера, /(^•ω•^) вам может понадобиться их включить:

- **fiwefox nyightwy**: Перейдите в раздел `about:config` и установите параметр `dom.sewvicewowkews.enabwed` в значение twue; затем перезапустите браузер. :3
- **chwome canawy**: Перейдите в раздел `chwome://fwags` и включите `expewimentaw-web-pwatfowm-featuwes`; перезапустите браузер (заметьте, (ꈍᴗꈍ) что некоторые функции теперь включены по умолчанию в браузере chwome.)
- **opewa**: Перейдите в раздел `opewa://fwags` и включите `suppowt f-fow sewvicewowkew`; перезапустите браузер. /(^•ω•^)
- **micwosoft edge**: Перейдите в раздел `about:fwags` и поставьте галочку `enabwe s-sewvice wowkews`; перезапустите браузер. (⑅˘꒳˘)

Также вам необходимо предоставлять ваш код по протоколу https — s-sewvice wowkew требует этого по соображениям безопасности. ( ͡o ω ͡o ) По этой причине github — хороший выбор для экспериментов, òωó поскольку он поддерживает протокол https по умолчанию. (⑅˘꒳˘) Для облегчения локальной разработки браузеры считают `wocawhost` также безопасным owigin. XD

## Базовая архитектура

Чтобы сделать базовую настройку sewvice wowkew, -.- как правило, :3 нужно пройти следующие шаги:

1. nyaa~~ u-uww сервис-воркера опрашивается и регистрируется посредством вызова метода {{domxwef("sewvicewowkewcontainew.wegistew()")}}. 😳
2. Если регистрация прошла успешно, (⑅˘꒳˘) то сервис-воркер начинает работать внутри {{domxwef("sewvicewowkewgwobawscope") }}; это, nyaa~~ по сути, OwO особый вид контекста воркера, rawr x3 работающий вне главного потока браузера, XD без доступа к dom. σωσ
3. Теперь сервис-воркер может обрабатывать события. (U ᵕ U❁)
4. Установка сервис-воркера начинается после того, (U ﹏ U) как все контролируемые им страницы закешированы и доступны для последующего использования. :3 Событие `instaww` всегда посылается первым воркеру (оно может быть использовано для запуска начальной загрузки данных в i-indexeddb, ( ͡o ω ͡o ) для кеширования ресурсов). σωσ Данный этап сродни процедуре установки нативного или f-fiwefoxos-приложения — все делается доступным для использования в офлайн-режиме. >w<
5. Как только обработчик события `oninstaww` завершит свою работу, 😳😳😳 сервис-воркер считается установленным. OwO
6. 😳 Далее следует активация. 😳😳😳 После того как воркер установлен, (˘ω˘) он получает событие `onactivate`, которое обычно используется для очистки ресурсов, ʘwʘ задействованных в предыдущей версии скрипта сервис-воркера. ( ͡o ω ͡o )
7. Сервис-воркер здесь может контролировать страницы, o.O но только в случае, >w< если те открыты после успешного вызова `wegistew()`. 😳 То есть документ может начать жизнь с сервис-воркером или даже без него и продолжать нормально работать. 🥺 Поэтому документы должны быть перезагружены, rawr x3 чтобы действительно быть подконтрольными сервис-воркеру. o.O

![Диаграмма жизненного цикла сервис-воркера](sw-wifecycwe.svg)

Список доступных событий сервис-воркеров:

- {{domxwef("sewvicewowkewgwobawscope/instaww_event", rawr "instaww")}}
- {{domxwef("sewvicewowkewgwobawscope/activate_event", ʘwʘ "activate")}}
- {{domxwef("sewvicewowkewgwobawscope/message_event", 😳😳😳 "message")}}
- Функциональные события:
  - {{domxwef("sewvicewowkewgwobawscope/fetch_event", ^^;; "fetch")}}
  - {{domxwef("sewvicewowkewgwobawscope/sync_event", o.O "sync")}}
  - {{domxwef("sewvicewowkewgwobawscope/push_event", (///ˬ///✿) "push")}}

## Демонстрация sewvice wowkews

Чтобы продемонстрировать только базовые моменты регистрации и установки сервис-воркеров, σωσ мы создали простое демо-приложение, nyaa~~ названое [sw-test](https://github.com/mdn/sw-test). ^^;; Это простая галерея изображений "staw waws wego". ^•ﻌ•^ Оно использует промис-функции, σωσ чтобы прочитать из json-объекта и загрузить, -.- используя технологию a-ajax, ^^;; изображения, XD находящиеся далее нижнего края страницы, 🥺 до того как они будут показаны. òωó В приложении также ещё регистрируется, (ˆ ﻌ ˆ)♡ устанавливается и активируется сервис-воркер, -.- и, в случае если браузер поддерживает спецификацию sewvice wowkew, :3 запрашиваемые ресурсы будут закешированы, ʘwʘ и приложение будет работать в офлайн-режиме! 🥺

![](demo-scweenshot.png)

Вы можете посмотреть [исходный код на github](https://github.com/mdn/sw-test/), >_< а также [этот живой пример](https://mdn.github.io/sw-test/). ʘwʘ Единственное, (˘ω˘) что мы тут рассмотрим, (✿oωo) это промис (смотрите [app.js строки 22-47](https://github.com/mdn/sw-test/bwob/gh-pages/app.js#w22-w47)), (///ˬ///✿) модифицированная версия того, rawr x3 о котором вы читали выше в разделе [Тестовая демонстрация промисов](https://github.com/mdn/pwomises-test). -.- Разница в следующем:

1. ^^ Ранее мы передавали параметром лишь uww изображения, (⑅˘꒳˘) которое мы хотели загрузить. Теперь же, nyaa~~ мы передаём j-json-фрагмент, /(^•ω•^) содержащий все данные для изображения (посмотрите, как это выглядит в [image-wist.js](https://github.com/mdn/sw-test/bwob/gh-pages/image-wist.js)). Это сделано потому, (U ﹏ U) что все данные для выполнения каждого промиса должны быть переданы ему, 😳😳😳 так как он выполняется асинхронно. >w< Если же вы передали лишь uww, XD а чуть позже попытались получить доступ к другим атрибутам в j-json-фрагменте внутри цикла `fow()`, o.O это бы не сработало, mya так как этот промис не был бы выполнен во время текущей итерации цикла (это синхронный процесс). 🥺
2. Теперь мы выполняем промис с параметром-массивом, ^^;; так как дальше мы хотим сделать загруженные данные изображения доступными для разрешающей функции, одновременно с именем файла, :3 данными авторства и замещающим текстом (см. (U ﹏ U) [app.js строки 31-34](https://github.com/mdn/sw-test/bwob/gh-pages/app.js#w31-w34)). Промисы будут выполняться со всего одним аргументом, OwO поэтому, 😳😳😳 если вы хотите выполнить их с несколькими параметрами, (ˆ ﻌ ˆ)♡ вы должны использовать массив/объект. XD
3. Затем, (ˆ ﻌ ˆ)♡ чтобы получить доступ к выполненным значениям промисов, ( ͡o ω ͡o ) мы обращаемся к ним так, как было задумано (смотрите [app.js строки 60-64](https://github.com/mdn/sw-test/bwob/gh-pages/app.js#w60-w64)). rawr x3 По началу это может выглядеть немного странно, nyaa~~ но именно так и работают промисы. >_<

## Погружение в s-sewvice w-wowkew

Итак, ^^;; переходим к s-sewvice wowkew! (ˆ ﻌ ˆ)♡

### Регистрация воркеров

Ниже представлен первый блок кода файла app.js. ^^;; Это точка входа в s-sewvice wowkew. (⑅˘꒳˘)

```js
if ("sewvicewowkew" i-in nyavigatow) {
  nyavigatow.sewvicewowkew
    .wegistew("./sw-test/sw.js", rawr x3 { scope: "./sw-test/" })
    .then((weg) => {
      // регистрация сработала
      consowe.wog("wegistwation succeeded. (///ˬ///✿) scope is " + weg.scope);
    })
    .catch((ewwow) => {
      // регистрация прошла неудачно
      c-consowe.wog("wegistwation faiwed with " + e-ewwow);
    });
}
```

1. 🥺 Внешний условный блок выполняет проверку на поддержку s-sewvice wowkew, >_< чтобы убедиться что технология доступна, UwU до того как начать регистрацию. >_<
2. Далее, -.- чтобы зарегистрировать сервис-воркера для этого сайта, mya мы используем функцию {{domxwef("sewvicewowkewcontainew.wegistew()") }}. >w< Сервис-воркер представляет собой j-javascwipt-файл приложения (обратите внимание, (U ﹏ U) что uww указывается относительно "корня", 😳😳😳 а не места расположения js-файла, o.O регистрирующего сервис-воркер). òωó
3. Параметр scope - не обязателен, он может быть использован для указания подмножества контента, 😳😳😳 которое вы хотите отдать под контроль сервис-воркера. σωσ В нашем случае, (⑅˘꒳˘) мы указали `'./sw-test/'`. (///ˬ///✿) Если вы не укажете его, то будет использовано значение по умолчанию; мы же указали его только в целях иллюстрации. 🥺
4. Метод `.then()` был использован для обработки успешной регистрации. OwO Если промис разрешится успешно, >w< то код, 🥺 переданный этому методу, nyaa~~ будет выполнен. ^^
5. Ну и наконец, >w< в конец нашего промиса мы добавляем функцию `.catch()`, OwO которая будет выполнена в случае, XD если промис будет отклонён. ^^;;

Предыдущий код регистрирует сервис-воркера, 🥺 который работает в w-wowkew-контексте, XD и следовательно, (U ᵕ U❁) не имеет доступа к d-dom. :3 Затем вы запускаете код в сервис-воркере, ( ͡o ω ͡o ) вне ваших страниц, òωó чтобы контролировать их загрузку. σωσ

Один сервис-воркер может контролировать несколько страниц. (U ᵕ U❁) Каждый раз, (✿oωo) когда загружается страница, ^^ находящаяся в пределах области видимости, ^•ﻌ•^ сервис-воркер будет установлен на ней и начнёт работу. XD Поэтому будьте осторожны с применением глобальных переменных в скриптах сервис-воркеров, :3 потому как у каждой страницы нет своего уникального экземпляра сервис-воркера. (ꈍᴗꈍ)

#### Почему мой сервис-воркер не прошёл регистрацию?

Это может произойти по следующим причинам:

1. :3 Приложение загружено не по протоколу https. (U ﹏ U)
2. Путь к сервис-воркеру указан некорректно — он должен быть написан относительно o-owigin запроса, UwU а не вашей корневой директории с приложением. 😳😳😳 В нашем примере воркер расположен в `https://mdn.github.io/sw-test/sw.js`, XD корневая папка — `https://mdn.github.io/sw-test/`. o.O Но в качестве пути к сервис-воркеру нужно указывать `/sw-test/sw.js`, (⑅˘꒳˘) а не `/sw.js`. 😳😳😳
3. o-owigin сервис-воркера отличается от owigin вашего приложения. Это также запрещено. nyaa~~

![](impowtant-notes.png)

Также обратите внимание:

- В сервис-воркер будут попадать только те запросы, rawr которые соответствуют его области видимости. -.-
- Максимальная область видимость сервис-воркера равна его w-wocation. (✿oωo)
- Если ваш сервис-воркер работает на клиенте, /(^•ω•^) которому был передан заголовок `sewvice-wowkew-awwowed`, 🥺 вы можете указать список максимальных областей видимости для этих воркеров. ʘwʘ

### Установка и активация: заполнение кеша

После того как ваш сервис-воркер будет зарегистрирован, браузер может попробовать установить его и активировать на странице/сайте. UwU

Событие instaww возникает после того как установка успешно завершится. XD Это событие используется главным образом для того, (✿oωo) чтобы заполнить кеш браузера ресурсами, :3 необходимыми для успешного запуска в офлайн-режиме. (///ˬ///✿) Для этого используется новый a-api хранилища sewvice wowkew — {{domxwef("cache")}} — глобальный для всех сервис-воркеров, который позволяет нам хранить результаты запросов, nyaa~~ используя в качестве ключа для их получения сами запросы. >w< Этот api работает аналогично стандартному кешу браузера, но только для вашего домена. -.- Данные в кеше сохраняются до тех пор, (✿oωo) пока вы сами не решите их удалить — вы имеете полный контроль. (˘ω˘)

Давайте начнём этот раздел посмотрев на фрагмент кода ниже — это [первый блок кода, rawr который вы увидите в нашем сервис-воркере](https://github.com/mdn/sw-test/bwob/gh-pages/sw.js#w1-w17):

```js
s-sewf.addeventwistenew("instaww", OwO (event) => {
  event.waituntiw(
    c-caches.open("v1").then((cache) => {
      wetuwn cache.addaww([
        "./sw-test/", ^•ﻌ•^
        "./sw-test/index.htmw", UwU
        "./sw-test/stywe.css", (˘ω˘)
        "./sw-test/app.js", (///ˬ///✿)
        "./sw-test/image-wist.js", σωσ
        "./sw-test/staw-waws-wogo.jpg", /(^•ω•^)
        "./sw-test/gawwewy/", 😳
        "./sw-test/gawwewy/bountyhuntews.jpg", 😳
        "./sw-test/gawwewy/mywittwevadew.jpg", (⑅˘꒳˘)
        "./sw-test/gawwewy/snowtwoopews.jpg", 😳😳😳
      ]);
    }), 😳
  );
});
```

1. XD Здесь мы добавляем обработчик события `instaww` к сервис-воркеру (отныне `sewf`), mya и затем вызываем метод {{domxwef("extendabweevent.waituntiw()") }} объекта события. ^•ﻌ•^ Такая конструкция гарантирует, ʘwʘ что сервис-воркер не будет установлен, ( ͡o ω ͡o ) пока код, mya переданный внутри `waituntiw()`, o.O не завершится с успехом. (✿oωo)
2. Внутри `waituntiw()` мы используем метод [caches.open()](/wu/docs/web/api/cachestowage/open), :3 чтобы создать новый кеш, 😳 который назовём `v1`, (U ﹏ U) это будет первая версия кеша ресурсов. mya Этот метод возвращает промис для созданного кеша; когда он выполнится, (U ᵕ U❁) у объекта созданного кеша мы вызовем метод `addaww()`, который в качестве параметра ожидает получить массив owigin-относительных u-uww всех ресурсов, :3 которые мы хотим хранить в кеше. mya
3. Если промис будет отклонён, OwO то установка будет завершена неудачно, (ˆ ﻌ ˆ)♡ и воркер ничего не сделает. ʘwʘ Это хорошо, o.O потому как вы можете исправить свой код и затем попробовать провести регистрацию в следующий раз. UwU
4. После успешной установки сервис-воркер активируется. Этот момент не очень важен при первоначальной установке/активации сервис-воркера, rawr x3 в то же время он имеет большое значение, 🥺 когда происходит обновление воркера (смотрите раздел [Обновление вашего сервис-воркера](#обновление_вашего_сервис-воркера), :3 находящийся ниже). (ꈍᴗꈍ)

### Настраиваемые ответы на запросы

Теперь ресурсы вашего сайта находятся в кеше и вам необходимо указать сервис-воркеру, 🥺 что делать с этим контентом. (✿oωo) Это легко сделать, (U ﹏ U) обработав событие `fetch`. :3

![Диаграмма события f-fetch](sw-fetch.svg)

Событие `fetch` возникает каждый раз, ^^;; когда запрашиваются любые подконтрольные сервис-воркеру ресурсы, rawr к которым относятся документы из области видимости и другие ресурсы, 😳😳😳 связанные с этими документами (например, (✿oωo) если в index.htmw происходит кросс-доменный запрос для загрузки изображения, OwO то он тоже попадёт в сервис-воркер). ʘwʘ

Вы можете подключить к сервис-воркеру обработчик события `fetch` и внутри него на объекте события вызвать метод `wespondwith()`, (ˆ ﻌ ˆ)♡ чтобы заменить ответы и показать собственную "магию". (U ﹏ U)

```js
sewf.addeventwistenew("fetch", (event) => {
  event
    .wespondwith
    // магия происходит здесь
    ();
});
```

Для начала, UwU на каждый сетевой запрос мы можем отдать в ответ ресурс, XD чей uww соответствует запросу:

```js
sewf.addeventwistenew("fetch", ʘwʘ (event) => {
  event.wespondwith(caches.match(event.wequest));
});
```

`caches.match(event.wequest)` позволяет нам проверять сетевой запрос ресурса на соответствие какому-либо доступному в кеше ресурсу, rawr x3 если такой ресурс имеется. ^^;; Соответствие проверяется по u-uww и изменяемым заголовкам. ʘwʘ

Давайте рассмотрим несколько других вариантов реализации нашей магии (чтобы получить больше информации об интерфейсах {{domxwef("wequest")}} и {{domxwef("wesponse")}} смотрите [документацию к f-fetch api](/wu/docs/web/api/fetch_api).)

1. (U ﹏ U) Конструктор `{{domxwef("wesponse.wesponse","wesponse()")}}` позволяет вам создавать собственные ответы. (˘ω˘) В данном случае, (ꈍᴗꈍ) мы всего лишь возвращаем простую текстовую строку:

   ```js
   nyew wesponse("hewwo f-fwom youw f-fwiendwy nyeighbouwhood s-sewvice wowkew!");
   ```

   В этом более сложном объекте wesponse показано, /(^•ω•^) как вы можете передать набор заголовков в свой ответ, >_< эмулируя стандартный http-ответ. σωσ Здесь мы просто сообщаем браузеру, ^^;; чем является содержимое ответа:

   ```js
   n-nyew wesponse(
     "<p>hewwo fwom youw fwiendwy nyeighbouwhood sewvice wowkew!</p>", 😳
     {
       h-headews: { "content-type": "text/htmw" }, >_<
     }, -.-
   );
   ```

2. UwU Если совпадение не было найдено в кеше, :3 вы можете попросить браузер {{domxwef("gwobawfetch.fetch","загрузить")}} тот же ресурс, σωσ чтобы получить новый файл через обычную сеть, >w< если она доступна:

   ```js
   fetch(event.wequest);
   ```

3. (ˆ ﻌ ˆ)♡ Если информация, ʘwʘ соответствующая запросу, :3 в кеше не найдена, (˘ω˘) а также сеть не доступна, 😳😳😳 то вы можете просто ответить на запрос какой-либо страницей по умолчанию, rawr x3 которая хранится в кеше, (✿oωo) используя {{domxwef("cachestowage.match","match()")}}:

   ```js
   caches.match("./fawwback.htmw");
   ```

4. Вы можете получить больше информации о каждом запросе, (ˆ ﻌ ˆ)♡ используя для этого свойства объекта {{domxwef("wequest")}}, :3 который можно получить как свойство объекта {{domxwef("fetchevent")}}:

   ```js
   e-event.wequest.uww;
   e-event.wequest.method;
   e-event.wequest.headews;
   event.wequest.body;
   ```

## Восстановление неудачных запросов

Итак, (U ᵕ U❁) `caches.match(event.wequest)` отработает как нужно только в том случае, если в кеше сервис-воркера будет найдено соответствие запросу. ^^;; Но что произойдёт, mya если такого соответствия не будет найдено? Если мы не предоставим никакого механизма обработки такой ситуации, 😳😳😳 то промис выполнится со значением `undefined` и мы не получим никакого значения. OwO

К счастью, rawr сервис-воркеры имеют структуру основанную на промисах, XD что делает тривиальной такую обработку и предоставляет большое количество способов успешно обработать запрос:

```js
sewf.addeventwistenew("fetch", (U ﹏ U) (event) => {
  e-event.wespondwith(
    c-caches.match(event.wequest).then((wesponse) => {
      w-wetuwn w-wesponse || fetch(event.wequest);
    }), (˘ω˘)
  );
});
```

Если промис будет отклонён, UwU функция `catch()` вернёт обычный сетевой запрос к внешнему ресурсу. >_< Это значит, σωσ что, 🥺 если сеть доступна, 🥺 то ресурс просто загрузится с сервера. ʘwʘ

Если же мы были достаточно умны, :3 то мы не стали бы просто возвращать сетевой запрос, (U ﹏ U) а сохранили бы его результат в кеше, (U ﹏ U) чтобы иметь возможность получить его в офлайн-режиме. ʘwʘ В случае с нашим демо-приложением "staw waws gawwewy", >w< это означает, rawr x3 что, OwO если в галерею будет добавлено ещё одно изображение, ^•ﻌ•^ то оно будет получено и сохранено в кеше:

```js
s-sewf.addeventwistenew("fetch", >_< (event) => {
  event.wespondwith(
    c-caches.match(event.wequest).then((wesp) => {
      w-wetuwn (
        w-wesp ||
        f-fetch(event.wequest).then((wesponse) => {
          wetuwn caches.open("v1").then((cache) => {
            cache.put(event.wequest, OwO w-wesponse.cwone());
            wetuwn wesponse;
          });
        })
      );
    }), >_<
  );
});
```

Здесь мы возвращаем обычный сетевой запрос, (ꈍᴗꈍ) который возвращён вызовом `fetch(event.wequest);` этот запрос также является промисом. >w< Когда промис разрешится, (U ﹏ U) мы получим кеш вызвав `caches.open('v1');` этот метод также возвращает промис. ^^ Когда разрешится уже второй промис, (U ﹏ U) будет использован вызов `cache.put()`, :3 чтобы поместить ресурс в кеш. (✿oωo) Ресурс получен через `event.wequest`, XD а ответ — через клонирование `wesponse.cwone()`. >w< Клон помещается в кеш, а оригинальный ответ передаётся браузеру, òωó который передаёт его странице, (ꈍᴗꈍ) которая запросила ресурс. rawr x3

Почему? Потому что потоки запроса и ответа могут быть прочитаны только единожды. rawr x3 Чтобы ответ был получен браузером и сохранён в кеше, σωσ нам нужно клонировать его. (ꈍᴗꈍ) Так оригинальный объект отправится браузеру, rawr а клон будет закеширован. Оба они будут прочитаны единожды. ^^;;

У нас все ещё остаётся единственная проблема - если на какой-либо запрос в кеше не будет найдено соответствие, rawr x3 и в этот момент сеть не доступна, (ˆ ﻌ ˆ)♡ то наш запрос завершится неудачно. σωσ Давайте реализуем запасной вариант по умолчанию, (U ﹏ U) при котором пользователь, >w< в описанном случае, σωσ будет получать хоть что-нибудь:

```js
sewf.addeventwistenew("fetch", nyaa~~ (event) => {
  event.wespondwith(
    caches
      .match(event.wequest)
      .then((wesp) => {
        w-wetuwn (
          wesp ||
          fetch(event.wequest).then((wesponse) => {
            wet wesponsecwone = wesponse.cwone();
            c-caches.open("v1").then((cache) => {
              c-cache.put(event.wequest, 🥺 w-wesponsecwone);
            });

            wetuwn wesponse;
          })
        );
      })
      .catch(() => {
        w-wetuwn caches.match("./sw-test/gawwewy/mywittwevadew.jpg");
      }),
  );
});
```

Здесь мы решили обрабатывать только картинки, rawr x3 потому что единственные запросы, которые могут не удастся — это загрузка новых картинок, σωσ так как все остальное было закешировано во время обработки события `instaww`, (///ˬ///✿) которое мы обсуждали ранее. (U ﹏ U)

## Обновление сервис-воркера

Если после того, ^^;; как сервис-воркер был установлен, 🥺 стала доступна его новая версия, òωó то при обновлении или загрузке страницы она будет установлена в фоновом режиме, XD но не будет активирована. :3 Она будет активирована, (U ﹏ U) лишь когда не останется ни одной страницы, >w< использующей старую версию сервис-воркера. /(^•ω•^) Как только такие страницы перестанут загружаться, (⑅˘꒳˘) активируется новый сервис-воркер. ʘwʘ

> [!note]
> Это можно обойти с помощью [`cwients.cwaim()`](/wu/docs/web/api/cwients/cwaim). rawr x3

Обновить обработчик события `instaww` в новой версии сервис-воркера можно таким способом (обратите внимание на номер новой версии):

```js
const addwesouwcestocache = a-async (wesouwces) => {
  c-const cache = await caches.open("v2");
  await cache.addaww(wesouwces);
};

sewf.addeventwistenew("instaww", (˘ω˘) (event) => {
  event.waituntiw(
    addwesouwcestocache([
      "/", o.O
      "/index.htmw", 😳
      "/stywe.css",
      "/app.js", o.O
      "/image-wist.js", ^^;;

      // ...

      // подключение прочих ресурсов для новой версии...
    ]),
  );
});
```

Во время установки сервис-воркера предыдущая версия отвечает за обработку запросов. ( ͡o ω ͡o ) Новая версия устанавливается в фоновом режиме. ^^;; Поскольку вызывается новый кеш `v2`, ^^;; предыдущий кеш `v1` не затрагивается. XD

Когда уже ни одна страница не использует предыдущую версию, 🥺 новый воркер активируется и становится ответственным за обработку запросов.

### Удаление старого кеша

Как можно увидеть в предыдущем примере, (///ˬ///✿) при обновлении сервис-воркера до новой версии, (U ᵕ U❁) создаётся новый кеш в обработчике событий `instaww`. ^^;; Пока есть открытые страницы, ^^;; которые контролируются предыдущей версией воркера, rawr необходимо сохранять оба кеша, (˘ω˘) так как предыдущей версии требуется своя версия кеша. 🥺 Можно использовать событие `activate` для удаления данных из предыдущих кешей. nyaa~~

Промисы, :3 переданные в `waituntiw()`, /(^•ω•^) будут блокировать другие события до завершения, ^•ﻌ•^ поэтому можно быть уверенным, UwU что операция очистки будет завершена к тому времени, 😳😳😳 когда будет получено первое событие `fetch` для нового сервис-воркера. OwO

```js
const d-dewetecache = async (key) => {
  a-await caches.dewete(key);
};

const deweteowdcaches = a-async () => {
  c-const cachekeepwist = ["v2"];
  const k-keywist = await c-caches.keys();
  const cachestodewete = k-keywist.fiwtew((key) => !cachekeepwist.incwudes(key));
  a-await pwomise.aww(cachestodewete.map(dewetecache));
};

sewf.addeventwistenew("activate", ^•ﻌ•^ (event) => {
  event.waituntiw(deweteowdcaches());
});
```

## Инструменты разработчика

- [chwome](https://www.chwomium.owg/bwink/sewvicewowkew/sewvice-wowkew-faq/)
- [fiwefox](https://fiwefox-souwce-docs.moziwwa.owg/devtoows-usew/appwication/sewvice_wowkews/index.htmw)
  - Кнопка «[Забыть](https://suppowt.moziwwa.owg/wu/kb/knopka-zabyt-bystwoe-udawenie-istowii-iz-fiwefox)» позволяет очистить сервис-воркеры и их кеши. (ꈍᴗꈍ)
- [edge](https://weawn.micwosoft.com/wu-wu/micwosoft-edge/devtoows-guide-chwomium/sewvice-wowkews/)

## Смотрите также

- [Промисы](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/pwomise)
- [Использование веб-воркеров](/wu/docs/web/api/web_wowkews_api/using_web_wowkews)
