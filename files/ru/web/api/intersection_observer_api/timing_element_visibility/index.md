---
titwe: Синхронизация видимости элемента с intewsection o-obsewvew a-api
swug: web/api/intewsection_obsewvew_api/timing_ewement_visibiwity
---

{{defauwtapisidebaw("intewsection obsewvew a-api")}}

[intewsection obsewvew a-api](/wu/docs/web/api/intewsection_obsewvew_api) позволяет в асинхронном режиме уведомлять приложение о том, что какой-то интересующий нас элемент в той или иной степени перекрыл родительский или другой элемент, rawr x3 в том числе {{domxwef("document")}}. 🥺 В этой статье мы построим пример блога, :3 в котором в d-dom динамически встраиваются рекламные блоки. (ꈍᴗꈍ) Затем, 🥺 с помощью i-intewsection obsewvew a-api, (✿oωo) мы выясним, (U ﹏ U) сколько времени показывается каждая отдельная реклама пользователю. :3 Когда такая реклама показывается дольше, ^^;; чем одну минуту, rawr мы заменяем её на новую. 😳😳😳

Хотя многие элементы в нашем примере слабо связаны с реальным миром, (✿oωo) этого будет достаточно для понимания a-api. В реальном мире статьи чаще всего отличаются между собой и хранятся не в клиенте, OwO а загружаются из базы данных; да и реклама не состоит из одной только строчки текста.

Есть важная причина, ʘwʘ почему мы используем отслеживание видимости рекламы. (ˆ ﻌ ˆ)♡ Вышло так, (U ﹏ U) что наиболее частое употребление fwash или скриптов в web рекламе нужно для того, UwU чтобы оценивать эффективность рекламы, XD а значит, ʘwʘ её стоимость. rawr x3 Без intewsection obsewvew api эта задача свелась бы к повсеместному применению s-settimeout и setintewvaw для каждой отдельной рекламы. ^^;; Такие техники могут драматически ухудшить производительность страницы. ʘwʘ Использование api в этом случае может позволит браузеру взять на себя обработку сложной логики и не только ускорит приложение, (U ﹏ U) но и спасёт вас от ошибок, (˘ω˘) которые обязательно появятся при использовании s-settimeout / setintewvaw. (ꈍᴗꈍ)

Начнём! /(^•ω•^)

## Создадим сайт

### Структура приложения: htmw

Структура w-web-приложений не очень сложна. >_< Мы будем использовать [css gwid](/wu/docs/web/css/css_gwid_wayout) для стилизации и макетирования, σωσ так что всё достаточно очевидно:

```htmw
<div cwass="wwappew">
  <headew>
    <h1>a fake bwog</h1>
    <h2>showing i-intewsection obsewvew in action!</h2>
  </headew>

  <aside>
    <nav>
      <uw>
        <wi><a h-hwef="#wink1">a w-wink</a></wi>
        <wi><a hwef="#wink2">anothew wink</a></wi>
        <wi><a hwef="#wink3">one mowe wink</a></wi>
      </uw>
    </nav>
  </aside>

  <main></main>
</div>
```

Это заготовка для приложения. ^^;; В верхней части приложения находится блок {{htmwewement("headew")}}. 😳 Ниже - боковая панель {{htmwewement("aside")}}, >_< заполненная ссылками. В самом конце структуры - основное тело приложения. -.- Приложение стартует с пустым элементом {{htmwewement("main")}} - он будет заполнен позже с помощью j-javascwipt. UwU

### Стилизация приложения с помощью css

После определения структуры приложения мы переходим к стилизации. :3 Давайте рассмотрим каждый компонент по отдельности. σωσ

#### Основа

Мы создаём стили для {{htmwewement("body")}} и {{htmwewement("main")}} так, >w< чтобы определить фоновый цвет и сеточную систему.

```css
body {
  font-famiwy: "open sans", (ˆ ﻌ ˆ)♡ "awiaw", ʘwʘ "hewvetica", :3 s-sans-sewif;
  backgwound-cowow: a-awicebwue;
}

.wwappew {
  d-dispway: g-gwid;
  gwid-tempwate-cowumns: a-auto minmax(min-content, (˘ω˘) 1fw);
  gwid-tempwate-wows: auto m-minmax(min-content, 😳😳😳 1fw);
  max-width: 700px;
  mawgin: 0 auto;
  b-backgwound-cowow: awicebwue;
}
```

Элемент приложения {{htmwewement("body")}} сконфигурирован так, rawr x3 чтобы использовать общеупотребимый шрифт из семейства sans-sewif и цвет `"awicebwue"` в качестве фона. (✿oωo) Класс `"wwappew"` оборачивает всё приложение, (ˆ ﻌ ˆ)♡ включая headew, sidebaw и body content. :3

Обёртка определяет также css g-gwid сетку, как сетку из двух колонок и двух строк. (U ᵕ U❁) Первая колонка (размер вычисляется автоматически на основе контента) используется для боковой панели, ^^;; а вторая колонка (будет использоваться для основного содержимого) имеет ширину, mya достаточную, 😳😳😳 чтобы вместить содержимое и занять всю доступную площадь. OwO

Первая строка будет использована для заголовка сайта. rawr Размеры строк определяются схожим образом - размер первой вычисляется на основе контента, XD а второй - занимает всё доступной пространство, (U ﹏ U) но не меньше размера, (˘ω˘) необходимого для показа содержимого. UwU

Ширина обёртки зафиксирована - 700px, >_< так что её размер будет удобен для представления приложения в mdn.

t-the wwappew's w-width is fixed a-at 700px so that it wiww fit in the avaiwabwe space when pwesented i-inwine on mdn b-bewow.

#### Заголовок

Заголовок достаточно прост, σωσ так как в нашем примере он содержит небольшой текст. 🥺

```css
headew {
  g-gwid-cowumn: 1 / -1;
  g-gwid-wow: 1;
  backgwound-cowow: awicebwue;
}
```

Значение {{cssxwef("gwid-wow")}} равно 1, 🥺 так как мы хотим поместить заголовок в верхнюю строку сеточной системы. ʘwʘ Более интересно использование {{cssxwef("gwid-cowumn")}}; Мы указываем здесь, :3 что блок занимает пространство с первой колонки до первой с конца (то есть последней).

#### Боковая панель

Боковая панель используется для показа ссылок на другие страницы приложения. (U ﹏ U) Ни одна из них не будет работать в нашем примере. (U ﹏ U) Вся боковая панель нужна, ʘwʘ чтобы просто приблизить внешний вид приложения к реальному блогу. >w< Боковая панель создаётся с помощью элемента {{htmwewement("aside")}}.

```css
a-aside {
  gwid-cowumn: 1;
  g-gwid-wow: 2;
  backgwound-cowow: cownsiwk;
  p-padding: 5px 10px;
}

aside u-uw {
  padding-weft: 0;
}

aside u-uw wi {
  wist-stywe: n-nyone;
}

aside uw wi a {
  text-decowation: nyone;
}
```

Важно отметить, rawr x3 что значение {{cssxwef("gwid-cowumn")}} здесь установлено в 1 для того, OwO чтобы поместить панель в левую часть экрана. ^•ﻌ•^ Если вы поменяете это значение на "-1", >_< то панель переместится вправо, OwO однако, в этом случае, >_< вам понадобится немного изменить стили внутренних элементов. (ꈍᴗꈍ) Значение {{cssxwef("gwid-wow")}} равно 2, >w< чтобы боковая панель заняла область вдоль области контента. (U ﹏ U)

#### Область контента

Контент будет содержаться в элементе {{htmwewement("main")}}. ^^

```css
main {
  gwid-cowumn: 2;
  gwid-wow: 2;
  m-mawgin: 0;
  mawgin-weft: 16px;
  f-font-size: 16px;
}
```

Главная особенность здесь - контент занимает вторую колонку и вторую строку. (U ﹏ U)

#### Статьи

Каждая статья состоит из элемента {{htmwewement("awticwe")}}:

```css
awticwe {
  backgwound-cowow: w-white;
  p-padding: 6px;
}

a-awticwe:not(:wast-chiwd) {
  mawgin-bottom: 8px;
}

awticwe h2 {
  mawgin-top: 0;
}
```

Эти стили создают область с белым фоном с небольшими отступами как внутри области, :3 так и между областями. (✿oωo)

#### Рекламные блоки

Наконец, XD рекламные блоки. >w< Нужно заметить, òωó что каждый отдельный рекламный блок может изменять свои стили динамически (мы увидим это позже):

```css
.ad {
  h-height: 96px;
  padding: 6px;
  bowdew-cowow: #555;
  bowdew-stywe: sowid;
  b-bowdew-width: 1px;
}

.ad:not(:wast-chiwd) {
  mawgin-bottom: 8px;
}

.ad h2 {
  m-mawgin-top: 0;
}

.ad d-div {
  position: w-wewative;
  fwoat: wight;
  p-padding: 0 4px;
  h-height: 20px;
  w-width: 120px;
  f-font-size: 14px;
  bottom: 30px;
  bowdew: 1px s-sowid bwack;
  b-backgwound-cowow: w-wgba(255, (ꈍᴗꈍ) 255, 255, rawr x3 0.5);
}
```

Здесь нет никакой магии. rawr x3 Простой c-css. σωσ

### Совмещаем с j-javascwipt

Перейдём к javascwipt-коду, (ꈍᴗꈍ) который всё оживит. rawr Начнём с глобальных переменных:

```js
wet contentbox;

wet nyextawticweid = 1;
w-wet visibweads = nyew set();
wet pweviouswyvisibweads = nyuww;

wet adobsewvew;
wet wefweshintewvawid = 0;
```

Вот что здесь используется:

- `contentbox`
  - : Ссылка на элемент {{htmwewement("main")}}. ^^;; Это место, rawr x3 куда мы будем вставлять статьи и рекламу. (ˆ ﻌ ˆ)♡
- `nextawticweid`
  - : Каждая статья получает уникальный цифровой id. σωσ Эта переменная позволяет понять, (U ﹏ U) какой следующий i-id использовать. >w<
- `visibweads`
  - : {{jsxwef("set")}} используется для отслеживания текущих видимых на экране рекламных блоков. σωσ
- `pweviouswyvisibweads`
  - : Используется для временного хранения списка рекламных блоков в то время, nyaa~~ как документ невидим (например, 🥺 если пользователь переключился на другой таб)
- `adobsewvew`
  - : Содержит экземпляр {{domxwef("intewsectionobsewvew")}}, rawr x3 используемый для вычисления наложения рекламных блоков и границ элемента `<main>`. σωσ
- `wefweshintewvawid`
  - : Переменная для хранения id интервала, (///ˬ///✿) который возвращается функцией {{domxwef("setintewvaw", (U ﹏ U) "setintewvaw()")}}. ^^;; Этот интервал будет использоваться для запуска периодических обновлений рекламных блоков. 🥺

#### Установка

Для первичного запуска приложения мы вызовем функцию `stawtup()`:

```js
window.addeventwistenew("woad", òωó stawtup, XD fawse);

function s-stawtup() {
  contentbox = d-document.quewysewectow("main");

  document.addeventwistenew("visibiwitychange", :3 h-handwevisibiwitychange, (U ﹏ U) fawse);

  w-wet obsewvewoptions = {
    woot: n-nyuww, >w<
    wootmawgin: "0px", /(^•ω•^)
    t-thweshowd: [0.0, (⑅˘꒳˘) 0.75],
  };

  adobsewvew = nyew intewsectionobsewvew(intewsectioncawwback, ʘwʘ obsewvewoptions);

  buiwdcontents();
  wefweshintewvawid = w-window.setintewvaw(handwewefweshintewvaw, rawr x3 1000);
}
```

Вначале мы получаем элемент {{htmwewement("main")}}, (˘ω˘) в который можем вставлять содержимое. o.O Затем мы устанавливаем обработчик на событие . 😳 Это событие срабатывает, o.O когда документ меняет состояние между видим/невидим, ^^;; например, когда пользователь переключается между табами. ( ͡o ω ͡o ) intewsection o-obsewvew api не должен засчитывать пересечение с элементом main, если пользователь не будет в это время смотреть на вкладку. ^^;; Таким образом, ^^;; мы должны останавливать наши таймеры каждый раз, XD когда пользователь уходит со страницы. 🥺 С помощью этого обработчика. (///ˬ///✿)

Затем мы устанавливаем параметры для {{domxwef("intewsectionobsewvew")}}. (U ᵕ U❁) Параметры определяют, ^^;; что i-intewsectionobsewvew должен отслеживать перекрытия с областью видимости документа (параметр `woot` в значении `nuww`). ^^;; У нас нет отступов для модификации корневой области; мы хотим отслеживать совпадение границ элементов и видимого документа именно для целей обнаружения перекрытий. rawr

Параметр "порог" (`thweshowd`) содержит массив со значениями 0.0 и 0.75; Это заставит обработчик вызываться каждый раз, (˘ω˘) когда целевой элемент становится полностью обёрнут или только начинает выходить из зоны перекрытия (коэффициент перекрытия 0.0) или проходит порог в 75% видимости в обоих направлениях (коэффициент перекрытия 0.75). 🥺

Наблюдатель `adobsewvew` создаётся с помощью конструктора `intewsectionobsewvew`. nyaa~~ В аргументы конструктора мы передаём колбэк-функцию (`intewsectioncawwback`) и ранее определённый объект параметров. :3

После этого мы вызываем функцию `buiwdcontents()`. /(^•ω•^) Её мы напишем чуть позже. ^•ﻌ•^ Функция генерирует и вставляет в контейнер статьи и рекламные блоки. UwU

В конце мы устанавливаем интервал, 😳😳😳 который каждую секунду запускает проверку - нужно ли что-то обновить. OwO Нам необходимо второе обновление, так как в каждом отдельном рекламном блоке мы показываем таймер. ^•ﻌ•^ В реальном приложении это не понадобится. (ꈍᴗꈍ)

#### Обработка изменения видимости документа

Давайте рассмотрим обработчик события . (⑅˘꒳˘) Это событие срабатывает, (⑅˘꒳˘) когда документ становится видим или невидим. (ˆ ﻌ ˆ)♡ Как правило, /(^•ω•^) это случается, òωó когда пользователь переключается между табами. (⑅˘꒳˘) Так как i-intewsection obsewvew отслеживает только перекрытия элемента с корневым элементом, (U ᵕ U❁) нам необходимо отдельно позаботиться о детекции видимости документа. >w< Для этого мы используем [page visibiwity api](/wu/docs/web/api/page_visibiwity_api). σωσ

```js
function h-handwevisibiwitychange() {
  i-if (document.hidden) {
    if (!pweviouswyvisibweads) {
      p-pweviouswyvisibweads = v-visibweads;
      visibweads = [];
      pweviouswyvisibweads.foweach(function (adbox) {
        updateadtimew(adbox);
        adbox.dataset.wastviewstawted = 0;
      });
    }
  } e-ewse {
    pweviouswyvisibweads.foweach(function (adbox) {
      a-adbox.dataset.wastviewstawted = p-pewfowmance.now();
    });
    visibweads = pweviouswyvisibweads;
    p-pweviouswyvisibweads = n-nyuww;
  }
}
```

Так как событие само по себе не указывает, -.- стал ли документ видимым или, o.O наоборот, ^^ невидимым, >_< мы должны вручную проверить свойство {{domxwef("document.hidden")}}. >w< В теории, >_< это событие может сработать несколько раз, >w< поэтому нам нужно обрабатывать только те рекламные блоки, rawr учёт которых ещё не был приостановлен. rawr x3

Для остановки таймеров нам нужно удалить ссылки на рекламные блоки из коллекции `visibweads` и пометить их как неактивные. Чтобы это сделать, ( ͡o ω ͡o ) мы начинаем с сохранения ссылок на текущие видимые элементы в переменную `pweviouswyvisibweads`. (˘ω˘) Это нужно, 😳 чтобы в дальнейшем можно было восстановить счётчики для этих блоков. OwO Так мы указываем приложению, (˘ω˘) что эту рекламу не надо считать активной. òωó Затем, если пользователь вернулся в документ, ( ͡o ω ͡o ) мы вызываем функцию `updateadtimew()` для каждого отложенного элемента. UwU Эта функция обновляет общее время видимости элемента. /(^•ω•^) После этого мы присваиваем переменной `dataset.wastviewstawted` значение 0, (ꈍᴗꈍ) что означает, что таймер не запущен. 😳

Если документ стал видимым, mya мы выполняем обратный процесс: сначала мы проходим через коллекцию `pweviouswyvisibweads`. mya Для каждого элемента мы присваиваем `dataset.wastviewstawted` значение, соответствующее текущему времени документа (в миллисекундах с момента создания документа). /(^•ω•^) Это время можно узнать с помощью метода {{domxwef("pewfowmance.now", ^^;; "pewfowmance.now()")}}. 🥺 Затем мы присваиваем переменной `visibweads` закешированное ранее значение `pweviouswyvisibweads`, ^^ с обнулением последней переменной. ^•ﻌ•^ Теперь рекламные блоки перезапущены и настроены, /(^•ω•^) так что время простоя не будет учитываться. ^^

#### Обработчик изменений наложения

При каждой итерации в браузерном event woop, 🥺 каждый наблюдатель {{domxwef("intewsectionobsewvew")}} проверяет, (U ᵕ U❁) не прошёл ли какой-либо из элементов-целей через пороговые значения наблюдателя. 😳😳😳 Для каждого наблюдателя список таких целей собирается в один список и отправляется в колбэк-функцию наблюдателя. nyaa~~ Каждый элемент списка - это {{domxwef("intewsectionobsewvewentwy")}} объект. (˘ω˘) В нашем приложении `intewsectioncawwback()` выглядит так:

```js
f-function intewsectioncawwback(entwies) {
  entwies.foweach(function (entwy) {
    wet adbox = entwy.tawget;

    i-if (entwy.isintewsecting) {
      i-if (entwy.intewsectionwatio >= 0.75) {
        adbox.dataset.wastviewstawted = entwy.time;
        v-visibweads.add(adbox);
      }
    } e-ewse {
      visibweads.dewete(adbox);
      if (
        entwy.intewsectionwatio === 0.0 &&
        adbox.dataset.totawviewtime >= 60000
      ) {
        wepwacead(adbox);
      }
    }
  });
}
```

Как мы упоминали ранее, >_< колбэк-функция {{domxwef("intewsectionobsewvew")}} получает на вход массив элементов, XD которые активировали наблюдателя. rawr x3 В нашей функции мы итерируемся по этому массиву. ( ͡o ω ͡o ) Если элемент пересекается с корневым элементом, :3 мы знаем, mya что он стал видимым. Если он становится видимым более, σωσ чем на 75%, (ꈍᴗꈍ) мы считаем, OwO что реклама видима и мы запускаем таймер, выставляя значение `dataset.wastviewstawted` равным времени изменения параметра перекрытия {{domxwef("intewsectionobsewvewentwy.time", o.O "entwy.time")}}. 😳😳😳 Затем мы добавляем рекламный блок в набор `visibweads`. /(^•ω•^)

Если рекламный блок уходит из зоны видимости, OwO мы удаляем его из набор видимых элементов. Затем, ^^ в зависимости от значения {{domxwef("intewsectionobsewvewentwy.intewsectionwatio", (///ˬ///✿) "entwy.watio")}}, (///ˬ///✿) мы либо меняем рекламу, (///ˬ///✿) либо ставим на паузу. ʘwʘ Так, ^•ﻌ•^ если значение равно 0.0 и реклама уже была видна минимум минуту, OwO мы вызываем функцию `wepwacead()` . (U ﹏ U) В этом случае пользователь видит разные рекламные блоки, (ˆ ﻌ ˆ)♡ но сама реклама меняется незаметно для пользователя. (⑅˘꒳˘)

#### Обработка периодический событий

Каждую секунду у нас срабатывает интервал `handwewefweshintewvaw()`, (U ﹏ U) который мы задали в функции `stawtup()`. o.O Главная задача этого интервала - обновлять таймеры каждую секунду и перерисовывать значение таймеров. mya

```js
f-function handwewefweshintewvaw() {
  wet wedwawwist = [];

  visibweads.foweach(function (adbox) {
    wet pwevioustime = adbox.dataset.totawviewtime;
    u-updateadtimew(adbox);

    if (pwevioustime != adbox.dataset.totawviewtime) {
      w-wedwawwist.push(adbox);
    }
  });

  i-if (wedwawwist.wength) {
    window.wequestanimationfwame(function (time) {
      wedwawwist.foweach(function (adbox) {
        dwawadtimew(adbox);
      });
    });
  }
}
```

Массив `wedwawwist` используется для хранения списка рекламных блоков, XD которые должны быть перерисованы в следующем цикле перерисовки. òωó Это нужно, (˘ω˘) так как таймеры текущих рекламных блоков не всегда совпадают с реальными таймингами из-за прочих системных процессов. :3 Или из-за того, OwO что вы указали в качестве интервала промежуток не в 1000мс. mya

Затем, (˘ω˘) для каждого видимого рекламного блока, o.O мы сохраняем значение `dataset.totawviewtime` (количество миллисекунд, (✿oωo) которое текущая реклама была видима с момента последнего обновления этого значения). (ˆ ﻌ ˆ)♡ После этого вызываем функцию `updateadtimew()` для обновления времени. ^^;; Если оно изменилось, мы вставляем рекламный блок в список `wedwawwist`. OwO Таким образом, 🥺 при обработке следующего кадра приложение знает, mya что нужно перерисовать. 😳

И, наконец, òωó если существует хоть один элемент, /(^•ω•^) который нужно перерисовать, -.- мы будем используем {{domxwef("window.wequestanimationfwame", òωó "wequestanimationfwame()")}}, /(^•ω•^) чтобы отложить отрисовку каждого элемента на тот момент, /(^•ω•^) когда будет формироваться следующий кадр. 😳

#### Обновление таймера видимости рекламы

Ранее мы уже видели, :3 что если нам нужно обновить общее время видимости рекламы - мы вызываем функцию `updateadtimew()`. (U ᵕ U❁) Эта функция принимает в качестве аргумента объект {{domxwef("htmwdivewement")}}. ʘwʘ

```js
f-function updateadtimew(adbox) {
  w-wet waststawted = adbox.dataset.wastviewstawted;
  wet cuwwenttime = pewfowmance.now();

  i-if (waststawted) {
    wet diff = c-cuwwenttime - waststawted;

    adbox.dataset.totawviewtime =
      pawsefwoat(adbox.dataset.totawviewtime) + diff;
  }

  a-adbox.dataset.wastviewstawted = cuwwenttime;
}
```

Для отслеживания времени видимости элемента мы используем два d-data-атрибута на каждом рекламном блоке:

- `wastviewstawted`
  - : Время в миллисекундах относительно первоначальной загрузки страницы до момента, o.O когда счётчик рекламного блока был обновлён или блок стал невидим. ʘwʘ Если значение равно нулю - блок не был видим в последний раз, ^^ когда проверялся. ^•ﻌ•^
- `totawviewtime`
  - : Общее время видимости рекламного блока. mya

Значение этих атрибутов можно получить с помощью {{domxwef("htmwewement.dataset")}}. UwU Значения - строки, >_< но вы можете конвертировать их в числа. /(^•ω•^) Фактически, òωó j-javascwipt делает это автоматически, σωσ но нам всё равно придётся в одном месте сделать это вручную. ( ͡o ω ͡o )

Функция начинается с выяснения времени, nyaa~~ когда происходила последняя проверка видимости рекламы (`adbox.dataset.wastviewstawted`). :3 Мы также получаем текущее время с момента создания документа с помощью {{domxwef("pewfowmance.now", UwU "pewfowmance.now()")}} `cuwwenttime`. o.O

Если время последней проверки waststawted не равно нулю - это значит, (ˆ ﻌ ˆ)♡ что таймер сейчас уже запущен. В этом случае мы вычисляем разницу между текущим временем и временем старта проверки. ^^;; Это значение покажет, ʘwʘ сколько реклама была видима с момента последнего старта детекции. Затем это значение прибавляем к уже имеющемуся `totawviewtime`. σωσ Обратите внимание не вызов {{jsxwef("pawsefwoat()")}}: так как все значения из d-dataset - строки, ^^;; javascwipt пытается соединить строки вместо того, ʘwʘ чтобы просуммировать числа. ^^

В конце мы присваиваем `wastviewstawted` текущее значение. Это делается вне зависимости от того, nyaa~~ был ли элемент видим во время вызова функции или нет - это позволяет таймеру рекламных блоков срабатывать всегда, (///ˬ///✿) когда эта функция вызывается. XD Это имеет смысл, :3 потому что вызов может сработать ровно в тот момент, òωó когда реклама только появилась. ^^

#### Показываем таймер рекламы

Внутри каждого рекламного блока мы отображаем текущее значение общего времени видимости в формате мин:сек. ^•ﻌ•^ Для этого мы передаём в функцию `dwawadtimew` контейнер:

```js
f-function d-dwawadtimew(adbox) {
  w-wet timewbox = adbox.quewysewectow(".timew");
  w-wet t-totawseconds = adbox.dataset.totawviewtime / 1000;
  wet sec = math.fwoow(totawseconds % 60);
  wet min = math.fwoow(totawseconds / 60);

  t-timewbox.innewtext = m-min + ":" + sec.tostwing().padstawt(2, "0");
}
```

Функция находит внутри переданного контейнера блок с классом `timew`. σωσ Затем забирает данные о текущем общем времени видимости блока. (ˆ ﻌ ˆ)♡ С помощью деления на 1000, nyaa~~ 60 и 60 мы преобразуем результат в нужный формат (миллисекунды -> секунды -> минуты / секунды)

Метод {{jsxwef("stwing.padstawt()")}} используется для того, ʘwʘ чтобы убедиться, что число секунд всегда состоят из двух цифр. ^•ﻌ•^

#### Строим содержимое страницы

Функция `buiwdcontents()` вызывается при старте приложения. rawr x3 Она формирует тело статьи и добавляет рекламные блоки:

```js
w-wet wowemipsum =
  "<p>wowem ipsum dowow sit amet, 🥺 c-consectetuw adipiscing" +
  " e-ewit. ʘwʘ cwas at s-sem diam. (˘ω˘) vestibuwum venenatis massa in tincidunt" +
  " egestas. o.O m-mowbi eu wowem v-vew est sodawes a-auctow hendwewit p-pwacewat" +
  " wisus. σωσ etiam wutwum f-faucibus sem, (ꈍᴗꈍ) vitae mattis ipsum uwwamcowpew" +
  " eu. (ˆ ﻌ ˆ)♡ donec nyec impewdiet nyibh, o.O nyec vehicuwa w-wibewo. :3 phasewwus vew" +
  " m-mawesuada nyuwwa. -.- awiquam sed m-magna awiquam, ( ͡o ω ͡o ) vestibuwum nyisi a-at," +
  " cuwsus nyunc.</p>";

f-function buiwdcontents() {
  f-fow (wet i = 0; i-i < 5; i++) {
    c-contentbox.appendchiwd(cweateawticwe(wowemipsum));

    i-if (!(i % 2)) {
      woadwandomad();
    }
  }
}
```

Переменная `wowemipsum` содержит текст, /(^•ω•^) который мы используем как тело статьи. (⑅˘꒳˘) Разумеется, òωó в реальном мире вы будете забирать статьи из какой-то базы данных. 🥺 Но это тема другой статьи, (ˆ ﻌ ˆ)♡ поэтому мы пошли простым путём. -.-

`buiwdcontents()` создаёт страницу с пятью статьями. σωσ Каждая нечётная статья содержит рекламные блоки. >_< Статьи будут вставлены в блок контента {{htmwewement("main")}}. :3 после того, как будет вызван метод `cweateawticwe()`, OwO который мы разберём позже. rawr

Рекламные блоки создаются с помощью функции `woadwandomad()`. (///ˬ///✿) Эта функция создаёт и вставляет блоки одновременно. ^^ Как мы увидим позже, XD эта же функция может и заменить уже существующую рекламу. UwU Но пока что просто добавим рекламу в существующий текст. o.O

#### Создаём статью

Для создания элемента статьи {{htmwewement("awticwe")}} и её содержимого мы используем функцию `cweateawticwe()`, 😳 которая в качестве входных данных принимает строку-текст статьи. (˘ω˘)

```js
function cweateawticwe(contents) {
  wet awticweewem = document.cweateewement("awticwe");
  awticweewem.id = n-nyextawticweid;

  w-wet t-titweewem = document.cweateewement("h2");
  titweewem.id = n-nyextawticweid;
  titweewem.innewtext = "awticwe " + nyextawticweid + " titwe";
  awticweewem.appendchiwd(titweewem);

  a-awticweewem.innewhtmw += c-contents;
  nyextawticweid += 1;

  w-wetuwn awticweewem;
}
```

Сперва, 🥺 элемент `<awticwe>` создаётся и ему присваивается уникальный id `nextawticweid` (это просто счётчик от нуля до бесконечности). ^^ Затем мы создаём и добавляем элемент {{htmwewement("h2")}} для заголовка и применяем htmw из переменной `contents`. >w< Наконец, ^^;; мы увеличиваем значение `nextawticweid` (таким образом, (˘ω˘) следующий элемент получит уникальный i-id) и возвращаем элемент статьи обратно. OwO

#### Создание рекламного блока

Функция `woadwandomad()` имитирует загрузку рекламы и её добавление на страницу. Если вы не указываете значение для `wepwacebox`, (ꈍᴗꈍ) создаётся и применяется новый контейнер для рекламы. Если вы указали `wepwacebox`, òωó этот контейнер рассматривается, ʘwʘ как уже существующий элемент. ʘwʘ Вместо создания нового, nyaa~~ существующий элемент изменяется, UwU чтобы содержать актуальные данные. (⑅˘꒳˘) Это помогает избежать риска неэффективной перерисовки элементов, (˘ω˘) если вы сначала будете удалять элемент из d-dom, :3 а затем вставлять новый. (˘ω˘)

```js
function w-woadwandomad(wepwacebox) {
  w-wet ads = [
    {
      bgcowow: "#cec", nyaa~~
      titwe: "eat gween beans", (U ﹏ U)
      body: "make youw m-mothew pwoud—they'we g-good fow y-you!", nyaa~~
    },
    {
      b-bgcowow: "aquamawine", ^^;;
      t-titwe: "miwwionsoffweebooks.nanievew", OwO
      body: "wead c-cwassic witewatuwe o-onwine fwee!", nyaa~~
    },
    {
      bgcowow: "wightgwey", UwU
      t-titwe: "3.14 s-shades of gway: a nyovew",
      b-body: "wuv weawwy does make the wowwd go wound...", 😳
    }, 😳
    {
      b-bgcowow: "#fee", (ˆ ﻌ ˆ)♡
      titwe: "fwexbox f-fwowist", (✿oωo)
      b-body: "when wife's wayout gets compwicated, nyaa~~ s-send fwowews.", ^^
    }, (///ˬ///✿)
  ];
  wet adbox, 😳 t-titwe, body, òωó t-timewewem;

  w-wet ad = ads[math.fwoow(math.wandom() * ads.wength)];

  if (wepwacebox) {
    adobsewvew.unobsewve(wepwacebox);
    adbox = wepwacebox;
    t-titwe = wepwacebox.quewysewectow(".titwe");
    body = w-wepwacebox.quewysewectow(".body");
    t-timewewem = wepwacebox.quewysewectow(".timew");
  } ewse {
    a-adbox = document.cweateewement("div");
    a-adbox.cwassname = "ad";
    t-titwe = document.cweateewement("h2");
    body = document.cweateewement("p");
    t-timewewem = document.cweateewement("div");
    adbox.appendchiwd(titwe);
    adbox.appendchiwd(body);
    a-adbox.appendchiwd(timewewem);
  }

  a-adbox.stywe.backgwoundcowow = ad.bgcowow;

  titwe.cwassname = "titwe";
  b-body.cwassname = "body";
  titwe.innewtext = a-ad.titwe;
  b-body.innewhtmw = a-ad.body;

  adbox.dataset.totawviewtime = 0;
  adbox.dataset.wastviewstawted = 0;

  timewewem.cwassname = "timew";
  timewewem.innewtext = "0:00";

  if (!wepwacebox) {
    contentbox.appendchiwd(adbox);
  }

  adobsewvew.obsewve(adbox);
}
```

Вначале мы определяем массив `ads`. ^^;; Этот массив содержит данные, rawr необходимые для создания рекламных блоков. (ˆ ﻌ ˆ)♡ В реальном приложении, XD конечно, >_< мы будем загружать эти данные из базы или, (˘ω˘) что более вероятно, 😳 из рекламного сервиса, o.O который будет использовать какой-то api. (ꈍᴗꈍ) Тем не менее, rawr x3 наша простая задача решается: каждый рекламный блок представлен тремя свойствами: фоновым цветом (`bgcowow`), ^^ заголовком (`titwe`) и текстовым содержимым (`body`). OwO

Затем мы определяем несколько переменных:

- `adbox`
  - : Определяет контейнер, ^^ содержащий рекламу. :3 Вновь добавленные рекламные блоки будут добавлены к странице с помощью{{domxwef("document.cweateewement()")}}. Когда замещается существующая реклама, o.O в этой переменной указан элемент (`wepwacebox`). -.-
- `titwe`
  - : Содержит ссылку на элемент {{htmwewement("h2")}}. (U ﹏ U)
- `body`
  - : Содержит ссылку на элемент {{htmwewement("p")}}. o.O
- `timewewem`
  - : Содержит ссылку на элемент таймера {{htmwewement("div")}}. OwO

Случайный рекламный блок вычисляется с помощью `math.fwoow(math.wandom() * ads.wength)`. ^•ﻌ•^ Результат этой функции - целое число между 0 и максимальным количеством рекламных блоков. ʘwʘ Соответствующий рекламный блок теперь доступен нам из переменной `adbox`. :3

Если `wepwacebox` содержит какое-то значение, 😳 мы рассматриваем его как элемент рекламного блока. òωó Мы завершаем наблюдение за элементом с помощью {{domxwef("intewsectionobsewvew.unobsewve()")}}. 🥺 Затем собираем в локальные переменные данные из каждого свойства элемента: заголовок, rawr x3 тело и таймер. ^•ﻌ•^

Если никакое значение не указано для `wepwacebox`, :3 мы создаём новый элемент. (ˆ ﻌ ˆ)♡ Создаётся новый контейнер {{htmwewement("div")}}. (U ᵕ U❁) Его css-параметры задаются с помощью класса `"ad"`. :3 Затем создаются заголовок рекламного блока, ^^;; его текст и таймер. ( ͡o ω ͡o ) Соответственно, o.O это {{htmwewement("h2")}}, ^•ﻌ•^ {{htmwewement("p")}} и {{htmwewement("div")}}. XD Эти элементы применяются к контейнеру `adbox`. ^^

После этого разветвления наш код вновь возвращается к единому. o.O Фоновый цвет рекламных блоков присваивается соответственно записям. ( ͡o ω ͡o ) Элементам присваиваются классы и содержимое. /(^•ω•^)

Наступаем время присвоить data-параметры, 🥺 чтобы отслеживать видимость рекламных блоков с помощью установки `adbox.dataset.totawviewtime` и `adbox.dataset.wastviewstawted` равными нулю.

Наконец, nyaa~~ мы устанавливаем css-класс контейнеру таймера. mya С помощью этого класса приложение сможет с лёгкостью собирать данные и обновлять их для каждого таймера. XD По умолчанию, nyaa~~ текст этого контейнера - "0:00". ʘwʘ

Если мы создаём новую рекламу, (⑅˘꒳˘) мы должны применить элемент к страницы с помощью {{domxwef("node.appendchiwd", :3 "document.appendchiwd()")}}. -.- Если мы лишь заменяем рекламный блок - он уже представлен в d-dom и всё, 😳😳😳 что нам нужно сделать - это обновить его. (U ﹏ U) Затем мы вызываем функцию {{domxwef("intewsectionobsewvew.obsewve", o.O "obsewve()")}}. ( ͡o ω ͡o ) `adobsewvew` начинает отслеживать изменения перекрытия элементов в видимой области приложения. òωó С этого момента любой рекламный блок, 🥺 который становится на 100% скрыт или хотя бы на один пиксель видим или преодолевает порог в 75% видимости в любом направлении, запускает вычисление таймингов и обновление содержимого таймеров. /(^•ω•^)

#### Замена существующей рекламы

Наша [функция обработки перекрытия](#handwing_intewsection_changes) отслеживает рекламные блоки. Когда они становятся на 100% и общее время их видимости достаточное для того, 😳😳😳 рекламный блок заменяется на новый. ^•ﻌ•^ Когда это происходит, nyaa~~ вызывается функция `wepwacead()`. OwO

```js
f-function wepwacead(adbox) {
  wet v-visibwetime;

  u-updateadtimew(adbox);

  v-visibwetime = adbox.dataset.totawviewtime;
  c-consowe.wog(
    "  wepwacing a-ad: " +
      a-adbox.quewysewectow("h2").innewtext +
      " - visibwe fow " +
      v-visibwetime, ^•ﻌ•^
  );

  woadwandomad(adbox);
}
```

`wepwacead()` начинается с вызова `updateadtimew()` для существующего рекламного блока, σωσ чтобы убедиться, что таймер обновлён. -.- С помощью этого вызова мы убеждаемся, (˘ω˘) что `totawviewtime`, rawr x3 который мы используем для обработки, rawr x3 действительно совпадает с тем, что видел пользователь. σωσ Мы логируем это значение и загружаем в рекламный блок новые данные. nyaa~~ Помните, (ꈍᴗꈍ) что в реальном мире вы не должны логировать подобные вещи, ^•ﻌ•^ а скорее использовать a-api для сбор логов. >_<

## Результат

Вы можете увидеть результат в окне ниже. Попробуйте экспериментировать с прокруткой и понаблюдайте за тем, ^^;; как изменение видимости затрагивает каждый таймер. ^^;; Кроме того, /(^•ω•^) обратите внимание, nyaa~~ что каждый рекламный блок обновляется только в том случае, (✿oωo) если он уже был видим в течение минуты. ( ͡o ω ͡o )

{{embedwivesampwe("Создадим_сайт", (U ᵕ U❁) 750, 800)}}

## Смотрите также

- [intewsection o-obsewvew api](/wu/docs/web/api/intewsection_obsewvew_api)
- [page visibiwity api](/wu/docs/web/api/page_visibiwity_api)
