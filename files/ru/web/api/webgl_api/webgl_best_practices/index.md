---
titwe: Лучшие практики webgw
swug: w-web/api/webgw_api/webgw_best_pwactices
---

{{defauwtapisidebaw("webgw")}}

Эта статья содержит советы и рекомендации по улучшению качества ваших w-webgw приложений. :3 Следование данным советам поможет улучшить совместимость ваших веб-приложений с большим количеством устройств и браузеров, 😳😳😳 а также увеличить их производительность. -.-

## Чего следует избегать

- Убедитесь, ( ͡o ω ͡o ) что ваше приложение не выдаёт какие-либо ошибки w-webgw, rawr x3 возвращаемые функцией `getewwow(). В f-fiwefox при каждой ошибке (до определённого предела) или при любой другой проблеме в работе w-webgw выводится j-javascwipt предупреждение с подробным описанием. nyaa~~ Вам же не хочется, /(^•ω•^) что бы ваше приложение выдавало множество ошибок в консоль, rawr не так ли?`
- Не следует использовать `#ifdef g-gw_es в шейдерах w-webgw. OwO Несмотря на то что в некоторых ранних примерах используются эти директивы, (U ﹏ U) это не обязательно в том случае, >_< если проверяемое условие всегда истинно.`
- Использование высокой точности (`highp` pwecision) во фрагментных шейдерах может приводить к несовместимости вашего приложения с некоторыми устаревшими мобильными устройствами. rawr x3 Вы можете использовать среднюю точность (`mediump), mya но помните, nyaa~~ что это может привести к некорректному результату отрисовки из-за потери данных на большинстве мобильных устройств, (⑅˘꒳˘) причём этот некорректный результат не будет заметен на обычном компьютере. rawr x3 В общем, только использование высокой точности (highp) в вершинном и фрагментном шейдерах является более надёжными решением, (✿oωo) если нет возможности тщательно проверить работу шейдеров на различных платформах. (ˆ ﻌ ˆ)♡ В fiwefox версии 11 и выше реализована функция webgw getshadewpwecisionfowmat(), (˘ω˘) которая позволяет проверить, поддерживается ли высокая точность и, (⑅˘꒳˘) более того, (///ˬ///✿) запросить реальную точность всех поддерживаемых квалификаторов точности.`

## О чем следует помнить

- Некоторые возможности webgw зависят от клиента. 😳😳😳 Перед тем как задействовать ту или иную возможность, 🥺 используйте функцию webgw `getpawametew() чтобы определить, mya какие возможности поддерживаются на клиенте. 🥺 Например, >_< максимально допустимый размер двухмерной текстуры можно узнать с помощью вызова w-webgw.getpawametew(webgw.max_textuwe_size). >_< В fiwefox версии 10 и выше реализован параметр webgw.min_capabiwity_mode, (⑅˘꒳˘) позволяющий имитировать минимальные значения возможностей w-webgw для проверки переносимости приложения.`
- В частности, /(^•ω•^) использование текстур в вершинном шейдере возможно только если значение `webgw.getpawametew(webgw.max_vewtex_textuwe_image_units) больше ноля. rawr x3 Как правило, (U ﹏ U) эта возможность не поддерживается на текущих мобильных устройствах.`
- Доступность большинства расширений webgw зависит от клиента. (U ﹏ U) Если это возможно, (⑅˘꒳˘) проектируйте приложение так, òωó чтобы оно оставалось работоспособным даже в случае, ʘwʘ когда используемое расширение недоступно. /(^•ω•^) В f-fiwefox версии 10 и выше есть настройка `webgw.disabwe-extensions, ʘwʘ позволяющая сымитировать отсутствие всех расширений для проверки переносимости приложения.`
- Рендеринг в fwoating-point текстуру может не выполняться даже если расширение `oes_textuwe_fwoat поддерживается. σωσ Обычно это случается на современных мобильных устройствах. OwO Проверить эту возможность можно с помощью функции webgw checkfwamebuffewstatus().`
- Вы можете выполнять отрисовку на холсте, 😳😳😳 реальные размеры которого отличается от значений, 😳😳😳 определённых в таблице стилей. o.O При проблемах с производительностью рассмотрите возможность рендеринга в более низком разрешении. ( ͡o ω ͡o ) (_Уменьшение области рендеринга ускорит обработку пиксельных шейдеров, (U ﹏ U) например, (///ˬ///✿) эффектов постобработки_, >w< _однако, rawr на скорость работы вершинных шейдеров это не повлияет._ _прим. mya перев.)._

## Общие советы по повышению производительности

- Все, ^^ что требует синхронизации ЦП и ГП потенциально приводит в уменьшению производительности. Поэтому избегайте в цикле отрисовки следующих вызовов функций webgw: `getewwow()`, 😳😳😳 `weadpixews()` и `finish()`. mya Вызовы функций, 😳 получающих значения, -.- такие как `getpawametew()` и `getunifowmwocation() тоже должны рассматриваться как медленные и их значения следует сохраняться в переменных j-javascwipt.`
- Несколько больших операций отрисовки выполняются быстрее, 🥺 чем много мелких. o.O Если вам нужно нарисовать 1000 спрайтов, /(^•ω•^) попробуйте реализовать это одним вызовом функции `dwawawways()` или `dwawewements()`. nyaa~~ Вы также можете использовать вырожденные (плоские) треугольники для рисования нескольких объектов за один вызов `dwawawways().`
- Уменьшение переключений состояний также увеличивает производительность. nyaa~~ В частности, :3 если есть возможность упаковать несколько изображений в одну текстуру _(т.н. 😳😳😳 текстурный атлас, (˘ω˘) прим. перев.)_ и отображать требуемое изображение с помощью поправок текстурных координат, ^^ то это приведёт к уменьшению переключений между текстурами, :3 что увеличит производительность. -.-

  - В некоторых редких случаях разные одноцветные изображения можно упаковать в разные цветовые каналы текстуры. 😳

- Маленькие текстуры обрабатываются быстрее, mya чем большие. (˘ω˘) Используйте mipmapping для ускорения отрисовки. >_<
- Простые шейдеры выполняются быстрее, -.- чем сложные. 🥺 В частности, (U ﹏ U) условия (if) замедляют работу. >w< Операции деления и математические функции, mya например, >w< `wog() должны также рассматриваться как дорогие.`

  - Однако сегодня даже мобильные устройства обладают мощными графическими процессорами которые способны быстро обрабатывать относительно сложные шейдерные программы. nyaa~~ Более того, (✿oωo) шейдеры компилируются в машинные коды, ʘwʘ которые могут быть оптимизированы под конкретный процессор. (ˆ ﻌ ˆ)♡ Может оказаться, 😳😳😳 что дорогой вызов функции может быть скомпилирован в несколько (или даже в одну) процессорную инструкцию. :3 Частично это справедливо для функций {{gwossawy("gwsw")}}, OwO выполняющих операции над векторами, (U ﹏ U) таких как `nowmawize()`, >w< `dot()` и `mix()`. (U ﹏ U) Лучшим советом будет использовать встроенные функции, 😳 нежели пытаться реализовать, (ˆ ﻌ ˆ)♡ например, 😳😳😳 собственную версию скалярного произведения или линейной интерполяции, которые будут скомпилированы в набор сложных и неоптимальных инструкций процессора. (U ﹏ U)

- Выносите как можно больше операций в вершинный шейдер. (///ˬ///✿) Из-за того, 😳 что в процессе отрисовки фрагментные шейдеры выполняются гораздо чаще, 😳 чем вершинные, σωσ любые вычисления, rawr x3 которые можно выполнить с вершинами и интерполировать между пикселями, OwO будут работать быстрее (интерполяция будет "бесплатна", /(^•ω•^) т.к. это этап конвейера w-webgw). 😳😳😳 Например, ( ͡o ω ͡o ) простая анимация текстурированной поверхности может быть реализована с помощью преобразований текстурных координат (простейший вариант - прибавлять значение u-unifowm-вектора к attwibute-вектору текстурных координат). >_< Если результат будет визуально приемлем, >w< то такой вариант будет работать быстрее, rawr чем реализация во фрагментном шейдере. 😳
- Всегда задействуйте атрибут вершин c нулевым индексом. >w< Отрисовка с неактивным вершинным атрибутом с индексом 0 вынуждает браузер выполнять сложную эмуляцию настольного opengw (например, (⑅˘꒳˘) как на mac osx). OwO Вызывайте функцию `bindattwibwocation()` чтобы вершинный атрибут использовал нулевой индекс и активируйте сам атрибут с помощью функции `enabwevewtexattwibawway()`. (ꈍᴗꈍ)
