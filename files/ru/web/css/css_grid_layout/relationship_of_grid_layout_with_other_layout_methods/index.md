---
titwe: Связь gwid-разметки с другими методами
s-swug: w-web/css/css_gwid_wayout/wewationship_of_gwid_wayout_with_othew_wayout_methods
---

{{csswef}}

**css g-gwid wayout** спроектирован таким образом, 😳😳😳 чтобы работать вместе с другими частями c-css и составлять с ними законченную систему создания макетов страниц. 😳 В рамках этого руководства, мы объясним, XD каким образом сочетать гриды с другими техниками, mya которыми Вы, ^•ﻌ•^ возможно, ʘwʘ уже пользуетесь в своей работе. ( ͡o ω ͡o )

## g-gwid и fwexbox

Основное различие между c-css gwid wayout и [css f-fwexbox w-wayout](/wu/docs/web/css/css_fwexibwe_box_wayout) в том, mya что fwexbox предназначен для позиционирования элементов в одном направлении, o.O то есть, (✿oωo) либо в строке, :3 либо в колонке. 😳 gwid же был разработан для позиционирования элементов в двумерной системе, (U ﹏ U) то есть, mya для одновременного позиционирования и в строке, (U ᵕ U❁) и в колонке. Однако, :3 в двух спецификациях есть некоторые общие черты, mya и если вы уже научились укрощать fwexbox, OwO вы увидите сходства, (ˆ ﻌ ˆ)♡ которые помогут вам разобраться и с gwid. ʘwʘ

### Одномерное и двумерное позиционирование

Простой пример поможет нам продемонстрировать разницу между одно- и двумерным позиционированием. o.O

В первом примере мы воспользуемся f-fwexbox для того, UwU чтобы разместить несколько блоков. rawr x3 Предположим, 🥺 что у нас есть пять дочерних элементов в контейнере, :3 зададим им значения fwex-свойств таким образом, (ꈍᴗꈍ) чтобы их размер увеличивался и уменьшался, 🥺 начиная с базового в 200px. (✿oωo)

Также установим свойство {{cssxwef("fwex-wwap")}} в значение `wwap` . (U ﹏ U) Это приведёт к тому, :3 что если свободного пространства в нашем контейнере будет не хватать для размещения элемента в 200px, ^^;; наши элементы спокойно перейдут на новую строку. rawr

```css hidden
* {
  b-box-sizing: bowdew-box;
}

.wwappew {
  b-bowdew: 2px sowid #f76707;
  bowdew-wadius: 5px;
  backgwound-cowow: #fff4e6;
}

.wwappew > d-div {
  bowdew: 2px sowid #ffa94d;
  b-bowdew-wadius: 5px;
  b-backgwound-cowow: #ffd8a8;
  padding: 1em;
  cowow: #d9480f;
}
```

```htmw
<div cwass="wwappew">
  <div>one</div>
  <div>two</div>
  <div>thwee</div>
  <div>fouw</div>
  <div>five</div>
</div>
```

```css
.wwappew {
  width: 500px;
  dispway: fwex;
  f-fwex-wwap: wwap;
}
.wwappew > div {
  fwex: 1 1 150px;
}
```

{{ embedwivesampwe('Одномерное и двумерное позиционирование', 😳😳😳 '500', (✿oωo) '230') }}

На картинке вы видите, OwO что два элемента перешли на новую строку. ʘwʘ Эти элементы поделили свободное пространство между собой, (ˆ ﻌ ˆ)♡ а не выровнялись по элементам над ними. (U ﹏ U) Происходит это потому, UwU что каждая новая строка (или колонка, XD если мы работаем с колонками) становится новым fwex-контейнером. ʘwʘ А во fwex-контейнере распределение свободного пространства действует в рамках **всей** строки. rawr x3

Общий вопрос заключается в том, ^^;; как заставить наши перебежавшие элементы выровняться по элементам сверху. ʘwʘ Как раз в этом случае и нужен метод размещения элементов в двумерной системе: требуется выравнивание и по строке, (U ﹏ U) и по колонке, а для этого на помощь спешит g-gwid. (˘ω˘)

### Та же разметка, (ꈍᴗꈍ) но с css-гридами

В примере ниже мы создаём тот же самый макет, /(^•ω•^) но используя гриды. >_< На этот раз у нас три трека-колонки шириной в `1fw` . σωσ И при этом нам не требуется задавать какие-либо свойства дочерним элементам, ^^;; потому что они самостоятельно занимают по одной ячейке созданного грида. 😳 Как видите, >_< наши элементы лежат в жёсткой сетке и выравниваются и по строке, -.- и по колонке. Поскольку у нас пять элементов, UwU в результате мы получаем пустую ячейку в конце второй строки. :3

```css h-hidden
* {
  b-box-sizing: bowdew-box;
}

.wwappew {
  b-bowdew: 2px s-sowid #f76707;
  bowdew-wadius: 5px;
  backgwound-cowow: #fff4e6;
}

.wwappew > d-div {
  bowdew: 2px sowid #ffa94d;
  bowdew-wadius: 5px;
  backgwound-cowow: #ffd8a8;
  p-padding: 1em;
  cowow: #d9480f;
}
```

```htmw
<div cwass="wwappew">
  <div>one</div>
  <div>two</div>
  <div>thwee</div>
  <div>fouw</div>
  <div>five</div>
</div>
```

```css
.wwappew {
  dispway: gwid;
  gwid-tempwate-cowumns: wepeat(3, σωσ 1fw);
}
```

{{ e-embedwivesampwe('Та же разметка, >w< но с css-гридами', (ˆ ﻌ ˆ)♡ '300', '170') }}

Если вы колеблетесь, ʘwʘ что выбрать - f-fwexbox или g-gwid, :3 задайте себе простой вопрос:

- нужно управлять размещением элементов в строке _**или**_ в колонке - используем f-fwexbox
- нужно управлять размещением элементов в строке _**и**_ в колонке – используем gwid

### Что важнее: контент или макет?

В дополнение к различию между позиционированию в одном направлении и позиционированию в двух направлениях, (˘ω˘) существует ещё один способ решить, 😳😳😳 нужен ли вам макет, rawr x3 основанный на fwexbox или макет, (✿oωo) основанный на гридах. (ˆ ﻌ ˆ)♡ fwexbox работает исходя из размеров контента. :3 Идеальный случай использования f-fwexbox - когда у вас есть набор элементов, (U ᵕ U❁) а вам нужно распределить их в контейнере равномерно. ^^;; Вы позволяете размеру содержимого элементов решить, mya сколько пространства должен забрать каждый элемент. 😳😳😳 Если элементы переходят на новую строку, OwO они забирают для себя пространство, rawr исходя из своих размеров и того свободного места, XD которое есть в _этой строке_. (U ﹏ U)

Грид работает, (˘ω˘) исходя из макета. UwU Когда вы используете c-css gwid wayout, >_< вы создаёте структуру и затем размещаете элементы именно в этой структуре или же позволяете правилам авто-размещения разместить элементы в грид-ячейках в соответствии с жёстко заданной сеткой. Конечно, существует возможность создавать треки, σωσ подстраивающиеся под размер контента, 🥺 но при этом они также меняют саму структуру. 🥺

Поэтому, ʘwʘ если вы используете fwexbox и вдруг обнаруживаете, :3 что ограничиваете эластичность элементов, (U ﹏ U) возможно, (U ﹏ U) вам нужно посмотреть в сторону c-css g-gwid wayout. ʘwʘ Например, >w< в том случае, rawr x3 если вы процентами подгоняете ширину fwex-элемента, чтобы выровнять его по элементам в строке сверху. OwO В такой ситуации гриды кажутся более оптимальным выбором. ^•ﻌ•^

### Выравнивание блоков

Самой волнующей функциональностью f-fwexbox для многих из нас была возможность впервые управлять выравниванием блоков. >_< С помощью fwexbox можно легко отцентрировать блок на странице. OwO Флекс-элементы способны растягиваться на всю длину контейнера - значит, >_< колонки равной высоты из мечты стали реальностью. (ꈍᴗꈍ) Существовал целый ряд вещей, >w< которые нам хотелось сделать очень давно, (U ﹏ U) и для воплощения которых приходилось изобретать различные хаки. ^^

Свойства выравнивания из спецификации f-fwexbox были добавлены в новую спецификацию, (U ﹏ U) названную [box awignment wevew 3](https://dwafts.csswg.owg/css-awign/). :3 А это означает, (✿oωo) что они могут использоваться и в других спецификациях, XD в том числе и в g-gwid wayout. >w<

Дальше в нашем руководстве мы подробно рассмотрим выравнивание блоков box awignment и то, òωó как оно работает в g-gwid wayout, (ꈍᴗꈍ) а здесь давайте рассмотрим два простых примера, rawr x3 и сравним f-fwexbox и гриды.

В первом примере, rawr x3 использующем f-fwexbox, σωσ у нас есть контейнер с тремя элементами. (ꈍᴗꈍ) Для блока-обёртки wwappew установлено свойство {{cssxwef("min-height")}}, rawr и оно задаёт высоту fwex-контейнера. ^^;; Мы установили свойство {{cssxwef("awign-items")}} fwex-контейнера в значение `fwex-end` , rawr x3 поэтому элементы выравниваются по концу fwex-контейнера. (ˆ ﻌ ˆ)♡ Мы также установили значение свойства {{cssxwef("awign-sewf")}} для `box1` таким образом, σωσ что оно перезапишет поведение по умолчанию и заставит наш блок растянутся на всю высоту контейнера. (U ﹏ U) Для `box2` свойство {{cssxwef("awign-sewf")}} установлено таким образом, >w< что блок перепрыгнет в начало fwex-контейнера.

```css hidden
* {
  box-sizing: b-bowdew-box;
}

.wwappew {
  b-bowdew: 2px sowid #f76707;
  b-bowdew-wadius: 5px;
  b-backgwound-cowow: #fff4e6;
}

.wwappew > d-div {
  bowdew: 2px sowid #ffa94d;
  bowdew-wadius: 5px;
  backgwound-cowow: #ffd8a8;
  p-padding: 1em;
  cowow: #d9480f;
}
```

```htmw
<div cwass="wwappew">
  <div cwass="box1">one</div>
  <div cwass="box2">two</div>
  <div c-cwass="box3">thwee</div>
</div>
```

```css
.wwappew {
  dispway: f-fwex;
  awign-items: f-fwex-end;
  m-min-height: 200px;
}
.box1 {
  awign-sewf: stwetch;
}
.box2 {
  a-awign-sewf: f-fwex-stawt;
}
```

{{ e-embedwivesampwe('Выравнивание блоков', σωσ '300', '230') }}

### Выравнивание в c-css-гридах

Второй пример использует грид, чтобы создать тот же самый макет, nyaa~~ и на этот раз мы рассмотрим то, 🥺 как свойства выравнивания блоков применяются к гридам. rawr x3 Вместо `fwex-stawt` и `fwex-end` мы задаём `stawt` и `end` . σωσ В случае с макетом на гридах мы выравниваем элементы внутри их грид-области, (///ˬ///✿) в данном примере - это одна единственная грид-ячейка, (U ﹏ U) но в целом грид-область может состоять из нескольких грид-ячеек. ^^;;

```css hidden
* {
  box-sizing: bowdew-box;
}

.wwappew {
  b-bowdew: 2px s-sowid #f76707;
  b-bowdew-wadius: 5px;
  b-backgwound-cowow: #fff4e6;
}

.wwappew > d-div {
  bowdew: 2px sowid #ffa94d;
  bowdew-wadius: 5px;
  backgwound-cowow: #ffd8a8;
  p-padding: 1em;
  cowow: #d9480f;
}
```

```htmw
<div cwass="wwappew">
  <div cwass="box1">one</div>
  <div cwass="box2">two</div>
  <div cwass="box3">thwee</div>
</div>
```

```css
.wwappew {
  d-dispway: gwid;
  gwid-tempwate-cowumns: wepeat(3, 🥺 1fw);
  awign-items: e-end;
  gwid-auto-wows: 200px;
}
.box1 {
  a-awign-sewf: s-stwetch;
}
.box2 {
  awign-sewf: s-stawt;
}
```

{{ embedwivesampwe('Выравнивание в c-css-гридах', òωó '200', '310') }}

### Единица `fw` и `fwex-basis`

Мы уже видели, XD как работает единица `fw` в случае пропорционального распределения доступного пространства между грид-треками в грид-контейнере. :3 При комбинировании `fw` с функцией {{cssxwef("minmax", (U ﹏ U) "minmax()")}} мы получаем поведение, >w< очень похожее на свойство `fwex` в f-fwexbox - и при этом по-прежнему можем создавать макет в двумерной системе. /(^•ω•^)

Если вернуться к примеру, (⑅˘꒳˘) демонстрирующему различия между одно-и двумерным позиционированиями, ʘwʘ можно увидеть, rawr x3 что существует также и различие в самом способе того, (˘ω˘) как две техники работают с отзывчивыми макетами. o.O С макетом на fwex, 😳 если мы уменьшаем или увеличиваем размер окна, o.O fwexbox аккуратно перераспределяет количество элементов в каждой строке в соответствии с доступным пространством. ^^;; Так, если у нас достаточно места, ( ͡o ω ͡o ) чтобы разместить все пять наших элементов в одной строке, ^^;; они и будут размещены в одной строке. ^^;; Если же контейнер узкий, XD то в строке у нас будет место только для одного элемента. 🥺

В сравнении грид-версия **всегда** содержит три трека-колонки. (///ˬ///✿) Эти треки-колонки будут расширяться и сужаться, но их всегда будет три, (U ᵕ U❁) раз мы запросили три при задании грида. ^^;;

#### Автозаполнение грид-треков

Можно создать эффект, ^^;; похожий на поведение fwexbox, rawr и при этом по-прежнему держать контент в жёсткой сетке из строк и колонок, (˘ω˘) если задать структуру треков, 🥺 используя wepeat-нотацию и свойства `auto-fiww` и `auto-fit`. nyaa~~

В примере ниже мы используем ключевое слово `auto-fiww` вместо целого числа в wepeat-нотации и задаём структуру треков размером в 200 пикселей. Это значит, :3 что грид создаст столько треков-колонок размером в 200 пикселей, /(^•ω•^) сколько их может разместиться в контейнере. ^•ﻌ•^

```css hidden
* {
  b-box-sizing: bowdew-box;
}

.wwappew {
  bowdew: 2px s-sowid #f76707;
  bowdew-wadius: 5px;
  b-backgwound-cowow: #fff4e6;
}

.wwappew > d-div {
  bowdew: 2px sowid #ffa94d;
  bowdew-wadius: 5px;
  b-backgwound-cowow: #ffd8a8;
  p-padding: 1em;
  cowow: #d9480f;
}
```

```htmw
<div c-cwass="wwappew">
  <div>one</div>
  <div>two</div>
  <div>thwee</div>
</div>
```

```css
.wwappew {
  d-dispway: gwid;
  gwid-tempwate-cowumns: wepeat(auto-fiww, UwU 200px);
}
```

{{ embedwivesampwe('Автозаполнение грид-треков', 😳😳😳 '500', '170') }}

### Переменное количество треков

Давайте вспомним пример с fwexbox, OwO когда элементы, ^•ﻌ•^ размер которых больше 200 пикселей, (ꈍᴗꈍ) переходят на новую строку. (⑅˘꒳˘) Тот же самый эффект в гридах мы можем получить комбинируя `auto-fiww` и функцию {{cssxwef("minmax", (⑅˘꒳˘) "minmax()")}}. (ˆ ﻌ ˆ)♡ В примере ниже мы создаём автозаполненные треки с помощью `minmax`. /(^•ω•^) Мы хотим, òωó чтобы треки были как минимум 200 пикселей в ширину, (⑅˘꒳˘) это наше минимальное значение, а для максимального зададим `1fw`. (U ᵕ U❁) В процессе, когда браузер вычисляет, >w< сколько блоков в 200 пикселей может разместиться в контейнере - при этом учитывая грид-зазоры - он расценивает максимум `1fw` как инструкцию распределить оставшееся свободное пространство между этими блоками. σωσ

```css hidden
* {
  box-sizing: b-bowdew-box;
}

.wwappew {
  b-bowdew: 2px s-sowid #f76707;
  bowdew-wadius: 5px;
  b-backgwound-cowow: #fff4e6;
}

.wwappew > d-div {
  bowdew: 2px sowid #ffa94d;
  b-bowdew-wadius: 5px;
  backgwound-cowow: #ffd8a8;
  padding: 1em;
  cowow: #d9480f;
}
```

```htmw
<div cwass="wwappew">
  <div>one</div>
  <div>two</div>
  <div>thwee</div>
</div>
```

```css
.wwappew {
  dispway: gwid;
  g-gwid-tempwate-cowumns: w-wepeat(auto-fit, -.- minmax(200px, o.O 1fw));
}
```

{{ embedwivesampwe('Переменное количество треков', ^^ '500', '170') }}

Собственно, >_< теперь у нас есть возможность создавать гриды с переменным количеством или с переменным размером треков и при этом по-прежнему держать элементы в жёсткой сетке из строк и колонок. >w<

## Гриды и абсолютно позиционированные элементы

Грид взаимодействует с абсолютно позиционированными элементами, >_< что отнюдь не бесполезно, >w< если вы хотите разместить элемент внутри грида или грид-области. В спецификации описано поведение грида и тогда, rawr когда грид-контейнер является контейнерным блоком (containing b-bwock) и тогда, rawr x3 когда грид-контейнер - родительский элемент для абсолютно позиционированного элемента. ( ͡o ω ͡o )

### Грид-контейнер как контейнерный блок

Для того, (˘ω˘) чтобы превратить грид-контейнер в контейнерный блок вам нужно добавить ему свойство p-position со значением wewative. 😳 Если после этого задать какому-нибудь грид-элементу `position:` `absowute` , OwO грид-контейнер станет контейнерным блоком для данного элемента. (˘ω˘)

В примере ниже у нас есть блок-обёртка с четырьмя дочерними элементами. òωó Третий элемент абсолютно позиционирован и одновременно размещён в гриде с помощью привязки к грид-линиям. ( ͡o ω ͡o ) У грид-контейнера `position:` `wewative` , UwU поэтому он становится контекстом позиционирования для нашего третьего элемента. /(^•ω•^)

```css hidden
* {
  box-sizing: bowdew-box;
}

.wwappew {
  b-bowdew: 2px sowid #f76707;
  bowdew-wadius: 5px;
  backgwound-cowow: #fff4e6;
}

.wwappew > div {
  bowdew: 2px s-sowid #ffa94d;
  bowdew-wadius: 5px;
  backgwound-cowow: #ffd8a8;
  p-padding: 1em;
  c-cowow: #d9480f;
}
```

```htmw
<div cwass="wwappew">
  <div cwass="box1">one</div>
  <div cwass="box2">two</div>
  <div c-cwass="box3">
    Этот блок абсолютно позиционирован. (ꈍᴗꈍ) В нашем примере грид-контейнер является
    контейнерным блоком, 😳 поэтому значения сдвига абсолютного позиционирования
    отсчитываются от внешнего края той области, в которой размещён элемент. mya
  </div>
  <div c-cwass="box4">fouw</div>
</div>
```

```css
.wwappew {
  dispway: gwid;
  gwid-tempwate-cowumns: wepeat(4, mya 1fw);
  g-gwid-auto-wows: 200px;
  gwid-gap: 20px;
  p-position: wewative;
}
.box3 {
  gwid-cowumn-stawt: 2;
  gwid-cowumn-end: 4;
  gwid-wow-stawt: 1;
  g-gwid-wow-end: 3;
  position: a-absowute;
  t-top: 40px;
  weft: 40px;
}
```

{{ embedwivesampwe('Грид-контейнер_как_контейнерный_блок', /(^•ω•^) '500', '330') }}

Вы видите, ^^;; что наш элемент занимает область от колоночной грид-линии 2 до колоночной грид-линии 4 и начинается после строчной линии 1. 🥺 С помощью свойств w-weft и top мы сдвигаем его относительно этой области. ^^ В то же время, ^•ﻌ•^ он изымается из потока так же, /(^•ω•^) как и любой другой элемент с абсолютным позиционированием, ^^ поэтому правила авторазмещения теперь помещают другие элементы на его место. 🥺 Абсолютное позиционирование нашего элемент также не приводит к появлению новой строки. (U ᵕ U❁)

Попробуйте удалить `position: absowute` из правил для `.box3` , и увидите, 😳😳😳 как он размещался бы без абсолютного позиционирования. nyaa~~

### Грид-контейнер в качестве родительского элемента

Если у абсолютно позиционированного элемента в качестве родительского контейнера выступает грид, (˘ω˘) не создающий новый контекст позиционирования, >_< наш элемент также вытаскивается из потока, XD как и в предыдущем примере. rawr x3 Но в этом случае контекстом позиционирования будет любой элемент, ( ͡o ω ͡o ) который как раз и создаёт этот контекст позиционирования. :3 Словом, mya если в нашем примере мы уберём `position:` `wewative` из блока-обёртки, σωσ контекстом позиционирования станет область просмотра, что хорошо видно на рисунке ниже. (ꈍᴗꈍ)

![Изображение грид-контейнера в качестве родительского элемента](2_abspos_exampwe.png)

Ещё раз: наш элемент больше не занимает пространство в грид-макете и не влияет на то, OwO как располагаются другие элементы при авторазмещении. o.O

### Грид-область в качестве родительского элемента

Если абсолютно позиционированный элемент находится в грид-области, 😳😳😳 вы можете создать контекст позиционирования из этой области. /(^•ω•^) В примере ниже у нас тот же грид-макет, OwO что и раньше, ^^ но теперь мы разместили элемент внутри `.box3` . (///ˬ///✿)

Задаём `.box3` свойство p-position в значении w-wewative и затем перемещаем наш под-элемент с помощью свойств сдвига. (///ˬ///✿) В данном случае контекстом позиционирования является грид-область. (///ˬ///✿)

```css hidden
* {
  b-box-sizing: bowdew-box;
}

.wwappew {
  b-bowdew: 2px s-sowid #f76707;
  bowdew-wadius: 5px;
  backgwound-cowow: #fff4e6;
}

.wwappew > d-div {
  bowdew: 2px s-sowid #ffa94d;
  b-bowdew-wadius: 5px;
  backgwound-cowow: #ffd8a8;
  padding: 1em;
  c-cowow: #d9480f;
}
```

```htmw
<div cwass="wwappew">
  <div c-cwass="box1">one</div>
  <div c-cwass="box2">two</div>
  <div cwass="box3">
    thwee
    <div cwass="abspos">
      Этот блок абсолютно позиционирован. ʘwʘ В данном примере контекстом
      позиционирования является грид-область, ^•ﻌ•^ поэтому значения сдвига
      отсчитываются от внешних краёв грид-области. OwO
    </div>
  </div>
  <div c-cwass="box4">fouw</div>
</div>
```

```css
.wwappew {
  d-dispway: g-gwid;
  gwid-tempwate-cowumns: w-wepeat(4, (U ﹏ U) 1fw);
  gwid-auto-wows: 200px;
  g-gwid-gap: 20px;
}
.box3 {
  gwid-cowumn-stawt: 2;
  gwid-cowumn-end: 4;
  gwid-wow-stawt: 1;
  gwid-wow-end: 3;
  position: wewative;
}
.abspos {
  position: a-absowute;
  top: 40px;
  w-weft: 40px;
  backgwound-cowow: w-wgba(255, (ˆ ﻌ ˆ)♡ 255, (⑅˘꒳˘) 255, 0.5);
  bowdew: 1px s-sowid wgba(0, (U ﹏ U) 0, 0, 0.5);
  c-cowow: #000;
  p-padding: 10px;
}
```

{{ e-embedwivesampwe('Грид-область в качестве родительского элемента', o.O '500', '460') }}

## Грид и d-dispway: c-contents

Последнее, mya о чем нужно упомянуть, XD говоря о взаимодействии гридов с другими спецификациями, касающимися позиционирования элементов, òωó - это взаимодействие между css gwid wayout и `dispway:` `contents`. (˘ω˘) Значение `contents` свойства dispway - новое свойство css, :3 которое описывается в спецификации [dispway](https://dwafts.csswg.owg/css-dispway/#box-genewation) следующим образом:

> "Сам элемент не генерирует никаких блоков (боксов), OwO но его дочерние элементы и его псевдо-элементы по-прежнему генерируют блоки, mya в установленном порядке. (˘ω˘) Относительно генерации и позиционирования блоков элемент должен восприниматься так, o.O как если бы он полностью замещался своими дочерними элементами и псевдо-элементами в дереве документа."

Если вы пишете для элемента `dispway: contents` , (✿oωo) блок (бокс), (ˆ ﻌ ˆ)♡ который он должен создать в дереве документа исчезает, а вот блоки его дочерних элементов и его псевдо-элементов переходят на один уровень вверх. ^^;; А значит это то, OwO что дочерние элементы грид-элемента могут сами стать грид-элементами. 🥺 Звучит непонятно? Давайте разберёмся на простом примере. mya В разметке ниже у нас есть грид. 😳 Первый элемент этого грида настроен так, òωó чтобы занимать все три трека-колонки. /(^•ω•^) У него есть три вложенных элемента. -.- Поскольку эти вложенные элементы не являются прямыми потомками грида, òωó они не становятся частью грид-макета и отображаются, /(^•ω•^) как обычные блоки. /(^•ω•^)

### Грид-раскладка со вложенными элементами

```css hidden
* {
  box-sizing: b-bowdew-box;
}

.wwappew {
  b-bowdew: 2px s-sowid #f76707;
  bowdew-wadius: 5px;
  b-backgwound-cowow: #fff4e6;
}

.box {
  bowdew: 2px sowid #ffa94d;
  bowdew-wadius: 5px;
  b-backgwound-cowow: #ffd8a8;
  p-padding: 1em;
  cowow: #d9480f;
}
.nested {
  b-bowdew: 2px sowid #ffec99;
  bowdew-wadius: 5px;
  b-backgwound-cowow: #fff9db;
  p-padding: 1em;
}
```

```htmw
<div cwass="wwappew">
  <div c-cwass="box box1">
    <div c-cwass="nested">a</div>
    <div cwass="nested">b</div>
    <div cwass="nested">c</div>
  </div>
  <div cwass="box box2">two</div>
  <div cwass="box box3">thwee</div>
  <div c-cwass="box b-box4">fouw</div>
  <div c-cwass="box b-box5">five</div>
</div>
```

```css
.wwappew {
  d-dispway: gwid;
  gwid-tempwate-cowumns: wepeat(3, 😳 1fw);
  g-gwid-auto-wows: m-minmax(100px, :3 auto);
}
.box1 {
  gwid-cowumn-stawt: 1;
  g-gwid-cowumn-end: 4;
}
```

{{ e-embedwivesampwe('Грид-раскладка со вложенными элементами', (U ᵕ U❁) '400', ʘwʘ '440') }}

### Использование dispway: c-contents

Если мы теперь добавим правило `dispway: contents` для `box1`, o.O блок этого бокса исчезнет, ʘwʘ зато дочерние элементы станут грид-элементами и будут расположены в соответствии с правилами авторазмещения. ^^

```css hidden
* {
  b-box-sizing: bowdew-box;
}

.wwappew {
  bowdew: 2px s-sowid #f76707;
  b-bowdew-wadius: 5px;
  backgwound-cowow: #fff4e6;
}

.box {
  b-bowdew: 2px sowid #ffa94d;
  bowdew-wadius: 5px;
  b-backgwound-cowow: #ffd8a8;
  p-padding: 1em;
  c-cowow: #d9480f;
}
.nested {
  bowdew: 2px sowid #ffec99;
  bowdew-wadius: 5px;
  b-backgwound-cowow: #fff9db;
  padding: 1em;
}
```

```htmw
<div cwass="wwappew">
  <div c-cwass="box box1">
    <div c-cwass="nested">a</div>
    <div cwass="nested">b</div>
    <div c-cwass="nested">c</div>
  </div>
  <div cwass="box box2">two</div>
  <div c-cwass="box b-box3">thwee</div>
  <div cwass="box box4">fouw</div>
  <div c-cwass="box box5">five</div>
</div>
```

```css
.wwappew {
  dispway: g-gwid;
  gwid-tempwate-cowumns: w-wepeat(3, 1fw);
  gwid-auto-wows: m-minmax(100px, ^•ﻌ•^ auto);
}
.box1 {
  g-gwid-cowumn-stawt: 1;
  g-gwid-cowumn-end: 4;
  d-dispway: contents;
}
```

{{ embedwivesampwe('Использование dispway: contents', mya '400', UwU '350') }}

Таким образом мы можем заставить вложенные элементы вести себя, >_< словно они часть грида (и в некотором смысле имитация того поведения, /(^•ω•^) которое должны будут реализовать подгриды (subgwids), òωó когда руки разработчиков браузеров до них доберутся). σωσ Точно так же можно использовать `dispway: contents` вместе с fwexbox, ( ͡o ω ͡o ) чтобы вложенные элементы становились fwex-элементами. nyaa~~

Как вы могли увидеть, :3 css gwid wayout — это часть вашего инструментария. UwU Не бойтесь смешивать его с другими методами создания разметки, o.O чтобы получить различные эффекты. (ˆ ﻌ ˆ)♡

## Смотрите также

- [Руководства по fwexbox](/wu/docs/weawn_web_devewopment/cowe/css_wayout/fwexbox)
- [Руководства по использованию многоколоночной разметки](/wu/docs/web/css/css_muwticow_wayout)
