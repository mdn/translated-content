---
title: Основные понятия Flexbox
short-title: Основные понятия
slug: Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox
l10n.sourceCommit: 0cc9980e3b21c83d1800a428bc402ae1865326b2
---

{{CSSRef}}

**CSS модуль раскладки Flexible Box**, обычно называемый флексбокс или flexbox или просто flex (флекс), был разработан как модель одномерного-направленного макета и как один из методов распределения пространства между элементами в интерфейсе, с мощными возможностями выравнивания. В этой статье даётся краткое описание основных функций flexbox, которые мы рассмотрим более подробно в остальных руководствах.

Когда мы описываем flexbox как одномерно-направленный, мы имеем в виду, что flexbox имеет дело с макетом в одной плоскости за раз – либо в виде строки, либо в виде столбца. Как альтернативу можно упомянуть двумерную модель CSS Grid Layout, которая управляет и столбцами и строками одновременно.

## Flexbox: две оси

При работе с flexbox нужно мыслить с точки зрения двух осей – главной оси и побочной оси. Главная ось определяется свойством {{cssxref ("flex-direction")}}, а побочная ось проходит перпендикулярно ей. Все, что мы делаем с flexbox, относится к этим осям, поэтому стоит с самого начала понять, как они работают.

### Главная ось

Главная ось определяется свойством `flex-direction`, которая может принимать одно из следующих значений:

- `row`
- `row-reverse`
- `column`
- `column-reverse`

Если вы выберете `row` или `row-reverse`, ваша главная ось будет проходить в горизонтальном направлении **(inline direction)**.

![Если для flex-direction задано значение row, то главная ось проходит в горизонтальном направлении.](basics1.svg)

Если вы выберете `column` или `column-reverse`, ваша главная ось будет проходить в вертикальном направлении **(block direction)**.

![Если для flex-direction задано значение column, то главная ось проходит в вертикальном направлении.](basics2.svg)

### Побочная ось

Побочная ось проходит перпендикулярно главной оси, поэтому, если свойство `flex-direction` (главная ось) задано как `row` или `row-reverse`, побочная ось будет проходить в вертикальном направлении.

![Если для flex-direction задано значение row, то побочная ось проходит в вертикальном направлении.](basics3.svg)

Если свойство `flex-direction` задано как `column` или `column-reverse`, побочная ось будет проходить в горизонтальном направлении.

![Если для flex-direction задано значение column, то поперечная ось проходит в горизонтальном направлении.](basics4.svg)

Понимание того, с какой осью вы работаете (главная или побочная) очень важно для дальнейшего изучения Flexbox.

## Начало и конец строки

Важно понимать, что flexbox не делает никаких предположений о режиме написания документа. Раньше CSS был сильно ориентирован на горизонтальный режим и режим письма слева направо. Современные методы вёрстки охватывают полный диапазон режимов письма, и поэтому мы больше не предполагаем, что строка текста будет начинаться в верхнем левом углу документа и будет проходить по направлению к правой стороне, а новые строки будут появляться одна под другой.

Вы можете прочитать больше о взаимосвязи между flexbox и спецификацией Writing Modes в следующей статье, однако следующее описание должно помочь объяснить, почему мы не говорим о левом, правом, верхнем и нижнем направлениях наших flex-элементов.

Если свойству `flex-direction` задано значение `row` и вы работаете с английским языком, то начало главной оси будет слева, а конец главной оси – справа.

![При работе на английском языке начало главной оси находится слева.](basics5.svg)

Если бы вы работаете с арабским языком, то начало главной оси будет справа, а конец главной оси – слева.

![Для языков с направлением письма справа налево начало главной оси находится справа.](basics6.svg)

В обоих случаях начало побочной оси находится вверху flex контейнера, а конец – внизу, поскольку оба языка имеют режим горизонтальной записи.

Спустя некоторое время становится естественным думать о начале и конце оси, а не о левом и правом краях. Это будет полезно для вас при работе с другими методами, такими как CSS Grid Layout, которые следуют тем же шаблонам.

## Flex контейнер

Область документа, использующая flexbox, называется flex контейнером. Чтобы создать flex контейнер, мы задаём значение `flex` или `inline-flex` для свойства {{cssxref ("display")}} контейнера. Как только мы делаем это, прямые потомки этого контейнера становятся flex элементами. Как и для всех свойств в CSS, некоторые начальные значения уже определены, поэтому при создании flex-контейнера все содержащиеся в нем flex-элементы будут вести себя следующим образом.

- Элементы отображаются в ряд (свойство `flex-direction` по умолчанию имеет значение `row`).
- Позиционирование элементов начинается от начала главной оси.
- Элементы не растягиваются по основной оси, но могут сжиматься.
- Элементы будут растягиваться, чтобы заполнить размер побочной оси.
- Свойству {{cssxref("flex-basis")}} задано значение `auto`.
- Свойству {{cssxref("flex-wrap")}} задано значение `nowrap`.

Результатом этого является то, что все ваши элементы будут выстроены в ряд, используя размер содержимого в качестве их размера на главной оси. Если в контейнере больше элементов, чем можно уместить, они не будут обёрнуты и контейнер будет переполнен. Если некоторые элементы выше других, все элементы будут вытянуты вдоль побочной оси, чтобы заполнить ось в полный размер.

Вы можете увидеть принцип работы в живом примере ниже. Попробуйте отредактировать или добавить дополнительные элементы, чтобы проверить поведение flexbox.

{{EmbedGHLiveSample("css-examples/flexbox/basics/the-flex-container.html", '100%', 480)}}

### Изменение flex-direction

Добавление свойства {{cssxref ("flex-direction")}} в контейнер позволяет нам изменять направление, в котором отображаются наши элементы flex. Установка `flex-direction: row-reverse` сохранит порядок отображения элементов вдоль строки, однако начало и конец строки поменяются местами.

Если изменить значение свойства `flex-direction` на `column`, главная ось изменится, и наши элементы будут отображаются в столбец. При установке параметра `column-reverse`, начало и конец столбца поменяются местами.

В приведённом ниже примере значение свойства `flex-direction` установлено как `row-reverse`. Попробуйте другие значения — `row`, `column` и `column-reverse`, чтобы посмотреть как изменятся элементы контейнера.

{{EmbedGHLiveSample("css-examples/flexbox/basics/flex-direction.html", '100%', 350)}}

## Многострочный флекс-контейнер с flex-wrap

Несмотря на то, что флекс-бокс - это однонаправленная модель, есть возможность завернуть наши флекс-элементы в несколько строк. При этом вы должны рассматривать каждую строку как новый флекс контейнер. Распределение пространства будет происходить на этой конкретной линии, не привязываясь к соседним линиям.

Чтобы включить такое поведение, добавьте параметр {{cssxref("flex-wrap")}} со значением `wrap`. Теперь, как только ваши элементы будут слишком большими для того, чтобы влезать на одну строчку, они будут переноситься на новые строки. Живой пример ниже содержит широкие элементы, у которых общая ширина больше, чем размер контейнера. Так как параметр `flex-wrap` установлен в значение `wrap`, элементы переносятся. Если вы установите значение `nowrap`, то есть в начальное значение, то элементы ужмутся так, чтобы все элементы поместились на одной строке, потому что у них установлено значение, позволяющее им ужиматься при необходимости. Если им запретить ужиматься, или если они не смогут ужаться достаточно сильно, то при установленном значении `nowrap` будет происходить переполнение контейнера.

{{EmbedGHLiveSample("css-examples/flexbox/basics/flex-wrap.html", '100%', 400)}}

Более подробно эту тема разбирается в статье [Разбираемся с обёртыванием Flex элементов](/ru/docs/Web/CSS/CSS_flexible_box_layout/Mastering_wrapping_of_flex_items).

## Краткая запись направления и многострочности: flex-flow

Вы можете указать два свойства `flex-direction` и `flex-wrap` в одном {{cssxref("flex-flow")}}. Первое значение свойства определяет `flex-direction`, второе `flex-wrap`.

В приведённом ниже примере вы можете изменить первое значение на одно из доступных для `flex-direction` - `row`, `row-reverse`, `column` or `column-reverse`, а второе на `wrap` или `nowrap`, чтобы посмотреть как изменятся элементы контейнера.

{{EmbedGHLiveSample("css-examples/flexbox/basics/flex-flow.html", '100%', 400)}}

## Свойства, применяемые к флекс-элементам

Управлять поведением флекс-элементов более детально мы можем с помощью их собственных свойств:

- {{cssxref("flex-grow")}}
- {{cssxref("flex-shrink")}}
- {{cssxref("flex-basis")}}

В этом обзоре мы лишь кратко рассмотрим эти свойства. Чтобы получить более глубокое понимание обратитесь к руководству [Управление соотношением элементов вдоль главной оси (англ.)](/en/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_ratios_of_flex_items_along_the_main_axis).

Чтобы понять как работают эти свойства, прежде нам необходимо разобраться с концепцией **доступного пространства**. Изменяя значения этих флекс свойств, мы влияем на то, как доступное пространство распределяется между нашими элементами. Эта концепция так же важна для выравнивания элементов.

Если наш контейнер шириной 500 пикселей содержит три элемента шириной 100 пикселей каждый, для их размещения нам потребуется пространство шириной в 300 пикселей. Остаётся 200 пикселей свободного пространства. Если мы не изменим исходные значения этих свойств, флексбокс разместит это пространство за последним элементом.

![В этом flex-контейнере остаётся место после размещения элементов.](basics7.svg)

Если вместо этого мы хотим чтобы элементы росли и заполняли собой свободное пространство, нам нужно указать способ распределения оставшегося пространства между элементами. Это как раз то для чего предназначены `flex` свойства.

### Свойство `flex-basis`

Свойство `flex-basis` определяет размер доступного пространства элемента. Начальное значение этого свойства - `auto` - в этом случае браузер проверяет, имеют ли элементы размер. В приведённом выше примере все элементы имеют ширину 100px, и этот размер читается браузером как `flex-basis`.
Если элементы не имеют размера, то для размера `flex-basis` используется размер контента. Вот почему, когда мы просто объявляем `display: flex` на родительском элементе для создания flex-элементов, все элементы перемещаются в ряд и занимают столько места, сколько им нужно для отображения их содержимого.

### Свойство `flex-grow`

Если свойству `flex-grow` присвоено положительное целое число, элементы flex могут увеличиваться вдоль главной оси, начиная от своего значения `flex-basis`. Это приведёт к тому, что элемент растянется и займёт всё доступное пространство на этой оси — или его часть, если другим элементам также разрешено расти.

Если мы присвоим всем элементам в примере выше значение `flex-grow`, равное 1, то всё доступное пространство в контейнере flex будет равномерно распределено между нашими элементами, и они растянутся, чтобы заполнить контейнер вдоль главной оси.

Свойство `flex-grow` можно использовать для распределения пространства пропорционально. Если мы дадим первому элементу значение `flex-grow`, равное 2, а другим элементам — значение 1, то первый элемент получит 2 части (100px из 200px в примере выше), а остальные два элемента — по 1 части (по 50px из общих 200px).

### Свойство `flex-shrink`

В то время как свойство `flex-grow` управляет распределением доступного пространства вдоль главной оси, другое свойство – `flex-shrink` – контролирует то, как элементы будут уменьшаться в случае, если доступного пространства окажется недостаточно. Если в контейнере недостаточно места для размещения всех элементов и свойство `flex-shrink` задано положительным числом, элемент может стать меньше, чем его значение `flex-basis`. Как и в случае с `flex-grow`, можно присвоить разные значения, чтобы один элемент сжимался быстрее других — элемент с более высоким значением `flex-shrink` будет уменьшаться быстрее, чем соседние элементы в том же контейнере с меньшими значениями.

При вычислении фактической величины сжатия будет учитываться минимальный размер элемента. Это означает, что поведение `flex-shrink` может казаться менее предсказуемым по сравнению с `flex-grow`. Поэтому мы более подробно рассмотрим работу этого алгоритма в статье [Управление соотношением элементов вдоль главной оси (англ.)](/en/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_ratios_of_flex_items_along_the_main_axis).

> [!NOTE]
> Обратите внимание, что значения для `flex-grow` и `flex-shrink` задаются пропорционально (в долях). Обычно, если всем элементам задано `flex: 1 1 200px`, а затем мы хотим, чтобы один элемент рос в два раза быстрее, мы задаём ему `flex: 2 1 200px`. Однако, если нужно, можно использовать как `flex: 10 1 200px`, так и `flex: 20 1 200px`.

### Краткая запись значений флекс-свойств

Свойства `flex-grow`, `flex-shrink` и `flex-basis` очень редко используются по отдельности; вместо этого их объединяют в сокращённую запись {{cssxref("flex")}}. Сокращённая запись `flex` позволяет задать все три значения в следующем порядке — `flex-grow`, `flex-shrink`, `flex-basis`.

В примере ниже можно протестировать различные значения сокращённой записи `flex`; помните, что первое значение — это `flex-grow`. Если оно больше нуля, элемент может расти. Второе значение — `flex-shrink`: при положительном значении элементы могут сжиматься, но только при условии, что их суммарный размер выходит за пределы главной оси. Последнее значение — `flex-basis` — это исходное значение, от которого элементы «растут» или «сжимаются».

{{EmbedGHLiveSample("css-examples/flexbox/basics/flex-properties.html", '100%', 510)}}

Существуют также предопределённые сокращённые значения, которые покрывают большинство сценариев. Вы часто встретите их в учебных материалах, и в большинстве случаев их будет достаточно. Предопределённые значения представлены ниже:

- `flex: initial`
- `flex: auto`
- `flex: none`
- `flex: <positive-number>`

Значение `initial` — это [CSS-wide keyword (англ.)](/en-US/docs/Web/CSS/CSS_Values_and_Units/CSS_data_types#css-wide_keywords), которое представляет собой исходное значение свойства. Установка `flex: initial` сбрасывает элемент к начальным значениям трёх основных свойств, что эквивалентно записи `flex: 0 1 auto`. Начальное значение `flex-grow` равно `0`, поэтому элементы не будут увеличиваться больше, чем их размер `flex-basis`. Начальное значение `flex-shrink` равно `1`, поэтому элементы могут сжиматься при необходимости, чтобы не выходить за пределы контейнера. Начальное значение `flex-basis` равно `auto`. Элементы будут использовать либо установленный размер по главной оси, либо размер, определяемый их содержимым.

Использование `flex: auto` эквивалентно `flex: 1 1 auto`; это похоже на `flex: initial`, за исключением того, что элементы могут как увеличиваться, чтобы заполнить контейнер, так и сжиматься при необходимости.

Использование `flex: none` создаёт абсолютно негибкие flex-элементы. Это эквивалентно записи `flex: 0 0 auto`. Элементы не могут ни расти, ни сжиматься и будут размещены с использованием flexbox с `flex-basis: auto`.

Сокращённые записи, которые часто можно встретить в учебниках, — это `flex: 1` или `flex: 2` и т.п. Это эквивалентно записям `flex: 1 1 0` или `flex: 2 1 0` и т.д. Элементы получают минимальный размер благодаря `flex-basis: 0`, а затем пропорционально увеличиваются, чтобы заполнить доступное пространство. В этом случае значение `flex-shrink: 1` избыточно, так как элементы явно начинаются с минимального размера. Это означает, что у элементов изначально отсутствует возможность превысить размер flex-контейнера.

Попробуйте эти сокращённые значения в интерактивном примере ниже.

{{EmbedGHLiveSample("css-examples/flexbox/basics/flex-shorthands.html", '100%', 510)}}

## Выравнивание элементов и распределение свободного пространства между ними

Ключевая особенность flexbox — возможность выравнивать элементы по главной и поперечной осям, а также управлять распределением свободного пространства между flex-элементами. Обратите внимание, что эти свойства задаются на flex-контейнере, а не на самих элементах.

### Свойство `align-items`

Свойство {{cssxref("align-items")}} выравнивает элементы вдоль поперечной оси.

Начальное значение этого свойства — `stretch`, и именно поэтому flex-элементы по умолчанию растягиваются на высоту flex-контейнера (или на ширину, если `flex-direction` установлен в значение `column` или `column-reverse`). Эта высота может определяться самым высоким элементом в контейнере или размером, заданным самому flex-контейнеру.

Вместо этого вы можете задать `align-items: flex-start` или просто `align-items: start`, чтобы элементы выравнивались по началу контейнера; аналогично можно задать значения `flex-end` или просто `end`, чтобы выровнять их по концу flex-контейнера; также можно присвоить значение `center`, чтобы выровнять элементы по центру flex-контейнера. Попробуйте это в интерактивном примере ниже — в нём специально задана высота flex-контейнера, чтобы вы могли видеть, как элементы могут перемещаться внутри контейнера. Посмотрите, что происходит при установке значения свойства `align-items` в:

- `stretch`
- `flex-start`
- `flex-end`
- `start`
- `end`
- `center`
- `baseline`
- `last baseline`

{{EmbedGHLiveSample("css-examples/flexbox/basics/align-items.html", '100%', 520)}}

Свойство `align-items` задаётся на flex-контейнере и влияет на все flex-элементы. Если вы хотите выровнять отдельный элемент иначе, чем остальные, можно специально для него задать свойство `align-self`.

### Свойство `justify-content`

Свойство {{cssxref("justify-content")}} используется для выравнивания элементов вдоль главной оси, направление которой задано свойством `flex-direction`. Начальное значение — `flex-start`, которое выравнивает элементы по началу контейнера, но вы также можете задать значение `flex-end`, чтобы выровнять их по концу flex-контейнера, или `center`, чтобы выровнять их по его центру.

Можно также использовать значение `justify-content: space-between`, чтобы занять всё оставшееся пространство после размещения элементов и равномерно распределить его между элементами, создавая одинаковый промежуток пространства между каждой парой элементов. Чтобы создать равные промежутки справа и слева (или сверху и снизу для колонок) у каждого элемента, используйте значение `space-around`. При `justify-content: space-around` свободное пространство вдоль главной оси делится так, что между элементами получается полная доля, а у краёв контейнера — половина доли. Чтобы создать одинаковое пространство вокруг каждого элемента вдоль главной оси, используйте значение `space-evenly`. При значении `space-evenly` элементы имеют одинаковое расстояние как между собой, так и от краёв контейнера.

Попробуйте следующие значения свойства `justify-content` в интерактивном примере:

- `start`
- `end`
- `left`
- `right`
- `normal`
- `flex-start`
- `flex-end`
- `center`
- `space-around`
- `space-between`
- `space-evenly`
- `stretch`

{{EmbedGHLiveSample("css-examples/flexbox/basics/justify-content.html", '100%', 380)}}

Статья [Выравнивание элементов во Flex контейнере](/ru/docs/Web/CSS/CSS_flexible_box_layout/Aligning_items_in_a_flex_container) рассматривает эти свойства более подробно, с целью сформировать лучшее понимание того, как они работают. Тем не менее, эти базовые примеры полезны в большинстве случаев.

### Свойство `justify-items`

Свойство [`justify-items`](/ru/docs/Web/CSS/justify-items) игнорируется в раскладках flexbox. // РАСКЛАДКА???

### Свойства `place-items` и `place-content`

Свойство [`place-items`](/ru/docs/Web/CSS/place-items)  является шорткатом сразу для двух свойств – `align-items` и `justify-items`. Если оно установлено на flex-контейнере, это свойство задаёт выравнивание по перекрёстной оси, но не влияет на распределение по основной оси, так как свойство `justify-items` во flexbox игнорируется.

Существует другой шорткат, [`place-content (англ.)`](/en-US/docs/Web/CSS/place-content), который задаёт свойства {{cssxref("align-content")}} и `justify-content`. Свойство `align-content` действует только на flex-контейнеры с переносом (flex-wrap), и обсуждается в статье [Выравнивание элементов во Flex контейнере](/ru/docs/Web/CSS/CSS_flexible_box_layout/Aligning_items_in_a_flex_container).

## Следующие шаги

После прочтения этой статьи вы должны понимать базовые возможности flexbox. В следующей статье мы рассмотрим [как эта спецификация связана с другими частями CSS (англ.)](/en-US/docs/Web/CSS/CSS_flexible_box_layout/Relationship_of_flexbox_to_other_layout_methods).
