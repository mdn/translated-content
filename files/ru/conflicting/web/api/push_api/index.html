---
title: Использование Push API
slug: conflicting/Web/API/Push_API
translation_of: Web/API/Push_API
translation_of_original: Web/API/Push_API/Using_the_Push_API
original_slug: Web/API/Push_API/Using_the_Push_API
---
<p class="summary"><span class="seoSummary">W3C <a href="/en-US/docs/Web/API/Push_API">Push API</a> предоставляет некоторую захватывающую новую функциональность для разработчиков для использования в web-приложениях: эта статья предлагает вводную информацию о том, как настроить Push-уведомления и управлять ими, с помощью простого демо.</span></p>

<p>Возможность посылать сообщения или уведомления от сервера клиенту в любое время — независимо от того, активно приложение или нет — было прерогативой нативных приложений некоторое время, и наконец пришло в Web! Поддерживается большинства возможностей Push сейчас возможна в браузерах Firefox 43+ и Chrome 42+ на настольных компьютерах, мобильные платформы, возможно, скоро присоединятся. {{domxref("PushMessageData")}} на данный момент экспериментально поддерживаются только в Firefox Nightly (44+), и реализация может меняться.</p>

<div class="note">
<p><strong>Примечание</strong>: Ранние версии Firefox OS использовали проприетарную версию этого API вызывая <a href="/en-US/docs/Web/API/Simple_Push_API">Simple Push</a>. Считается устаревшим по стандартам Push API.</p>
</div>

<h2 id="Демо_основы_простого_сервера_чат-приложения">Демо: основы простого сервера чат-приложения</h2>

<p>Демо, которые мы создали, представляет начальное описание простого чат-приложения. Оно представляет собой форму, в которую вводятся данные, и кнопку для подписки на push-сообщения . Как только кнопка будет нажата, вы подпишитесь на push-сообщения, ваши данные будут записаны на сервере, а отправленное push-сообщение сообщит всем текущим подписчикам, что кто-то подписался.</p>

<p>На данном этапе, имя нового подписчика появится в списке подписчиков, вместе с текстовым полем и кнопкой рассылки, чтобы позволить подписчику отправить сообщение.</p>

<p><img alt="" src="https://mdn.mozillademos.org/files/11823/push-api-demo.png" style="border: 1px solid black; display: block; height: 406px; margin: 0px auto; width: 705px;"></p>

<p>Чтобы запустить демо, следуйте инструкциям на странице <a href="https://github.com/chrisdavidmills/push-api-demo">push-api-demo README</a>. Заметьте, что серверная компонента всё ещё нуждается в небольшой доработке для запуска в Chrome и в общем запускается более разумным путём. Но аспекты Push всё ещё могут быть полностью понятны; мы углубимся в это после того, как просмотрим технологии в процессе.</p>

<h2 id="Обзор_технологии">Обзор технологии</h2>

<p>Эта секция предоставляет описание того, какие технологии участвуют в примере.</p>

<p>Web Push-сообщения это часть семейства технологий <a href="/en-US/docs/Web/API/Service_Worker_API">сервис воркеров</a>; в первую очередь, для получения push-сообщений сервис воркер должен быть активирован на странице. Сервис воркер получает push-сообщения, и затем вы сами решаете, как уведомить об этом страницу. Вы можете:</p>

<ul>
 <li>Отправить <a href="/en-US/docs/Web/API/Notifications_API">Web-уведомление</a>, которое вызовет всплытие системного уведомления. Для этого необходимо подтверждение разрешения на отправку push-сообщений.</li>
 <li>Отправить сообщение обратно главной странице через {{domxref("MessageChannel")}}.</li>
</ul>

<p>Обычно необходима комбинация этих двух решений; демо внизу включает пример обоих.</p>

<div class="note">
<p><strong>Примечание</strong>: вам необходим некоторый код, запущенный на сервере, для управления конечной точкой/шифрованием данных и отправки запросов push-сообщений. В нашем демо мы собрали на скорую руку сервер, используя <a href="https://nodejs.org/">NodeJS</a>.</p>
</div>

<p>Сервис воркер так же должен подписаться на сервис push-сообщений. Каждой сессии предоставляется собственная уникальная конечная точка, когда она подписывается на сервис push-сообщений. Эта конечная точка получается из свойства  ({{domxref("PushSubscription.endpoint")}}) объекта подписчика. Она может быть отправлена серверу и использоваться для пересылки сообщений активному сервис воркеру сессии. Каждый браузер имеет свой собственный сервер push-сообщений для  управления отправкой push-сообщений.</p>

<h3 id="Шифрование">Шифрование</h3>

<div class="note">
<p><strong>Примечание</strong>: Для интерактивного краткого обзора, попробуйте JR Conlin's <a href="https://jrconlin.github.io/WebPushDataTestPage/">Web Push Data Encryption Test Page</a>.</p>
</div>

<p>Для отправки данных с помощью push-сообщений необходимо шифрование. Для этого необходим публичный ключ, созданный с использованием метода  {{domxref("PushSubscription.getKey()")}}, который основывается на некотором комплексе механизмов шифрования, которые выполняются на стороне сервера; читайте <a href="https://tools.ietf.org/html/draft-ietf-webpush-encryption-01">Message Encryption for Web Push</a>. Со временем появятся библиотеки для управления генерацией ключей и шифрованием/дешифрованием push-сообщений; для этого демо мы используем Marco Castelluccio's NodeJS <a href="https://github.com/marco-c/web-push">web-push library</a>.</p>

<div class="note">
<p><strong>Примечание</strong>: Есть так же другая библиотека для управления шифрованием с помощью Node и Python, смотри <a href="https://github.com/martinthomson/encrypted-content-encoding">encrypted-content-encoding</a>.</p>
</div>

<h3 id="Обобщение_рабочего_процесса_Push">Обобщение рабочего процесса Push</h3>

<p>Общие сведения ниже это то, что необходимо для реализации push-сообщений. Вы можете найти больше информации о некоторых частях демо в последующих частях.</p>

<ol>
 <li>Запрос на разрешение web-уведомлений или что-то другое, что вы используете и для чего необходимо разрешение.</li>
 <li>Регистрация сервис воркера для контроля над страницей с помощью вызова {{domxref("ServiceWorkerContainer.register()")}}.</li>
 <li>Подписка на сервис push-уведомлений с помощью {{domxref("PushManager.subscribe()")}}.</li>
 <li>Запрашивание конечной точки, соответствующей подписчику, и генерация публичного ключа клиента ({{domxref("PushSubscription.endpoint")}} и {{domxref("PushSubscription.getKey()")}}. Заметьте, что <code>getKey()</code> на данный момент экспериментальная технология и доступна только в Firefox.)</li>
 <li>Отправка данных на сервер, чтобы тот мог присылать push-сообщения, когда необходимо. Это демо использует {{domxref("XMLHttpRequest")}}, но вы можете использовать <a href="/en-US/docs/Web/API/Fetch_API">Fetch</a>.</li>
 <li>Если вы используете <a href="/en-US/docs/Web/API/Channel_Messaging_API">Channel Messaging API</a> для связи с сервис воркером, установите новый канал связи ({{domxref("MessageChannel.MessageChannel()")}}) и отправьте <code>port2</code> сервис воркеру с помощью вызова {{domxref("Worker.postMessage()")}} для того, чтобы открыть канал связи. Вы так же должны настроить обработчик ответов на сообщения, которые будут отправляться обратно с сервис воркера.</li>
 <li>На стороне сервера сохраните конечную точку и все остальные необходимые данные, чтобы они были доступны, когда будет необходимо отправить push-сообщение добавленному подписчику (мы используем простой текстовый файл, но вы можете использовать базу данных или все что угодно на ваш вкус). В приложении на продакшене убедитесь, что скрываете эти данные, так что злоумышленники не смогут украсть конечную точку и разослать спам подписчикам в push-сообщениях.</li>
 <li>Для отправки push-сообщений необходимо отослать HTTP <code>POST</code> конечному URL. Запрос должен включать <code>TTL</code> заголовок, который ограничивает время пребывания сообщения в очереди, если пользователь не в сети. Для добавления полезной информации в запросе, необходимо зашифровать её (что включает публичный ключ клиента). В нашем примере мы используем <a href="https://github.com/marco-c/web-push">web-push</a> модуль, который управляет всей тяжёлой работой.</li>
 <li>Поверх в сервис воркере настройте обработчик событий <code>push</code> для ответов на полученные push-сообщения.
  <ol>
   <li>Если вы хотите отвечать отправкой сообщения канала обратно основному контексту (смотри шаг 6), необходимо сначала получить ссылку на <code>port2,</code> который был отправлен контексту сервис воркера ({{domxref("MessagePort")}}). Это доступно в объекте  {{domxref("MessageEvent")}}, передаваемого обработчику <code>onmessage </code>({{domxref("ServiceWorkerGlobalScope.onmessage")}}). Конкретнее, он находится в свойстве <code>ports</code>, индекс 0. Когда это сделано, вы можете отправить сообщение обратно <code>port1</code>, используя {{domxref("MessagePort.postMessage()")}}.</li>
   <li>Если вы хотите ответить запуском системного уведомления, вы можете сделать это, вызвав {{domxref("ServiceWorkerRegistration.showNotification()")}}. Заметьте, что в нашем коде мы вызываем его внутри метода {{domxref("ExtendableEvent.waitUntil()")}} — это продлевает время жизни события до момента запуска уведомления и гарантирует, что метод showNotification будет завершён полностью.<span id="cke_bm_307E" class="hidden"> </span></li>
  </ol>
 </li>
</ol>

<h2 id="Сборка_демо">Сборка демо</h2>

<p>Давайте пройдёмся по коду для демо, чтобы понять, как все работает.</p>

<h3 id="HTML_и_CSS">HTML и CSS</h3>

<p>Нет ничего примечательного в HTML и CSS демо; HTML содержит простую форму для ввода данных для входа в чат, кнопку для подписки на push-уведомления и двух списков, в которых перечислены подписчики и сообщения чата. После подписки появляются дополнительные средства для того, чтобы пользователь мог ввести сообщение в чат.</p>

<p>CSS был оставлен очень минимальным, чтобы не отвлекать от объяснения того, как функционируют Push API.</p>

<h3 id="Основной_файл_JavaScript">Основной файл JavaScript</h3>

<p> JavaScript очевидно намного более существенный. Давайте взглянем на основной файл JavaScript.</p>

<h4 id="Переменные_и_начальные_настройки">Переменные и начальные настройки</h4>

<p>Для начала определим некоторые переменные, которые будем использовать в нашем приложении:</p>

<pre class="brush: js">var isPushEnabled = false;
var useNotifications = false;

var subBtn = document.querySelector('.subscribe');
var sendBtn;
var sendInput;

var controlsBlock = document.querySelector('.controls');
var subscribersList = document.querySelector('.subscribers ul');
var messagesList = document.querySelector('.messages ul');

var nameForm = document.querySelector('#form');
var nameInput = document.querySelector('#name-input');
nameForm.onsubmit = function(e) {
  e.preventDefault()
};
nameInput.value = 'Bob';</pre>

<p>Сначала нам необходимо создать две булевы переменные, для того чтобы отслеживать подписку на push-сообщения и подтверждение разрешения на рассылку уведомлений.</p>

<p>Далее, мы перехватываем ссылку на {{htmlelement("button")}} подписки/отписки и задаём переменные для сохранения ссылок на наши кнопку отправки сообщения/ввода (который создастся только после успешной подписки).<br>
 <br>
 Следующие переменные перехватывают ссылки на три основные {{htmlelement("div")}} элемента, так что мы можем включить в них элементы (к примеру, когда появится кнопка <em>Отправки Сообщения Чата</em> или сообщение появится в <em>списке сообщений</em>).</p>

<p>Наконец, мы берем ссылки на нашу форму выбора имени и элемент {{htmlelement("input")}}, присваиваем входу значение по умолчанию и используем <code><a href="/en-US/docs/Web/API/Event/preventDefault">preventDefault()</a></code>, чтобы остановить отправку формы, которая будет отправлена нажатием кнопки return.</p>

<p>Далее мы запрашиваем разрешение на отправку веб-уведомлений, используя {{domxref("Notification.requestPermission","requestPermission()")}}:</p>

<pre class="brush: js">Notification.requestPermission();</pre>

<p>Теперь мы запускаем участок кода, запускающий <code><a href="/en-US/docs/Web/API/GlobalEventHandlers/onload">onload</a></code> для процесса инициализации приложения при его первой загрузке. Прежде всего, мы добавляем слушатель события click к кнопке подписки/отписки, который запускает нашу функцию <code>unsubscribe()</code>, если мы уже подписаны (<code>isPushEnabled</code> равно <code>true</code>), и <code>subscribe()</code>. иначе:</p>

<pre class="brush: js">window.addEventListener('load', function() {
  subBtn.addEventListener('click', function() {
    if (isPushEnabled) {
      unsubscribe();
    } else {
      subscribe();
    }
  });</pre>

<p>Далее мы проверяем, поддерживаются ли работники служб. Если да, то мы регистрируем рабочий сервис с помощью {{domxref("ServiceWorkerContainer.register()")}} и запускаем нашу функцию <code>initialiseState()</code>. Если нет, мы выдаем сообщение об ошибке в консоль.</p>

<pre class="brush: js">  // Проверьте, поддерживаются ли работники служб, если да, 
  // то постепенно улучшайте и добавляйте поддержку push-сообщений, 
  // в противном случае продолжайте работать без неё.

  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js').then(function(reg) {
      if(reg.installing) {
        console.log('Service worker installing');
      } else if(reg.waiting) {
        console.log('Service worker installed');
      } else if(reg.active) {
        console.log('Service worker active');
      }

      initialiseState(reg);
    });
  } else {
    console.log('Service workers aren\'t supported in this browser.');
  }
  });
</pre>

<p>Следующей в исходном коде является функция <code>initialiseState()</code> - полный прокомментированный код смотрите в <a href="https://github.com/chrisdavidmills/push-api-demo/blob/gh-pages/main.js"><code>initialiseState()</code> источнике на Github</a> (мы не повторяем его здесь для краткости)</p>.

<p><code>initialiseState()</code> сначала проверяет, поддерживаются ли уведомления на рабочих службах, затем устанавливает переменную <code>useNotifications</code> в <code>true</code>, если да. Далее он проверяет, разрешены ли указанные уведомления пользователем и поддерживаются ли push-сообщения, и реагирует соответствующим образом на каждое из них.</p>

<p>И наконец, он использует {{domxref("ServiceWorkerContainer.ready()")}} для ожидания, пока сервисный работник не станет активным и не будет готов начать выполнять действия. Как только обещание разрешается, мы получаем нашу подписку на push-сообщения с помощью свойства {{domxref("ServiceWorkerRegistration.pushManager")}}, которое возвращает объект {{domxref("PushManager")}}, который мы затем вызываем {{domxref("PushManager.getSubscription()")}}. Как только это второе внутреннее обещание разрешится, мы включим кнопку подписки/отписки (<code>subBtn.disabled = false;</code>) и проверим, что у нас есть объект подписки для работы.</p>

<p>Если да, то мы уже подписаны. Это возможно, когда приложение не открыто в браузере; работник службы может оставаться активным в фоновом режиме. Если мы подписаны, мы обновляем пользовательский интерфейс, чтобы показать, что мы подписаны, обновляя ярлык кнопки, затем мы устанавливаем <code>isPushEnabled</code> в <code>true</code>, берем конечную точку подписки из {{domxref("PushSubscription.endpoint")}}, генерируем открытый ключ с помощью {{domxref("PushSubscription.getKey()")}} и запускаем нашу функцию <code>updateStatus()</code>, которая, как вы увидите позже, взаимодействует с сервером.</p>.

<p>В качестве дополнительного бонуса мы создаем новый {{domxref("MessageChannel")}} с помощью конструктора {{domxref("MessageChannel.MessageChannel()")}}, получаем ссылку на активный рабочий сервис с помощью {{domxref("ServiceworkerRegistration.active")}}, затем устанавливаем канал между основным контекстом браузера и контекстом рабочего сервиса с помощью {{domxref("Worker.postMessage()")}}. Контекст браузера получает сообщения на {{domxref("MessageChannel.port1")}}; Всякий раз, когда это происходит, мы запускаем функцию <code>handleChannelMessage()</code>, чтобы решить, что делать с этими данными (см. раздел {{anch("Обработка сообщений канала, отправленных от работника службы")}}).</p>

<h4 id="Subscribing_and_unsubscribing">Подписка и отписка</h4>

<p>Перейдем к рассмотрению функций <code>subscribe()</code> и <code>unsubscribe()</code>, используемых для подписки/отписки на службу push-уведомлений.</p>

<p>В случае подписки мы снова проверяем, что наш сервисный работник активен и готов, вызывая {{domxref("ServiceWorkerContainer.ready()")}}. Когда обещание разрешится, мы подписываемся на сервис с помощью {{domxref("PushManager.subscribe()")}}. Если подписка прошла успешно, мы получаем объект {{domxref("PushSubscription")}}, извлекаем из него конечную точку подписки и генерируем открытый ключ (снова {{domxref("PushSubscription.endpoint")}} и {{domxref("PushSubscription.getKey()")}}) и передаем их в нашу функцию <code>updateStatus()</code> вместе с типом обновления (<code>subscribe</code>), чтобы отправить необходимые данные на сервер.</p>.

<p>Мы также внесем необходимые изменения в состояние приложения (установим <code>isPushEnabled</code> в <code>true</code>) и пользовательский интерфейс (включим кнопку подписки/отписки и установим текст ее метки, чтобы показать, что при следующем нажатии она отменит подписку)</p>.

<p>Функция <code>unsubscribe()</code> довольно похожа по структуре, но в основном она делает противоположное; Наиболее заметное отличие заключается в том, что он получает текущую подписку, используя {{domxref("PushManager.getSubscription()")}}, и когда обещание разрешается, он отписывается, используя {{domxref("PushSubscription.unsubscribe()")}}.</p>.

<p>В обеих функциях также предусмотрена соответствующая обработка ошибок. </p>

<p>Для краткости мы покажем только код <code>subscribe()</code> ниже; смотрите полный <a href="https://github.com/chrisdavidmills/push-api-demo/blob/gh-pages/main.js">код подписки/отписки</a> на Github</a>.</p>

<pre class="brush: js">function subscribe() {
  // Отключите кнопку, чтобы ее нельзя было изменить, пока
  // мы обрабатываем запрос на разрешение

  subBtn.disabled = true;

  navigator.serviceWorker.ready.then(function(reg) {
    reg.pushManager.subscribe({userVisibleOnly: true})
      .then(function(subscription) {
        // Подписка прошла успешно
        isPushEnabled = true;
        subBtn.textContent = 'Отписаться от Push Messaging';
        subBtn.disabled = false;

        // Обновление статуса подписки текущего пользователя на сервере, 
        // чтобы другие пользователи могли знать, что он подписан.
        var endpoint = subscription.endpoint;
        var key = subscription.getKey('p256dh');
        updateStatus(endpoint,key,'subscribe');
      })
      .catch(function(e) {
        if (Notification.permission === 'denied') {
          // Пользователь отклонил уведомления, 
          // или нам не удалось подписаться и пользователю необходимо 
          // вручную изменить разрешение на уведомление, 
          // чтобы подписаться на push-сообщения.
          console.log('Разрешение на уведомления было отклонено');

        } else {
          // Возникла проблема с подпиской, часто это может быть связано 
          // с проблемой или отсутствием gcm_sender_id и/или gcm_user_visible_only
          console.log('Не удалось подписаться на push.', e);
          subBtn.disabled = false;
          subBtn.textContent = 'Подписаться на Push Messaging';
        }
      });
  });
}</pre>

<h4 id="Updating_the_status_in_the_app_and_server">Обновление статуса в приложении и на сервере</h4>

<p>Следующей функцией в нашем основном JavaScript является <code>updateStatus()</code>, которая обновляет пользовательский интерфейс для отправки сообщений чата при подписке/отписке и отправляет запрос на обновление этой информации на сервер.</p>

<p>Эта функция выполняет одно из трех различных действий, в зависимости от значения параметра <code>statusType</code>, переданного в нее:</p>

<ul>
 <li><code>subscribe</code>: Кнопка и текстовый ввод для отправки сообщений чата создаются и вставляются в пользовательский интерфейс, а на сервер через XHR отправляется объект, содержащий тип статуса (<code>subscribe</code>), имя пользователя подписчика, конечную точку подписки и открытый ключ клиента.</li>
 <li><code>отказаться от подписки</code>: В принципе, это работает противоположно подписке - элементы пользовательского интерфейса чата удаляются, а на сервер отправляется объект, сообщающий, что пользователь отписался.</li>
 <li><code>init</code>: Он запускается при первой загрузке/инициализации приложения - создает элементы пользовательского интерфейса чата и отправляет объект на сервер, чтобы сообщить ему, что пользователь повторно инициализировался (перезагрузился)</li>.
</ul>

<p>Для краткости мы не включили весь список функций. Изучите <a href="https://github.com/chrisdavidmills/push-api-demo/blob/gh-pages/main.js">полный код <code>updateStatus()</code> на Github</a>.</p>

<h4 id="Handling_channel_messages_sent_from_the_service_worker">Обработка сообщений канала, отправленных от сервисного работника</h4>

<p>Как упоминалось ранее, когда <a href="/en-US/docs/Web/API/Channel_Messaging_API">сообщение канала</a> получено от рабочего сервиса, для его обработки вызывается наша функция <code>handleChannelMessage()</code>. Это делается нашим обработчиком события {{event("message")}}, {{domxref("channel.port1.onmessage")}}:</p>.

<pre class="brush: js">channel.port1.onmessage = function(e) {
  handleChannelMessage(e.data);
}</pre>

<p>Это происходит, когда <a href="https://github.com/chrisdavidmills/push-api-demo/blob/gh-pages/sw.js#L8">работник службы</a> отправляет сообщение по каналу</a>.</p>

<p>Функция <code>handleChannelMessage()</code> выглядит следующим образом:</p>

<pre class="brush: js">function handleChannelMessage(data) {
  if(data.action === 'subscribe' || data.action === 'init') {
    var listItem = document.createElement('li');
    listItem.textContent = data.name;
    subscribersList.appendChild(listItem);
  } else if(data.action === 'unsubscribe') {
    for(i = 0; i &lt; subscribersList.children.length; i++) {
      if(subscribersList.children[i].textContent === data.name) {
        subscribersList.children[i].parentNode.removeChild(subscribersList.children[i]);
      }
    }
    nameInput.disabled = false;
  } else if(data.action === 'chatMsg') {
    var listItem = document.createElement('li');
    listItem.textContent = data.name + ": " + data.msg;
    messagesList.appendChild(listItem);
    sendInput.value = '';
  }
}</pre>

<p>Что здесь происходит, зависит от того, какое значение установлено в свойстве <code>action</code> объекта <code>data</code>:</p>

<ul>
 <li><code>subscribe</code> или <code>init</code> (как при запуске, так и при перезапуске, в данном примере нам нужно сделать одно и то же): Создается элемент {{htmlelement("li")}}, его текстовое содержимое устанавливается в <code>data.name</code> (имя подписчика), и он добавляется в список подписчиков (простой элемент {{htmlelement("ul")}}), чтобы была визуальная информация о том, что подписчик (вновь) присоединился к чату.</li>.
 <li><code>отказаться от подписки</code>: Мы пройдемся по дочерним элементам списка подписчиков, найдем узел, текстовое содержимое которого равно <code>data.name</code> (имя отписавшегося), и удалим этот узел, чтобы обеспечить визуальную обратную связь о том, что кто-то отписался.</li>
 <li><code>chatMsg</code>: Аналогично первому случаю, создается элемент {{htmlelement("li")}}, его текстовое содержимое устанавливается в <code>data.name + ":  + data.msg</code> (так, например, "Chris: Это мое сообщение"), и оно добавляется в список сообщений чата; вот как сообщения чата появляются в пользовательском интерфейсе для каждого пользователя.</li>
</ul>

<div class="note">
<p><strong>Примечание</strong>: Мы должны передать данные обратно в основной контекст перед обновлением DOM, потому что рабочие службы не имеют доступа к DOM. Вы должны знать об ограничениях сервисных работников, прежде чем пытаться пользоваться их услугами. Читайте <a href="/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers">Использование рабочих служб</a> для более подробной информации.</p>
</div>

<h4 id="Sending_chat_messages">Отправка сообщений чата</h4>

<p>Когда нажимается кнопка <em>Отправить сообщение чата</em>, содержимое связанного текстового поля отправляется в виде сообщения чата. Для этого используется <a href="https://github.com/chrisdavidmills/push-api-demo/blob/gh-pages/main.js"><code>sendChatMessage()</code> функция</a> (опять же, для краткости не показана полностью). Это работает аналогично различным частям функции <code>updateStatus()</code> (см. {{anch("Обновление статуса в приложении и на сервере")}}) - мы получаем конечную точку и открытый ключ через объект {{domxref("PushSubscription")}}, который сам извлекается через {{domxref("ServiceWorkerContainer.ready()")}} и {{domxref("PushManager.subscribe()")}}. Они отправляются на сервер через {{domxref("XMLHttpRequest")}} в объекте сообщения, вместе с именем подписавшегося пользователя, сообщением чата, которое нужно отправить, и <code>statusType</code> <code>chatMsg</code>.</p>.

<h3 id="The_server">Сервер</h3>

<p>Как упоминалось выше, нам нужен компонент на стороне сервера в нашем приложении, чтобы хранить данные о подписке и отправлять push-сообщения, когда происходят обновления. Мы собрали быстрый и грязный сервер, используя <a href="http://nodejs.org/">NodeJS</a> (<code><a href="https://github.com/chrisdavidmills/push-api-demo/blob/gh-pages/server.js">server.js</a></code>), который обрабатывает XHR-запросы, отправленные нашим JavaScript-кодом на стороне клиента.</p>

<p>Для хранения информации о подписке используется текстовый файл (<code><a href="https://github.com/chrisdavidmills/push-api-demo/blob/gh-pages/endpoint.txt">endpoint.txt</a></code>); этот файл начинается с пустого места. Существует четыре различных типа запросов, обозначаемых свойством <code>statusType</code> объекта, передаваемого в запросе; они такие же, как и те, которые понимаются на стороне клиента, и выполняют необходимые действия сервера для той же ситуации. Вот что каждый из них означает в контексте сервера:</p>

<ul>
 <li><code>subscribe</code>: Сервер добавляет данные нового подписчика в хранилище данных подписки (<code><a href="https://github.com/chrisdavidmills/push-api-demo/blob/gh-pages/endpoint.txt">endpoint.txt</a></code>), включая конечную точку, а затем отправляет push-сообщение всем конечным точкам, которые он сохранил, чтобы сообщить каждому подписчику, что кто-то новый присоединился к чату.</li>
 <li><code>отказаться от подписки</code>: Сервер находит данные подписчика-отправителя в хранилище подписок и удаляет его, затем отправляет push-сообщение всем оставшимся подписчикам, сообщая им, что пользователь отписался.</li>
 <li><code>init</code>: Сервер считывает всех текущих подписчиков из текстового файла и посылает каждому из них push-сообщение, чтобы сообщить, что пользователь инициализировал (вновь присоединился) к чату.</li>
 <li><code>chatMsg</code>: Отправляется абонентом, который хочет доставить сообщение всем пользователям; сервер считывает список всех текущих подписчиков из файла хранилища подписок, затем посылает каждому из них push-сообщение, содержащее новое сообщение чата, которое они должны отобразить.</li>
</ul>

<p>Еще пара моментов, на которые стоит обратить внимание:</p>

<ul>
 <li>Мы используем модуль Node.js <a href="https://nodejs.org/api/https.html">https</a> для создания сервера, поскольку в целях безопасности рабочие службы работают только на защищенном соединении. Вот почему нам нужно включить сертификат безопасности <code>.pfx</code> в приложение и ссылаться на него при создании сервера в коде Node.</li>
 <li>Когда вы отправляете push-сообщение без данных, вы просто отправляете его на URL конечной точки с помощью HTTP <code>POST</code> запроса. Однако, когда push-сообщение содержит данные, необходимо их зашифровать, что является довольно сложным процессом. Со временем появятся библиотеки, которые будут делать такие вещи за вас; Для этого демо мы использовали NodeJS-библиотеку Марко Кастеллуччио <a href="https://github.com/marco-c/web-push">web-push</a>. Посмотрите исходный код, чтобы получить представление о том, как выполняется шифрование (и прочитайте <a href="https://tools.ietf.org/html/draft-ietf-webpush-encryption-01">Шифрование сообщений для Web Push</a> для более подробной информации). Библиотека <a href="https://github.com/chrisdavidmills/push-api-demo/blob/gh-pages/server.js#L43-L46">делает отправку push-сообщения простой</a>.</li>
</ul>

<h3 id="The_service_worker">Работник службы сервиса</h3>

<p>Сейчас давайте посмотрим на код рабочего сервиса (<code><a href="https://github.com/chrisdavidmills/push-api-demo/blob/gh-pages/sw.js">sw.js</a></code>), который отвечает на push-сообщения, представленные событиями {{Event("push")}}. Они обрабатываются в области действия работника службы обработчиком события ({{domxref("ServiceWorkerGlobalScope.onpush")}}); его задача - решить, что делать в ответ на каждое полученное сообщение. Сначала мы преобразуем полученное сообщение обратно в объект, вызвав {{domxref("PushMessageData.json()")}}. Далее мы проверяем, какого типа это push-сообщение, просматривая свойство <code>action</code> объекта:</p>

<ul>
 <li><code>подписаться</code> или <code>отказаться от подписки</code>: Мы отправляем системное уведомление с помощью функции <code>fireNotification()</code>, но также отправляем сообщение обратно в основной контекст по нашему {{domxref("MessageChannel")}}, чтобы мы могли соответствующим образом обновить список подписчиков (см. {{anch("Обработка сообщений канала, отправленных с рабочего сервиса")}} для более подробной информации).</li>.
 <li><code>init</code> или <code>chatMsg</code>: Мы просто отправляем сообщение канала обратно в основной контекст для обработки случаев <code>init</code> и <code>chatMsg</code> (они не требуют системного уведомления).</li>
</ul>

<pre class="brush: js">self.addEventListener('push', function(event) {
  var obj = event.data.json();

  if(obj.action === 'subscribe' || obj.action === 'unsubscribe') {
    fireNotification(obj, event);
    port.postMessage(obj);
  } else if(obj.action === 'init' || obj.action === 'chatMsg') {
    port.postMessage(obj);
  }
});</pre>

<p>Следующим рассмотрим функцию <code>fireNotification()</code> (которая, к счастью, довольно проста).</p>

<pre class="brush: js">function fireNotification(obj, event) {
  var title = 'Subscription change';
  var body = obj.name + ' has ' + obj.action + 'd.';
  var icon = 'push-icon.png';
  var tag = 'push';

  event.waitUntil(self.registration.showNotification(title, {
    body: body,
    icon: icon,
    tag: tag
  }));
}</pre>

<p>Здесь мы собираем активы, необходимые для блока уведомлений: заголовок, тело и значок. Затем мы отправляем уведомление с помощью метода {{domxref("ServiceWorkerRegistration.showNotification()")}}, предоставляя эту информацию, а также тег "push", который мы можем использовать для идентификации этого уведомления среди других уведомлений, которые мы можем использовать. Когда уведомление успешно отправлено, оно отображается в виде диалога системного уведомления на компьютерах/устройствах пользователей в том стиле, в котором выглядят системные уведомления на этих системах (на следующем изображении показано системное уведомление Mac OSX)</p>.

<p><img alt="" src="https://mdn.mozillademos.org/files/11855/subscribe-notification.png" style="display: block; height: 65px; margin: 0px auto; width: 326px;"></p>

<p>Обратите внимание, что мы делаем это внутри метода {{domxref("ExtendableEvent.waitUntil()")}}; это делается для того, чтобы рабочий службы оставался активным до тех пор, пока не будет отправлено уведомление. <code>waitUntil()</code> будет продлевать жизненный цикл работника службы до тех пор, пока все, что находится внутри этого метода, не завершится.</p>

<div class="note">
<p><strong>Примечание</strong>: Веб-уведомления от работников служб были введены примерно в версии Firefox 42, но, вероятно, будут снова удалены, пока окружающая функциональность (например, <code>Clients.openWindow()</code>) будет должным образом реализована (см. {{bug(1203324)}} для более подробной информации)</p>.
</div>

<h2 id="Handling_premature_subscription_expiration">Обработка преждевременного истечения срока подписки</h2>

<p>Иногда подписки push истекают преждевременно, без вызова {{domxref("PushSubscription.unsubscribe()")}}. Это может произойти при перегрузке сервера или, например, если вы долгое время находитесь вне сети. Это сильно зависит от сервера, поэтому точное поведение трудно предсказать. В любом случае, вы можете решить эту проблему, следя за событием {{Event("pushsubscriptionchange")}}, которое вы можете прослушать, предоставив обработчик события {{domxref("ServiceWorkerGlobalScope.onpushsubscriptionchange")}}; это событие происходит только в этом конкретном случае.</p>

<pre class="brush: js  language-js"><code class="language-js">self<span class="punctuation token">.</span><span class="function token">addEventListener<span class="punctuation token">(</span></span><span class="string token">'pushsubscriptionchange'</span><span class="punctuation token">,</span> <span class="keyword token">function</span><span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="punctuation token">{</span>
 <span class="comment token"> // do something, usually resubscribe to push and
</span> <span class="comment token"> // send the new subscription details back to the
</span> <span class="comment token"> // server via XHR or Fetch
</span><span class="punctuation token">}</span><span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre>

<p>Обратите внимание, что мы не рассматриваем этот случай в нашей демонстрации, поскольку окончание подписки не является большой проблемой для простого чат-сервера. Но для более сложного примера вы, вероятно, захотите переподписать пользователя.</p>

<h2 id="Extra_steps_for_Chrome_support">Дополнительные шаги для поддержки Chrome</h2>

<p>Чтобы приложение работало в Chrome, нам потребуется несколько дополнительных шагов, поскольку Chrome в настоящее время полагается на службу Google Cloud Messaging.</p>

<h3 id="Setting_up_Google_Cloud_Messaging">Настройка Google Cloud Messaging</h3>

<p>Чтобы настроить его, выполните следующие действия:</p>

<ol>
 <li>Перейдите в <a href="https://console.developers.google.com">Google Developers Console</a> и создайте новый проект.</li>
 <li>Зайдите на домашнюю страницу вашего проекта (наш, например, находится по адресу <code>https://console.developers.google.com/project/push-project-978</code>), затем
  <ol>
   <li>Выберите опцию <em>Включить API Google для использования в ваших приложениях</em>.</li>
   <li>На следующем экране нажмите <em>Cloud Messaging for Android</em> в разделе <em>Mobile APIs</em>.</li>.
   <li>Нажмите кнопку <em>Enable API</em>.</li>.
  </ol>
 </li>
 <li>Сейчас вам нужно записать номер вашего проекта и ключ API, потому что они понадобятся вам позже. Чтобы найти их:
  <ol>
   <li><strong>Номер проекта</strong>: нажмите <em>Дома</em> слева; номер проекта четко обозначен в верхней части главной страницы вашего проекта.</li>
   <li><strong>API-ключ</strong>: нажмите <em>Учетные данные</em> в левом меню; ключ API можно найти на этом экране.</li>
  </ol>
 </li>
</ol>

<h3 id="manifest.json">manifest.json</h3>

<p>Вам необходимо включить в приложение файл <code>manifest.json</code> в стиле Google app, который ссылается на номер проекта, указанный ранее в параметре <code>gcm_sender_id</code>. Вот наш простой пример <a href="https://github.com/chrisdavidmills/push-api-demo/blob/gh-pages/manifest.json">manifest.json</a>:</p>

<pre class="brush: js">{
  "name": "Push Demo",
  "short_name": "Push Demo",
  "icons": [{
        "src": "push-icon.png",
        "sizes": "111x111",
        "type": "image/png"
      }],
  "start_url": "/index.html",
  "display": "standalone",
  "gcm_sender_id": "224273183921"
}</pre>

<p>Вам также нужно сослаться на свой манифест с помощью элемента {{HTMLElement("link")}} в HTML:</p>

<pre class="brush: html">&lt;link rel="manifest" href="manifest.json"&gt;</pre>

<h3 id="userVisibleOnly">userVisibleOnly</h3>

<p>Chrome требует, чтобы вы установили <a href="/en-US/docs/Web/API/PushManager/subscribe#Parameters"><code>userVisibleOnly</code> параметр</a> в <code>true</code> при подписке на службу push, что означает, что мы обещаем показывать уведомление каждый раз, когда получен push. Это можно <a href="https://github.com/chrisdavidmills/push-api-demo/blob/gh-pages/main.js#L127">увидеть в действии</a> в нашей функции <code>subscribe()</code>.</p>

<h2 id="See_also">Смотрите также</h2>

<ul>
 <li><a href="/en-US/docs/Web/API/Push_API">Push API</a></li>
 <li><a href="/en-US/docs/Web/API/Service_Worker_API">Service Worker API</a></li>
</ul>

<div class="note">
<p><strong>Примечание</strong>: Часть клиентского кода в нашей демонстрации Push в значительной степени зависит от превосходных примеров Мэтта Гаунта в <a href="http://updates.html5rocks.com/2015/03/push-notificatons-on-the-open-web">Push Notifications on the Open Web</a>. Спасибо за отличную работу, Мэтт! </p>
</div>


