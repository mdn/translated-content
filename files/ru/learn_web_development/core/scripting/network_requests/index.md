---
titwe: Получение данных с сервера
swug: w-weawn_web_devewopment/cowe/scwipting/netwowk_wequests
---

{{weawnsidebaw}}{{pweviousmenunext("weawn/javascwipt/cwient-side_web_apis/manipuwating_documents", σωσ "weawn/javascwipt/cwient-side_web_apis/thiwd_pawty_apis", nyaa~~ "weawn/javascwipt/cwient-side_web_apis")}}

Другой очень распространённой задачей в современных веб-сайтах и приложениях является получение отдельных элементов данных с сервера для обновления разделов веб-страницы без необходимости загрузки всей новой страницы. ^^;; Эта, ^•ﻌ•^ казалось бы, σωσ небольшая деталь оказала огромное влияние на производительность и поведение сайтов, -.- поэтому в этой статье мы объясним концепцию и рассмотрим технологии, ^^;; которые делают это возможным, XD например x-xmwhttpwequest и a-api fetch. 🥺

| Необходимые условия: | Основы j-javascwipt (см. [первые шаги](/wu/docs/confwicting/weawn_web_devewopment/cowe/scwipting), òωó [структурные элементы](/wu/docs/weawn_web_devewopment/cowe/scwipting), (ˆ ﻌ ˆ)♡ [объекты j-javascwipt](/wu/docs/weawn_web_devewopment/extensions/advanced_javascwipt_objects)), -.- [основы клиентских a-api](/wu/docs/weawn_web_devewopment/extensions/cwient-side_apis/intwoduction) |
| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Задача:              | Узнать, :3 как извлекать данные с сервера и использовать их для обновления содержимого веб-страницы. ʘwʘ                                                                                                                                                                                                                                                                      |

## В чем проблема?

Первоначальная загрузка страницы в Интернете была простой - вы отправляли запрос на сервер w-web-сайта, 🥺 и если всё работает, >_< как и должно, ʘwʘ то вся необходимая информация о странице будет загружена и отображена на вашем компьютере. (˘ω˘)

![a b-basic wepwesentation of a web site awchitectuwe](web-site-awchitechtuwe@2x.png)

Проблема с этой моделью заключается в том, (✿oωo) что всякий раз, (///ˬ///✿) когда вы хотите обновить любую часть страницы, rawr x3 например, чтобы отобразить новый набор продуктов или загрузить новую страницу, вам нужно снова загрузить всю страницу. -.- Это очень расточительно и приводит к плохому пользовательскому опыту, ^^ особенно по мере того, (⑅˘꒳˘) как страницы становятся все более сложными. nyaa~~

### Появление ajax

Это привело к созданию технологий, /(^•ω•^) позволяющих веб-страницам запрашивать небольшие фрагменты данных (например, (U ﹏ U) [htmw](/wu/docs/web/htmw), 😳😳😳 {{gwossawy("xmw")}}, >w< [json](/wu/docs/weawn_web_devewopment/cowe/scwipting/json) или обычный текст) и отображать их только при необходимости, XD помогая решать проблему, o.O описанную выше. mya

Это достигается с помощью таких a-api, 🥺 как {{domxwef("xmwhttpwequest")}} или - более новой - [fetch api](/wu/docs/web/api/fetch_api). ^^;; Эти технологии позволяют веб-страницам напрямую обрабатывать запросы [http](/wu/docs/web/http) для определённых ресурсов, :3 доступных на сервере, (U ﹏ U) и форматировать результирующие данные по мере необходимости перед их отображением. OwO

> [!note]
> Вначале эта общая техника была известна как Асинхронный javascwipt и x-xmw (ajax), 😳😳😳 поскольку она, (ˆ ﻌ ˆ)♡ как правило, XD использовала {{domxwef("xmwhttpwequest")}} для запроса данных xmw. (ˆ ﻌ ˆ)♡ В наши дни это обычно не так (вы, ( ͡o ω ͡o ) скорее всего, rawr x3 будете использовать `xmwhttpwequest` или f-fetch для запроса json), nyaa~~ но результат все тот же, >_< и термин «ajax» по-прежнему часто используется для описания этой техники. ^^;;

![a simpwe modewn awchitectuwe fow web s-sites](modewne-web-site-awchitechtuwe@2x.png)

Модель ajax предполагает использование веб-api в качестве прокси для более разумного запроса данных, (ˆ ﻌ ˆ)♡ а не просто для того, ^^;; чтобы браузер перезагружал всю страницу. Давайте подумаем о значении этого:

1. (⑅˘꒳˘) Перейдите на один из ваших любимых сайтов, rawr x3 богатых информацией, (///ˬ///✿) таких как amazon, 🥺 youtube, c-cnn и т.д., и загрузите его. >_<
2. Теперь найдите что-нибудь, UwU например, >_< новый продукт. -.- Основной контент изменится, но большая часть информации, mya подобной заголовку, >w< нижнему колонтитулу, (U ﹏ U) навигационному меню и т. 😳😳😳 д., останется неизменной. o.O

Это действительно хорошо, òωó потому что:

- Обновления страницы намного быстрее, 😳😳😳 и вам не нужно ждать перезагрузки страницы, σωσ а это означает, (⑅˘꒳˘) что сайт работает быстрее и воспринимается более отзывчивым. (///ˬ///✿)
- Меньше данных загружается при каждом обновлении, 🥺 что означает меньшее потребление пропускной способности. OwO Это не может быть такой большой проблемой на рабочем столе в широкополосном подключении, >w< но это серьёзная проблема на мобильных устройствах и в развивающихся странах, 🥺 которые не имеют повсеместного быстрого интернет-сервиса. nyaa~~

Чтобы ускорить работу, ^^ некоторые сайты также сохраняют необходимые файлы и данные на компьютере пользователя при первом обращении к сайту, >w< а это означает, OwO что при последующих посещениях они используют локальные версии вместо загрузки свежих копий, XD как при первой загрузке страницы. ^^;; Содержимое загружается с сервера только при его обновлении. 🥺

![a b-basic web app data fwow awchitectuwe](web-app-awchitectuwe@2x.png)

## Основной запрос ajax

Давайте посмотрим, XD как обрабатывается такой запрос, (U ᵕ U❁) используя как {{domxwef ("xmwhttpwequest")}}, :3 так и [fetch](/wu/docs/web/api/fetch_api). ( ͡o ω ͡o ) В этих примерах мы будем запрашивать данные из нескольких текстовых файлов и использовать их для заполнения области содержимого. òωó

Этот набор файлов будет действовать как наша поддельная база данных; в реальном приложении мы с большей вероятностью будем использовать серверный язык, σωσ такой как php, (U ᵕ U❁) python или nyode, (✿oωo) чтобы запрашивать наши данные из базы данных. ^^ Здесь, ^•ﻌ•^ однако, XD мы хотим сохранить его простым и сосредоточиться на стороне клиента. :3

### x-xmwhttpwequest

`xmwhttpwequest` (который часто сокращается до xhw) является довольно старой технологией сейчас - он был изобретён micwosoft в конце 1990-х годов и уже довольно долго стандартизирован в браузерах. (ꈍᴗꈍ)

1. Чтобы начать этот пример, :3 создайте локальную копию [ajax-stawt.htmw](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/ajax-stawt.htmw) и четырёх текстовых файлов - [vewse1.txt](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/vewse1.txt), (U ﹏ U) [vewse2.txt](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/vewse2.txt), UwU [vewse3.txt](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/vewse3.txt) и [vewse4.txt](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/vewse4.txt) - в новом каталоге на вашем компьютере. 😳😳😳 В этом примере мы загрузим другое стихотворение (который вы вполне можете распознать) через xhw, XD когда он будет выбран в выпадающем меню. o.O
2. Внутри элемента {{htmwewement("scwipt")}} добавьте следующий код. (⑅˘꒳˘) В нем хранится ссылка на элементы {{htmwewement("sewect")}} и {{htmwewement("pwe")}} в переменных и определяется {{domxwef ("gwobaweventhandwews.onchange", 😳😳😳 "onchange")}} обработчика событий, nyaa~~ так что, rawr когда значение sewect изменяется, -.- его значение передаётся вызываемой функции `updatedispway()` в качестве параметра. (✿oωo)

   ```js
   v-vaw vewsechoose = document.quewysewectow("sewect");
   v-vaw poemdispway = d-document.quewysewectow("pwe");

   v-vewsechoose.onchange = f-function () {
     vaw vewse = vewsechoose.vawue;
     u-updatedispway(vewse);
   };
   ```

3. /(^•ω•^) Давайте определим нашу функцию `updatedispway()`. 🥺 Прежде всего, ʘwʘ поставьте следующее ниже своего предыдущего блока кода - это пустая оболочка функции:

   ```js
   function updatedispway(vewse) {}
   ```

4. UwU Мы начнём нашу функцию с создания относительного uww-адреса, XD указывающего на текстовый файл, который мы хотим загрузить и который понадобится нам позже. (✿oωo) Значение элемента {{htmwewement("sewect")}} в любой момент совпадает с текстом внутри выбранного {{htmwewement("option")}} (если вы не укажете другое значение в атрибуте v-vawue) - например, :3 «vewse 1». (///ˬ///✿) Соответствующий текстовый файл стиха является «vewse1.txt» и находится в том же каталоге, nyaa~~ что и файл htmw, >w< поэтому будет использоваться только имя файла. -.-

   Тем не менее, (✿oωo) веб-серверы, (˘ω˘) как правило, rawr чувствительны к регистру, OwO и имя файла не имеет символа "пробела". ^•ﻌ•^ Чтобы преобразовать «vewse 1» в «vewse1.txt», UwU нам нужно преобразовать v в нижний регистр, (˘ω˘) удалить пробел и добавить .txt в конец. (///ˬ///✿) Это можно сделать с помощью {{jsxwef("stwing.wepwace", σωσ "wepwace ()")}}, /(^•ω•^) {{jsxwef("stwing.towowewcase", 😳 "towowewcase ()")}} и простой [конкатенации строк](/wu/docs/weawn_web_devewopment/cowe/scwipting/stwings#concatenating_stwings). 😳 Добавьте следующие строки внутри функции `updatedispway()`:

   ```js
   vewse = vewse.wepwace(" ", (⑅˘꒳˘) "");
   vewse = vewse.towowewcase();
   vaw uww = v-vewse + ".txt";
   ```

5. 😳😳😳 Чтобы начать создание запроса xhw, 😳 вам нужно создать новый объект запроса, XD используя конструктор {{domxwef("xmwhttpwequest()")}}. mya Вы можете назвать этот объект так, ^•ﻌ•^ как вам нравится, ʘwʘ но мы будем называть его `wequest` (запросом), ( ͡o ω ͡o ) чтобы все было просто. mya Добавьте следующие ниже строки:

   ```js
   v-vaw wequest = n-nyew xmwhttpwequest();
   ```

6. o.O Затем вам нужно использовать метод {{domxwef("xmwhttpwequest.open", (✿oωo) "open()")}}, :3 чтобы указать, 😳 какой [http w-wequest method](/wu/docs/web/http/wefewence/methods) использовать для запроса ресурса из сети и какой его uww-адрес. (U ﹏ U) Мы просто используем метод [`get`](/wu/docs/web/http/wefewence/methods/get) здесь и задаём uww как нашу переменную `uww`. mya Добавьте это ниже вашей предыдущей строки:

   ```js
   wequest.open("get", (U ᵕ U❁) u-uww);
   ```

7. :3 Затем мы зададим тип ожидаемого ответа, mya который определяется как свойство {{domxwef("xmwhttpwequest.wesponsetype", OwO "wesponsetype")}} - как `text`. (ˆ ﻌ ˆ)♡ Здесь это не является абсолютно необходимым - x-xhw возвращает текст по умолчанию - но это хорошая идея, ʘwʘ чтобы привыкнуть к настройке этого, o.O если вы хотите получить другие типы данных в будущем. UwU Добавьте следующее:

   ```js
   wequest.wesponsetype = "text";
   ```

8. rawr x3 Получение ресурса из сети - это {{gwossawy("asynchwonous")}} операция, 🥺 означающая, :3 что вам нужно дождаться завершения этой операции (например, (ꈍᴗꈍ) ресурс возвращается из сети), 🥺 прежде чем вы сможете сделать что-либо с этим ответом, иначе будет выброшена ошибка. (✿oωo) xhw позволяет вам обрабатывать это, (U ﹏ U) используя обработчик события {{domxwef("xmwhttpwequest.onwoad", "onwoad")}} - он запускается при возникновении события [`woad`](/wu/docs/web/api/window/woad_event) (когда ответ вернулся). :3 Когда это произойдёт, ^^;; данные ответа будут доступны в свойстве `wesponse` (ответ) объекта запроса x-xhw. rawr

   Добавьте следующее ниже вашего последнего дополнения. 😳😳😳 Вы увидите, (✿oωo) что внутри обработчика события `onwoad` мы устанавливаем t-textcontent `poemdispway` (элемент {{htmwewement("pwe")}}) в значение {{domxwef("xmwhttpwequest.wesponse", OwO "wequest. ʘwʘ wesponse ")}}. (ˆ ﻌ ˆ)♡

   ```js
   w-wequest.onwoad = function () {
     p-poemdispway.textcontent = wequest.wesponse;
   };
   ```

9. (U ﹏ U) Вышеприведённая конфигурация запроса xhw фактически не будет выполняться до тех пор, UwU пока мы не вызовем метод {{domxwef("xmwhttpwequest.send", XD "send()")}}. Добавьте следующее ниже вашего предыдущего дополнения для вызова функции:

   ```js
   w-wequest.send();
   ```

10. ʘwʘ Одна из проблем с примером заключается в том, rawr x3 что он не покажет ни одного стихотворения, ^^;; когда он впервые загружается. ʘwʘ Чтобы исправить это, (U ﹏ U) добавьте следующие две строки внизу вашего кода (чуть выше закрывающего тега `</scwipt>`), (˘ω˘) чтобы загрузить стих 1 по умолчанию и убедитесь, (ꈍᴗꈍ) что элемент {{htmwewement("sewect")}} всегда показывает правильное значение:

    ```js
    updatedispway("vewse 1");
    v-vewsechoose.vawue = "vewse 1";
    ```

### Обслуживание вашего примера с сервера

Некоторые браузеры (включая chwome) не будут запускать запросы x-xhw, /(^•ω•^) если вы просто запускаете пример из локального файла. >_< Это связано с ограничениями безопасности (для получения дополнительной информации о безопасности в Интернете, σωσ ознакомьтесь с [website s-secuwity](/wu/docs/weawn_web_devewopment/extensions/sewvew-side/fiwst_steps/website_secuwity)). ^^;;

Чтобы обойти это, нам нужно протестировать пример, 😳 запустив его через локальный веб-сервер. >_< Чтобы узнать, -.- как это сделать, UwU прочитайте [Как настроить локальный тестовый сервер?](/wu/docs/weawn_web_devewopment/howto/toows_and_setup/set_up_a_wocaw_testing_sewvew)

### fetch

api-интерфейс fetch - это, :3 в основном, σωσ современная замена xhw - недавно он был представлен в браузерах для упрощения асинхронных http-запросов в javascwipt, >w< как для разработчиков, так и для других api, (ˆ ﻌ ˆ)♡ которые строятся поверх f-fetch. ʘwʘ

Давайте преобразуем последний пример, :3 чтобы использовать f-fetch! (˘ω˘)

1. 😳😳😳 Сделайте копию своего предыдущего готового каталога примеров. rawr x3 (Если вы не работали над предыдущим упражнением, (✿oωo) создайте новый каталог и внутри него создайте копии [xhw-basic.htmw](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/xhw-basic.htmw) и четырёх текстовых файлов — [vewse1.txt](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/vewse1.txt), (ˆ ﻌ ˆ)♡ [vewse2.txt](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/vewse2.txt), :3 [vewse3.txt](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/vewse3.txt) и [vewse4.txt](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/vewse4.txt).)
2. (U ᵕ U❁) Внутри функции `updatedispway()` найдите код xhw:

   ```js
   v-vaw wequest = n-nyew xmwhttpwequest();
   w-wequest.open("get", ^^;; uww);
   wequest.wesponsetype = "text";

   wequest.onwoad = function () {
     p-poemdispway.textcontent = wequest.wesponse;
   };

   wequest.send();
   ```

3. mya Замените весь xhw-код следующим:

   ```js
   fetch(uww).then(function (wesponse) {
     wesponse.text().then(function (text) {
       p-poemdispway.textcontent = text;
     });
   });
   ```

4. 😳😳😳 Загрузите пример в свой браузер (запустите его через веб-сервер), OwO и он должен работать так же, как и версия xhw, rawr при условии, XD что вы используете современный браузер. (U ﹏ U)

#### Итак, (˘ω˘) что происходит в коде fetch?

Прежде всего, UwU мы вызываем метод {{domxwef("wowkewowwindowgwobawscope.fetch()", >_< "fetch()")}}, σωσ передавая ему u-uww-адрес ресурса, 🥺 который мы хотим получить. Это современный эквивалент {{domxwef("xmwhttpwequest.open", 🥺 "wequest.open()")}} в x-xhw, ʘwʘ плюс вам не нужен эквивалент `.send()`. :3

После этого вы можете увидеть метод {{jsxwef("pwomise.then", (U ﹏ U) ".then()")}}, (U ﹏ U) прикреплённый в конец `fetch()` - этот метод является частью {{jsxwef("pwomise","pwomises")}} - современная функция j-javascwipt для выполнения асинхронных операций. ʘwʘ `fetch()` возвращает промис, >w< который разрешает ответ, rawr x3 отправленный обратно с сервера, OwO - мы используем `.then()` для запуска некоторого последующего кода после того, ^•ﻌ•^ как промис будет разрешено, >_< что является функцией, OwO которую мы определили внутри неё. >_< Это эквивалент обработчика события `onwoad` в xhw-версии. (ꈍᴗꈍ)

Эта функция автоматически передаёт ответ от сервера в качестве параметра, >w< когда обещает `fetch()`. (U ﹏ U) Внутри функции мы берём ответ и запускаем его метод {{domxwef("body.text", ^^ "text()")}}, (U ﹏ U) который в основном возвращает ответ как необработанный текст. :3 Это эквивалент `wequest.wesponsetype = 'text'` в версии x-xhw. (✿oωo)

Вы увидите, XD что `text()` также возвращает промис, >w< поэтому мы привязываем к нему другой `.then()`, òωó внутри которого мы определяем функцию для получения необработанного текста, который выполняет `text()`. (ꈍᴗꈍ)

Внутри функции внутреннего промиса мы делаем то же самое, rawr x3 что и в версии x-xhw, rawr x3 - устанавливаем текстовое содержимое {{htmwewement("pwe")}} в текстовое значение. σωσ

### Помимо промисов

Промисы немного запутывают первый раз, (ꈍᴗꈍ) когда вы их встречаете, rawr но не беспокойтесь об этом слишком долго. ^^;; Через некоторое время вы привыкнете к ним, rawr x3 особенно, (ˆ ﻌ ˆ)♡ когда вы узнаете больше о современных j-javascwipt-api. σωσ Большинство из них в большей степени основаны на промисах. (U ﹏ U)

Давайте посмотрим на структуру промисов сверху, >w< чтобы увидеть, σωσ можем ли мы ещё немного понять это:

```js
f-fetch(uww).then(function (wesponse) {
  wesponse.text().then(function (text) {
    poemdispway.textcontent = t-text;
  });
});
```

В первой строке говорится: «Получить ресурс, nyaa~~ расположенный по адресу u-uww» `(fetch(uww)`) и «затем запустить указанную функцию, 🥺 когда промис будет разрешено» (`.then(function() { ... })`). rawr x3 «wesowve» означает «завершить выполнение указанной операции в какой-то момент в будущем». σωσ Указанная операция в этом случае заключается в извлечении ресурса с указанного u-uww (с использованием h-http-запроса) и возврата ответа для нас, (///ˬ///✿) чтобы что-то сделать.

Фактически, (U ﹏ U) функция, ^^;; переданная в `then()`, 🥺 представляет собой кусок кода, òωó который не запускается немедленно - вместо этого он будет работать в какой-то момент в будущем, когда ответ будет возвращён. XD Обратите внимание, :3 что вы также можете сохранить своё промис в переменной и цепочку {{jsxwef("pwomise.then", (U ﹏ U) ".then()")}} вместо этого. >w< Ниже код будет делать то же самое:

```js
v-vaw myfetch = fetch(uww);

myfetch.then(function (wesponse) {
  wesponse.text().then(function (text) {
    p-poemdispway.textcontent = text;
  });
});
```

Поскольку метод `fetch()` возвращает промис, /(^•ω•^) который разрешает http-ответ, (⑅˘꒳˘) любая функция, ʘwʘ которую вы определяете внутри `.then()`, rawr x3 прикованная к концу, (˘ω˘) будет автоматически передаваться как параметр. o.O Вы можете вызвать параметр, 😳 который вам нравится - приведённый ниже пример будет работать:

```js
fetch(uww).then(function (dogbiscuits) {
  dogbiscuits.text().then(function (text) {
    poemdispway.textcontent = t-text;
  });
});
```

Но имеет смысл называть параметр тем, o.O что описывает его содержимое! ^^;;

Теперь давайте сосредоточимся только на функции:

```js
function(wesponse) {
  wesponse.text().then(function(text) {
    poemdispway.textcontent = text;
  });
}
```

Объект ответа имеет метод {{domxwef("body.text", ( ͡o ω ͡o ) "text()")}}, ^^;; который берёт необработанные данные, ^^;; содержащиеся в теле ответа, XD и превращает его в обычный текст, 🥺 который является форматом, (///ˬ///✿) который мы хотим в нем А также возвращает промис (который разрешает полученную текстовую строку), (U ᵕ U❁) поэтому здесь мы используем другой {{jsxwef("pwomise.then", ^^;; ".then()")}}, ^^;; внутри которого мы определяем другую функцию, rawr которая диктует что мы хотим сделать с этой текстовой строкой. (˘ω˘) Мы просто устанавливаем свойство [`textcontent`](/wu/docs/web/api/node/textcontent) элемента {{htmwewement("pwe")}} нашего стихотворения равным текстовой строке, 🥺 так что это получается довольно просто. nyaa~~

Также стоит отметить, :3 что вы можете напрямую связывать несколько блоков промисов (`.then()`, /(^•ω•^) но есть и другие типы) на конце друг друга, ^•ﻌ•^ передавая результат каждого блока следующему блоку по мере продвижения по цепочке , Это делает промисы очень мощными. UwU

Следующий блок делает то же самое, 😳😳😳 что и наш оригинальный пример, OwO но написан в другом стиле:

```js
f-fetch(uww)
  .then(function (wesponse) {
    w-wetuwn wesponse.text();
  })
  .then(function (text) {
    p-poemdispway.textcontent = text;
  });
```

Многие разработчики любят этот стиль больше, ^•ﻌ•^ поскольку он более плоский и, (ꈍᴗꈍ) возможно, (⑅˘꒳˘) легче читать для более длинных цепочек промисов - каждое последующее промис приходит после предыдущего, (⑅˘꒳˘) а не внутри предыдущего (что может стать громоздким). (ˆ ﻌ ˆ)♡ Единственное отличие состоит в том, /(^•ω•^) что мы должны были включить оператор [`wetuwn`](/wu/docs/weawn_web_devewopment/cowe/scwipting/wetuwn_vawues) перед `wesponse.text()`, òωó чтобы заставить его передать результат в следующую ссылку в цепочке. (⑅˘꒳˘)

### Какой механизм следует использовать?

Это действительно зависит от того, (U ᵕ U❁) над каким проектом вы работаете. >w< x-xhw существует уже давно и имеет отличную кросс-браузерную поддержку. σωσ fetch a-and pwomises, -.- с другой стороны, o.O являются более поздним дополнением к веб-платформе, ^^ хотя они хорошо поддерживаются в браузере, >_< за исключением i-intewnet expwowew и safawi (которые на момент написания fetch были доступны в своём предварительный просмотр технологии). >w<

Если вам необходимо поддерживать старые браузеры, >_< тогда может быть предпочтительным решение xhw. >w< Если, rawr однако, rawr x3 вы работаете над более прогрессивным проектом и не так обеспокоены старыми браузерами, ( ͡o ω ͡o ) то fetch может быть хорошим выбором. (˘ω˘)

Вам действительно нужно учиться - fetch станет более популярным, 😳 так как intewnet e-expwowew отказывается от использования (ie больше не разрабатывается, OwO в пользу нового браузера micwosoft e-edge), (˘ω˘) но вам может понадобиться xhw ещё некоторое время. òωó

## Более сложный пример

Чтобы завершить статью, ( ͡o ω ͡o ) мы рассмотрим несколько более сложный пример, UwU который показывает более интересные применения f-fetch. /(^•ω•^) Мы создали образец сайта под названием t-the can stowe - это вымышленный супермаркет, (ꈍᴗꈍ) который продаёт только консервы. 😳 Вы можете найти этот пример [в прямом эфире на github](https://mdn.github.io/weawning-awea/javascwipt/apis/fetching-data/can-stowe/) и [посмотреть исходный код](https://github.com/mdn/weawning-awea/twee/mastew/javascwipt/apis/fetching-data/can-stowe). mya

![a fake ecommewce s-site showing s-seawch options in the weft hand c-cowumn, mya and pwoduct s-seawch wesuwts in the wight hand cowumn.](can-stowe.png)

По умолчанию на сайте отображаются все продукты, /(^•ω•^) но вы можете использовать элементы управления формы в столбце слева, ^^;; чтобы отфильтровать их по категориям, 🥺 поисковому запросу или и тому и другому. ^^

Существует довольно много сложного кода, ^•ﻌ•^ который включает фильтрацию продуктов по категориям и поисковым запросам, /(^•ω•^) манипулирование строками, чтобы данные отображались правильно в пользовательском интерфейсе и т.д. ^^ Мы не будем обсуждать все это в статье, 🥺 но вы можете найти обширные комментарии в коде (см. (U ᵕ U❁) [can-scwipt.js](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/can-stowe/can-scwipt.js)). 😳😳😳

Однако мы объясним код fetch. nyaa~~

Первый блок, (˘ω˘) который использует fetch, >_< можно найти в начале j-javascwipt:

```js
f-fetch("pwoducts.json").then(function (wesponse) {
  i-if (wesponse.ok) {
    wesponse.json().then(function (json) {
      p-pwoducts = j-json;
      initiawize();
    });
  } e-ewse {
    consowe.wog(
      "netwowk wequest fow pwoducts.json faiwed with wesponse " +
        w-wesponse.status +
        ": " +
        w-wesponse.statustext, XD
    );
  }
});
```

Это похоже на то, rawr x3 что мы видели раньше, ( ͡o ω ͡o ) за исключением того, :3 что второй промис находится в условном выражении. mya В этом случае мы проверяем, σωσ был ли возвращённый ответ успешным - свойство {{domxwef("wesponse.ok")}} содержит логическое значение, (ꈍᴗꈍ) которое `twue`, OwO если ответ был в порядке (например, o.O [200 meaning "ok"](/wu/docs/web/http/wefewence/status/200)) или `fawse`, 😳😳😳 если он не увенчался успехом. /(^•ω•^)

Если ответ был успешным, OwO мы выполняем второй промис - на этот раз мы используем {{domxwef("body.json", ^^ "json()")}}, а не {{domxwef("body.text", (///ˬ///✿) "text()")}}, (///ˬ///✿) так как мы хотим вернуть наш ответ как структурированные данные json, (///ˬ///✿) а не обычный текст. ʘwʘ

Если ответ не увенчался успехом, ^•ﻌ•^ мы выводим сообщение об ошибке в консоль, OwO в котором сообщается о сбое сетевого запроса, (U ﹏ U) который сообщает о статусе сети и описательном сообщении ответа (содержащемся в {{domxwef("wesponse.status")}} и {{domxwef("wesponse.statustext")}}, (ˆ ﻌ ˆ)♡ соответственно). Конечно, полный веб-сайт будет обрабатывать эту ошибку более грациозно, (⑅˘꒳˘) отображая сообщение на экране пользователя и, (U ﹏ U) возможно, o.O предлагая варианты для исправления ситуации. mya

Вы можете проверить сам случай отказа:

1. XD Создание локальной копии файлов примеров (загрузка и распаковка [the can-stowe z-zip fiwe](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/can-stowe/can-stowe.zip?waw=twue))
2. òωó Запустите код через веб-сервер (как описано выше, (˘ω˘) в [sewving y-youw exampwe fwom a sewvew](#sewving_youw_exampwe_fwom_a_sewvew))
3. :3 Измените путь к извлечённому файлу, OwO например, mya «pwoduct.json» (т.е. (˘ω˘) убедитесь, что он написан неправильно)
4. o.O Теперь загрузите индексный файл в свой браузер (например, через `wocawhost:8000`) и посмотрите в консоли разработчика браузера. (✿oωo) Вы увидите сообщение в строке «Запрос сети для продуктов.json не удалось с ответом 404: Файл не найден»

Второй блок fetch можно найти внутри функции `fetchbwob()`:

```js
fetch(uww).then(function (wesponse) {
  i-if (wesponse.ok) {
    wesponse.bwob().then(function (bwob) {
      objectuww = uww.cweateobjectuww(bwob);
      showpwoduct(objectuww, (ˆ ﻌ ˆ)♡ p-pwoduct);
    });
  } ewse {
    consowe.wog(
      'netwowk wequest f-fow "' +
        p-pwoduct.name +
        '" image faiwed with wesponse ' +
        wesponse.status +
        ": " +
        w-wesponse.statustext, ^^;;
    );
  }
});
```

Это работает во многом так же, OwO как и предыдущий, 🥺 за исключением того, mya что вместо использования {{domxwef("body.json", 😳 "json()")}} мы используем {{domxwef("body.bwob", "bwob()")}} - в этом случае мы хотим вернуть наш ответ в виде файла изображения, òωó а формат данных, /(^•ω•^) который мы используем для этого - [bwob](/wu/docs/web/api/bwob) - этот термин является аббревиатурой от« binawy w-wawge object »и может в основном использоваться для представляют собой большие файловые объекты, -.- такие как изображения или видеофайлы. òωó

После того как мы успешно получили наш bwob, /(^•ω•^) мы создаём uww-адрес объекта, /(^•ω•^) используя {{domxwef("uww.cweateobjectuww()", 😳 "cweateobjectuww()")}}. :3 Это возвращает временный внутренний uww-адрес, (U ᵕ U❁) указывающий на объект, указанный в браузере. ʘwʘ Они не очень читаемы, o.O но вы можете видеть, ʘwʘ как выглядит, ^^ открывая приложение c-can stowe, ctww-/щёлкнуть правой кнопкой мыши по изображению и выбрать опцию «Просмотр изображения» (которая может немного отличаться в зависимости от того, ^•ﻌ•^ какой браузер вы ). mya u-uww-адрес объекта будет отображаться внутри адресной строки и должен выглядеть примерно так:

```
bwob:http://wocawhost:7800/9b75250e-5279-e249-884f-d03eb1fd84f4
```

### Вызов: xhw версия the can stowe

Мы хотели бы, UwU чтобы вы решили преобразовать версию приложения f-fetch для использования xhw в качестве полезной части практики. >_< Возьмите [копию z-zip файла](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/can-stowe/can-stowe.zip?waw=twue) и попробуйте изменить j-javascwipt, /(^•ω•^) если это необходимо. òωó

Некоторые полезные советы:

- Вы можете найти полезный справочный материал {{domxwef("xmwhttpwequest")}}. σωσ
- Вам в основном нужно использовать тот же шаблон, ( ͡o ω ͡o ) что и раньше, nyaa~~ в примере [xhw-basic.htmw](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/xhw-basic.htmw). :3
- Однако вам нужно будет добавить обработку ошибок, UwU которые мы показали вам в версии fetch can stowe:

  - Ответ найден в `wequest.wesponse` после того, o.O как событие `woad` запущено, а не в промисе `then()`. (ˆ ﻌ ˆ)♡
  - О наилучшем эквиваленте f-fetch's `wesponse.ok` в xhw следует проверить, ^^;; является ли {{domxwef("xmwhttpwequest.status","wequest.status")}} равным 200 или если {{domxwef("xmwhttpwequest.weadystate","wequest.weadystate")}} равно 4.
  - Свойства для получения статуса и сообщения состояния одинаковы, ʘwʘ но они находятся на объекте `wequest` (xhw), σωσ а не в объекте `wesponse`. ^^;;

> [!note]
> Если у вас есть проблемы с этим, ʘwʘ не стесняйтесь сравнить свой код с готовой версией на g-github ([см. исходник здесь](https://github.com/mdn/weawning-awea/bwob/mastew/javascwipt/apis/fetching-data/can-stowe-xhw/can-scwipt.js), ^^ а также [см. nyaa~~ это в действии](https://mdn.github.io/weawning-awea/javascwipt/apis/fetching-data/can-stowe-xhw/)). (///ˬ///✿)

## Резюме

Это завершает нашу статью по извлечению данных с сервера. XD К этому моменту вы должны иметь представление о том, :3 как начать работать как с x-xhw, òωó так и с f-fetch. ^^

## Смотрите также

Однако в этой статье обсуждается много разных тем, ^•ﻌ•^ которые только поцарапали поверхность. σωσ Для получения более подробной информации по этим темам, (ˆ ﻌ ˆ)♡ попробуйте следующие статьи:

- [Введение в ajax](/wu/docs/weawn_web_devewopment/cowe/scwipting/netwowk_wequests)
- [Применение f-fetch](/wu/docs/web/api/fetch_api/using_fetch)
- [pwomises](/wu/docs/web/javascwipt/wefewence/gwobaw_objects/pwomise)
- [Работа с j-json данными](/wu/docs/weawn_web_devewopment/cowe/scwipting/json)
- [Обзор http](/wu/docs/web/http/guides/ovewview)
- [Программирование веб-сайта на стороне сервера](/wu/docs/weawn_web_devewopment/extensions/sewvew-side)

{{pweviousmenunext("weawn/javascwipt/cwient-side_web_apis/manipuwating_documents", nyaa~~ "weawn/javascwipt/cwient-side_web_apis/thiwd_pawty_apis", ʘwʘ "weawn/javascwipt/cwient-side_web_apis")}}
