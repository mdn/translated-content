---
title: "Учебник Express часть 3: Использование базы данных (с помощью Mongoose)"
short-title: "3: Использование баз данных с Mongoose"
slug: Learn_web_development/Extensions/Server-side/Express_Nodejs/mongoose
page-type: learn-module-chapter
sidebar: learnsidebar
---

{{PreviousMenuNext("Learn_web_development/Extensions/Server-side/Express_Nodejs/skeleton_website", "Learn_web_development/Extensions/Server-side/Express_Nodejs/routes", "Learn_web_development/Extensions/Server-side/Express_Nodejs")}}

Эта статья кратко знакомит с базами данных и объясняет, как использовать их в приложениях Node/Express. Затем мы показываем, как можно использовать [Mongoose](http://mongoosejs.com/) для доступа к базе данных сайта [LocalLibrary](/ru/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/Tutorial_local_library_website).
Мы объясняем, как объявляются схемы и модели объектов, описываем основные типы полей и базовую валидацию.
Также кратко показаны несколько основных способов доступа к данным модели.

<table>
  <tbody>
    <tr>
      <th scope="row">Предварительные сведения:</th>
      <td>
        <a href="/ru/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/skeleton_website">Учебник Express часть 2: Создание каркасного сайта</a>
      </td>
    </tr>
    <tr>
      <th scope="row">Цель:</th>
      <td>Научиться проектировать и создавать собственные модели с помощью Mongoose.</td>
    </tr>
  </tbody>
</table>

## Обзор

Сотрудники библиотеки будут использовать сайт Local Library для хранения информации о книгах и абонентах, а абоненты библиотеки будут использовать его для просмотра и поиска книг, для получения информации о доступных копиях, для резервирования или одалживания книг. Чтобы эффективно хранить и извлекать информацию, мы будем хранить её в базе данных.

Express-приложения могут использовать различные базы данных, и есть несколько подходов, которые можно использовать для выполнения операций **C**reate, **R**ead, **U**pdate and **D**elete (CRUD) (создать, прочесть, обновить, удалить). В руководстве дан краткий обзор некоторых доступных опций, и детально рассмотрены некоторые механизмы работы.

### Какие базы данных можно использовать?

*Express-*приложение может использовать любые базы данных, поддерживаемые _Node_ (сам по себе Express не определяет каких-либо конкретных дополнительных свойств и требований для управления базами данных). Есть [много популярных](https://expressjs.com/en/guide/database-integration.html) вариантов — PostgreSQL, MySQL, Redis, SQLite, и MongoDB.

При выборе базы данных следует учитывать такие факторы как время разработки, время обучения, простота репликации и копирования, расходы, поддержка сообщества и т. д. Хотя нет единственной "лучшей" базы данных, почти любое из популярных решений будет приемлемым для сайта малого и среднего размера, такого как наша Local Library.

Более подробно о вариантах смотрите в: [Database integration](https://expressjs.com/en/guide/database-integration.html) (Express docs).

### Каков наилучший способ взаимодействия с базой данных?

Существует два подхода при работе с базой данных:

- Использование родного языка запросов баз данных (т.е. SQL)
- Использование объектной модели данных (ODM) или объектно-реляционной модели (ORM). ODM / ORM представляют данные веб-сайта как объекты JavaScript, которые затем отображаются на поддерживающую базу данных. Некоторые ORM привязаны к определённой базе данных, тогда как другие не зависят от конкретной базы данных.

Наилучшую производительность можно получить с помощью SQL или другого языка запросов, поддерживаемого базой данных. Объектные модели (ODM) часто медленнее, потому что требуют перевода объектов в формат базы данных, при этом не обязательно будут использованы наиболее эффективные запросы к базе данных (особенно, если ODM предназначена для различных баз данных и должна идти на большие компромиссы в смысле поддержки тех или иных функций базы данных).

Преимущество применения ORM состоит в том, что программисты могут сосредоточиться на объектах JavaScript, а не на семантике базы данных — особенно, если требуется работать с разными базами данных (на одном или разных веб-сайтах). Они также дают очевидное место для валидации и проверки данных.

> [!NOTE]
> Совет: Применение ODM / ORMs часто приводит к снижению затрат на разработку и обслуживание! Если вы не очень хорошо знакомы с языком запросов базы данных или если производительность не имеет первостепенного значения, следует серьёзно рассмотреть возможность применения ODM.

### Какую модель ORM/ODM следует использовать?

Есть много ODM/ORM доступных решений на сайте менеджера пакетов NPM (проверьте теги по подгруппе [odm](https://www.npmjs.com/browse/keyword/odm) и [orm](https://www.npmjs.com/browse/keyword/orm)).

Популярные решения на момент написания статьи:

- [Mongoose](https://www.npmjs.com/package/mongoose): — это средство моделирование объектов базы данных [MongoDB](https://www.mongodb.org/), предназначенное для асинхронной работы.
- [Waterline](https://www.npmjs.com/package/waterline): ORM фреймворка [Sails](http://sailsjs.com/) (основан на Express) . Она предоставляет единый API для доступа к множеству баз данных, в том числе Redis, mySQL, LDAP, MongoDB, и Postgres.
- [Bookshelf](https://www.npmjs.com/package/bookshelf): поддерживает как promise- так и традиционные callback- интерфейсы, поддержка транзакций, eager/nested-eager relation loading, полиморфные ассоциации, и поддержка, один к одному, один ко многим, и многие ко многим. Работает с PostgreSQL, MySQL, и SQLite3.
- [Objection](https://www.npmjs.com/package/objection): Делает настолько лёгким, насколько возможно, использование всей мощи SQL и движка базы данных ( поддерживает SQLite3, Postgres, и MySQL).
- [Sequelize](https://www.npmjs.com/package/sequelize): Основанная на промисах ORM для Node.js и [io.js](https://ru.wikipedia.org/wiki/Io.js). Поддерживает диалекты PostgreSQL, MySQL, MariaDB, SQLite и MSSQL, обладает надёжной поддержкой транзакций, отношений, чтения копий и т.д.
- [GraphQL](https://graphql.org/): В первую очередь язык запросов для RESTful API, GraphQL очень популярен и имеет возможности для чтения данных из баз данных.

Как правило, при выборе решения следует учитывать как предоставляемые функции, так и "деятельность сообщества" ( загрузки, вклад, отчёты об ошибках, качество документации, и т.д. ) . На момент написания статьи Mongoose являлась очень популярной ODM, и разумно, если вы выбрали MongoDB.

### Применение Mongoose и MongoDb для LocalLibrary

В примере LocalLibrary (и до конца раздела) мы будем использовать [Mongoose ODM](https://www.npmjs.com/package/mongoose) для доступа к данным нашей библиотеки. Mongoose является интерфейсом для [MongoDB](https://www.mongodb.com/company/what-is-mongodb), [NoSQL](https://en.wikipedia.org/wiki/NoSQL)-базы данных с открытым исходным кодом, в которой использована документов-ориентированная модель данных. В MongoDB «коллекции» и «документы» — это [аналоги](https://www.mongodb.com/docs/manual/core/databases-and-collections/) «таблиц» и «строк» в реляционных БД.

Это сочетание ODM и БД весьма популярно в сообществе Node, частично потому, что система хранения документов и запросов очень похожа на JSON и поэтому знакома разработчикам JavaScript.

> [!NOTE]
> Не обязательно знать MongoDB, чтобы использовать Mongoose, хотя [документацию Mongoose](http://mongoosejs.com/docs/guide.html) легче использовать и понимать, если вы уже знакомы с MongoDB.

Далее показано, как определить и получить доступ к схеме и моделям Mongoose для примера [веб-сайта LocalLibrary](/ru/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/Tutorial_local_library_website).

## Проектирование моделей LocalLibrary

Прежде чем начинать писать код моделей, стоит обдумать, какие данные нам нужно хранить, и каковы отношения между разными объектами.

Мы знаем, что нужно хранить информацию о книгах (название, резюме (краткое описание), автор, жанр, ISBN (Международный стандартный книжный номер) ) и что может быть несколько доступных экземпляров (с уникальными идентификаторами, статусом наличия и т. д.). Может потребоваться хранить больше информации об авторе (не только имя, т.к. могут быть авторы с одинаковыми или похожими именами). Мы хотим иметь возможность сортировать данные по названиям книг, по авторам, по жанрам и категориям.

При проектировании моделей имеет смысл иметь отдельные модели для каждого «объекта» (группы связанных данных). В этом случае очевидными объектами являются книги, экземпляры книг и авторы.

Можно также использовать модели для представления параметров списка выбора (например, как выпадающий список вариантов), вместо жёсткого кодирования выбора на самом веб-сайте - рекомендуется, когда не все параметры известны или могут быть изменены. Явный кандидат для модели такого типа — это жанр книги (например, «Научная фантастика», «Французская поэзия» и т.д.),

Как только мы определились с моделями и полями, следует подумать об отношениях между ними.

С учётом сказанного, UML-диаграмма связей (см. ниже) показывает модели, которые представлены как прямоугольники. Мы решили, что создадим модели для книги (общие сведения о книге), для экземпляра книги (состояние отдельных физических копий книги, доступных в системе) и для автора. Кроме того, у нас будет модель для жанра, чтобы эти значения можно было создавать динамически. Решено не создавать модель для `BookInstance:status` — мы пропишем в коде необходимые значения, потому что не ожидаем их изменения. На элементах диаграммы показаны имя модели, имена и типы полей, имена методов и типы их результатов .

Также показаны отношения между моделями, включая множественные отношения. Числа на линиях связи показывают максимум и минимум моделей, участвующих отношении. Например, линия между `Book` и `Genre` показывает, что `Book` и `Genre` связаны. Числа на этой линии рядом с моделью `Book` показывают, что жанр может быть связан с любым количеством книг, а числа на другом конце линии рядом с `Genre` отмечают, что книга может быть связана с любым количеством жанров.

> [!NOTE]
> Как показано в [Учебнике по Mongoose](#mongoose_справочник) ниже, часто лучше иметь поле, определяющее отношение между документами (моделями), только в одной модели (обратное отношение можно найти по присвоенному идентификатору `_id` в другой модели). Ниже мы предпочли задать отношения между `Book`/`Genre` и между `Book`/`Author` в схеме Book, а отношение между `Book`/`BookInstance` — в схеме `BookInstance`. Этот выбор в некотором смысле был произвольным — таким же хорошим мог бы быть выбор другого поля в другой схеме.

![Mongoose Library Model with correct cardinality](library_website_-_mongoose_express.png)

> [!NOTE]
> В следующем разделе дан базовый учебник, в котором объясняется, как задавать и как использовать модели. При чтении обратите внимание, как будут создаваться модели, приведённые на диаграмме.

### API базы данных являются асинхронными

Методы базы данных для создания, поиска, обновления или удаления записей выполняются асинхронно.
Это означает, что методы возвращают управление сразу, а код для обработки успеха или ошибки выполняется позже, когда операция завершится.
Другой код может исполняться, пока сервер ждёт окончания операции с базой данных, и сервер остаётся отзывчивым к другим запросам.

В JavaScript существует несколько способов поддержки асинхронного поведения.
Исторически часто использовались [функции-коллбеки](/ru/docs/Learn_web_development/Extensions/Async_JS/Introducing), передаваемые в асинхронные методы для обработки успеха и ошибок.
В современном JavaScript коллбеки в основном заменены на [Promises](/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise).
Promise — это объект, который сразу возвращается асинхронным методом и представляет его будущий результат.
Когда операция завершается, promise «разрешается» и возвращает объект с результатом или ошибкой.

Есть два основных способа запускать код, когда promise завершён [Как использовать Promises](/ru/docs/Learn_web_development/Extensions/Async_JS/Promises), чтобы получить общее представление об обоих подходах.
В этом учебнике мы будем использовать в основном [`await`](/ru/docs/Web/JavaScript/Reference/Operators/await) внутри [`async function`](/ru/docs/Web/JavaScript/Reference/Statements/async_function), так как это делает код асинхронных операций более читаемым и понятным.

Смысл подхода в том, что ключевое слово `async` помечает функцию как асинхронную.
Внутри этой функции мы применяем `await` к любому методу, который возвращает promise.
С точки зрения окружающего кода асинхронная функция сразу возвращает управление, и следующий за ней код может выполняться. Позже, когда promise завершается, оператор `await` внутри асинхронной функции возвращает результат, либо выбрасывается ошибка, если promise был отклонён.
Затем код внутри асинхронной функции продолжает выполняться до тех пор, пока не встретит следующий `await` (тогда выполнение снова приостановится) или пока не будет выполнен весь код функции.

Вы можете увидеть, как это работает, в примере ниже.
`myFunction()` — это асинхронная функция, которая вызывается внутри блока [`try...catch`](/ru/docs/Web/JavaScript/Reference/Statements/try...catch).
Когда запускается `myFunction()`, выполнение кода приостанавливается на `methodThatReturnsPromise()`, пока promise не будет завершён.
После этого код продолжается на `functionThatReturnsPromise()` и снова ждёт.
Код в блоке `catch` выполняется, если в асинхронной функции выбрасывается ошибка, и это произойдёт, если promise, возвращённый любым из методов, будет отклонён.

```js
async function myFunction() {
  // …
  await someObject.methodThatReturnsPromise();
  // …
  await functionThatReturnsPromise();
  // …
}

try {
  // …
  myFunction();
  // …
} catch (e) {
  // обработка ошибки
}
```

Асинхронные методы выше выполняются последовательно.
Если методы не зависят друг от друга, то их можно запускать параллельно и закончить всю операцию быстрее.
Это делается с помощью метода [`Promise.all()`](/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/all), который принимает набор promises и возвращает один общий `Promise`.
Этот возвращённый promise выполняется успешно, когда все входные promises завершились, и результатом будет массив их значений.
Если любой из входных promises будет отклонён, общий promise тоже будет отклонён с причиной этого первого отклонения.

Ниже показан пример того, как это работает.
Сначала у нас есть две функции, которые возвращают promises.
Мы используем `await`, чтобы дождаться завершения обеих функций с помощью promise, возвращаемого `Promise.all()`.
Как только они оба завершились, `await` возвращает результат в виде массива, и функция продолжает выполнение до следующего `await`, где ждёт promise от `anotherFunctionThatReturnsPromise()`.
Вызывать `myFunction()` необходимо внутри блока `try...catch`, чтобы отлавливать возможные ошибки.

```js
async function myFunction() {
  // …
  const [resultFunction1, resultFunction2] = await Promise.all([
    functionThatReturnsPromise1(),
    functionThatReturnsPromise2(),
  ]);
  // …
  await anotherFunctionThatReturnsPromise(resultFunction1);
}
```

Promises вместе с `async/await` позволяют гибко и в то же время понятно управлять асинхронным выполнением.

## Учебник по Mongoose

В этом разделе кратко описано, как подключиться к базе MongoDB с помощью Mongoose, как определить схемы и модели, как сформировать основные запросы.

> [!NOTE]
> На этот учебник значительно повлияло руководство [Mongoose quick start](https://www.npmjs.com/package/mongoose) на _npm_ и [официальная документация](http://mongoosejs.com/docs/guide.html).

### Установка Mongoose и MongoDB

Mongoose устанавливается в ваш проект (**package.json**) как и другие зависимости - при помощи NPM. Команда установки (выполняется из каталога проекта):

```bash
npm install mongoose
```

Установка _Mongoose_ добавит все зависимости, включая драйвер MongoDB, но не установит саму базу данных. При желании установить сервер MongoDB локально, можно [скачать установочный файл здесь](https://www.mongodb.com/download-center) для своей операционной системы и установить его. Также можно использовать облако MongoDB.

> [!NOTE]
> В этом руководстве мы будем использовать бесплатный тариф облачного сервиса [MongoDB Atlas](https://www.mongodb.com/) _database as a service_ для базы данных. Это удобно для разработки и подходит для учебного примера, так как делает «установку» независимой от операционной системы (database-as-a-service — это также один из вариантов, который можно использовать и в продакшене).

### Подключение к MongoDB

_Mongoose_ требует подключения к базе данных MongoDB.
Вы можете использовать `require()` и подключиться к локально запущенной базе данных с помощью `mongoose.connect()`, как показано ниже (в этом учебнике мы вместо этого будем подключаться к базе данных, размещённой в интернете).

```js
// Импортируем модуль mongoose
const mongoose = require("mongoose");

// Устанавливаем `strictQuery: false`, чтобы глобально разрешить фильтрацию по свойствам,
// которых нет в схеме. Это убирает подготовительные предупреждения для Mongoose 7.
// См.: https://mongoosejs.com/docs/migrating_to_6.html#strictquery-is-removed-and-replaced-by-strict
mongoose.set("strictQuery", false);

// Определяем URL базы данных для подключения.
const mongoDB = "mongodb://127.0.0.1/my_database";

// Ждём подключения к базе данных и выводим ошибку, если что-то пойдёт не так
main().catch((err) => console.log(err));
async function main() {
  await mongoose.connect(mongoDB);
}
```

> [!NOTE]
> Как обсуждалось в разделе [API базы данных являются асинхронными](#api-базы-данных-являются-асинхронными), здесь мы используем `await` для promise, возвращаемого методом `connect()`, внутри `async`-функции.
> Для обработки ошибок при попытке подключения используется обработчик `catch()`, но мы также могли бы вызвать `main()` внутри блока `try...catch`.

Вы можете получить объект `Connection` по умолчанию с помощью `mongoose.connection`.
Если нужно создать дополнительные подключения, используйте `mongoose.createConnection()`.
Он принимает тот же формат URI базы данных (хост, база, порт, опции и т. д.), что и `connect`(), и возвращает объект `Connection`.
Учтите, что `createConnection()` возвращает управление сразу; если нужно дождаться установления соединения, вызовите его с `asPromise()`, чтобы получить promise (`mongoose.createConnection(mongoDB).asPromise()`).

### Определение и создание моделей

Модели можно создать при помощи интерфейса `Schema` . Schema позволяет указать поля, которые будут в каждом документе, значения полей по умолчанию и требования по валидации. Кроме того, можно задать статические методы и методы-хелперы (от help), облегчающие работу с вашими типами данных, а также задать виртуальные свойства, которые можно использовать как и обычные поля, но без влияния на данные в самой базе данных.

Схемы "компилируются " в окончательную модель методом `mongoose.model()`. После создания модели её можно использовать для поиска, создания, обновления и удаления объектов данного типа.

> [!NOTE]
> Каждой модели соответствует _коллекция_ _документов_ в ДБ MongoDB. Документы будут содержать поля тех типов, которые заданы в модели `Schema`.

#### Определение схем данных

Код ниже показывает, как можно задать простую схему. Сначала при помощи `require()` создаётся объект mongoose, затем конструктор Schema создаёт новый экземпляр схемы, при этом различные поля задаются как параметры конструктора.

```js
//Требуется Mongoose
const mongoose = require("mongoose");

//Определяем схему
const Schema = mongoose.Schema;

const SomeModelSchema = new Schema({
  a_string: String,
  a_date: Date,
});
```

В примере созданы два поля, типа String и типа Date. В следующем разделе будут примеры полей других типов, их валидации и примеры других методов.

#### Создание модели

Модели создаются из схем методом `mongoose.model()`:

```js
// Определяем схему
const Schema = mongoose.Schema;

const SomeModelSchema = new Schema({
  a_string: String,
  a_date: Date,
});

// Компилируем модель из схемы
const SomeModel = mongoose.model("SomeModel", SomeModelSchema);
```

Первый аргумент - уникальное имя создаваемой для модели коллекции(Mongoose создаст коллекцию для модели _SomeModel_), второй аргумент - схема, которая используется для создания модели.

> [!NOTE]
> После создания классов модели они могут применяться для создания, обновления или удаления записей в базе, для выполнения запросов по всем записям или по их подмножествам. Как это делать, будет показано в разделе [Применение моделей](#применение-моделей), и когда будут создаваться представления.

#### Типы схемы (поля)

Схема может содержать любое количество полей, при этом каждое поле будет полем документа, хранимого в БД _MongoDB_. Схема-пример содержит определения многих широко используемых типов полей.

```js
const schema = new Schema({
  name: String,
  binary: Buffer,
  living: Boolean,
  updated: { type: Date, default: Date.now() },
  age: { type: Number, min: 18, max: 65, required: true },
  mixed: Schema.Types.Mixed,
  _someId: Schema.Types.ObjectId,
  array: [],
  ofString: [String], // Вы также можете использовать массив для любого из других типов.
  nested: { stuff: { type: String, lowercase: true, trim: true } },
});
```

Большинство типов в [SchemaTypes](http://mongoosejs.com/docs/schematypes.html) (указаны после "type:" или после имён полей) достаточно очевидны. Исключения:

- `ObjectId`: Представляет отдельный экземпляр модели в БД. Например, book может ссылаться на объект- автора. Поле будет содержать уникальный идентификатор (`_id`) отдельного объекта. При необходимости использования этой информации применяют метод `populate()`.
- [Mixed](http://mongoosejs.com/docs/schematypes.html#mixed): Произвольный тип в схеме.
- \[]: Массив элементов. В таких моделях можно выполнять JavaScript-операции для массивов (push, pop, unshift, etc.). Выше показан пример массива объектов неопределённого типа и массив строк, но можно использовать массив объектов любого типа.

Код содержит также два способа объявления полей:

- _Имя_ и _тип_ поля как пара "ключ-значение" (поля `name`, `binary и` `living`).
- _Имя_ поля, после которого указывается объект, определяющий _тип_ и другие _возможности_ поля, такие как:
  - значения по умолчанию.
  - встроенные валидаторы (например, значения max и min) и функции-валидаторы пользователя.
  - Является ли поле обязательным
  - Должны ли строковые поля автоматически преобразовываться в нижний или верхний регистр, удалять ли ведущие и хвостовые пробелы (`пример:` `{ type: String, lowercase: true, trim: true }`)

Дополнительная информация - в [SchemaTypes](http://mongoosejs.com/docs/schematypes.html) (документация Mongoose).

#### Валидация (проверка допустимости)

Mongoose предусматривает встроенные валидаторы, валидаторы пользователя, синхронные и асинхронные валидаторы. Во всех случаях можно задать допустимые диапазоны или значения, а также сообщения об ошибках при нарушении условий валидации.

Встроенные валидаторы включают:

- Все [SchemaTypes](https://mongoosejs.com/docs/schematypes.html) имеют встроенный валидатор [required](https://mongoosejs.com/docs/api.html#schematype_SchemaType-required). Он используется для указания того, должно ли поле быть заполнено, чтобы документ можно было сохранить.
- [Numbers](https://mongoosejs.com/docs/api/schemanumber.html) имеют валидаторы [min](https://mongoosejs.com/docs/api/schemanumber.html#SchemaNumber.prototype.min%28%29) и [max](https://mongoosejs.com/docs/api/schemanumber.html#SchemaNumber.prototype.max%28%29).
- [Strings](https://mongoosejs.com/docs/api/schemastring.html) имеют:
  - [enum](https://mongoosejs.com/docs/api/schemastring.html#SchemaString.prototype.enum%28%29): задаёт набор допустимых значений для поля.
  - [match](https://mongoosejs.com/docs/api/schemastring.html#SchemaString.prototype.match%28%29): задаёт регулярное выражение, которому должна соответствовать строка.
  - [maxLength](https://mongoosejs.com/docs/api/schemastring.html#SchemaString.prototype.maxlength%28%29) и [minLength](https://mongoosejs.com/docs/api/schemastring.html#SchemaString.prototype.minlength%28%29) для строки.

Пример ниже (с небольшими изменениями из документации Mongoose) показывает, как задать некоторые валидаторы и сообщения об ошибках:

```js
const breakfastSchema = new Schema({
  eggs: {
    type: Number,
    min: [6, "Too few eggs"],
    max: 12,
    required: [true, "Why no eggs?"],
  },
  drink: {
    type: String,
    enum: ["Coffee", "Tea", "Water"],
  },
});
```

Подробная информация по валидации полей - в разделе [Validation](http://mongoosejs.com/docs/validation.html) (документация Mongoose).

#### Виртуальные свойства

Виртуальные свойства - это свойства документа, которые можно читать (get) и задавать (set), но которые не хранятся в MongoDB. Методы "геттеры" полезны для форматирования и соединения полей, а "сеттеры" применяют для декомпозиции отдельных значений на несколько частей перед сохранением в БД. Пример из документации собирает (и разбирает) виртуальное свойство "полное имя" из полей "имя" и "фамилия", что удобнее, чем конструировать полное имя каждый раз, когда оно используется в шаблоне.

> [!NOTE]
> В библиотеке виртуальное свойство будет применено для определения уникального URL каждой записи в модели по пути и по значению `_id` записи.

Подробная информация - в разделе [Virtuals](http://mongoosejs.com/docs/guide.html#virtuals) (документация Mongoose).

#### Методы и помощники запросов

В схеме можно также задать методы экземпляра ([instance methods](http://mongoosejs.com/docs/guide.html#methods)), статические ([static](http://mongoosejs.com/docs/guide.html#statics)) методы и [помощники запросов](http://mongoosejs.com/docs/guide.html#query-helpers). Статические методы и методы экземпляра аналогичны, но различаются тем, что методы экземпляра связаны с конкретной записью и имеют доступ к текущему объекту. Помощники запросов позволяют расширить [API построителя цепочек запросов](http://mongoosejs.com/docs/queries.html) (например, можно добавить запрос "byName" ("по имени") в дополнение к методам `find()`, `findOne()` и `findById()`).

### Применение моделей

Подготовленную схему можно использовать для создания моделей. Модель представляет коллекцию документов в базе данных, в которой можно выполнять поиск, тогда как экземпляры модели представляют отдельные документы, которые можно сохранять и извлекать.

Ниже предлагается краткий обзор. Более подробно смотрите в [Models](http://mongoosejs.com/docs/models.html) (документация Mongoose).

> [!NOTE]
> Создание, обновление, удаление и запрос записей — это асинхронные операции, которые возвращают [promise](/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise).
> В примерах ниже показано только использование соответствующих методов и `await` (т.е. основной код для работы с методами).
> Внешняя `async function` и блок `try...catch` для перехвата ошибок опущены для наглядности.
> Подробнее об использовании `await/async` см. выше в разделе [API базы данных являются асинхронными](#api-базы-данных-являются-асинхронными).

#### Создание и изменение документов

Чтобы создать запись, вы можете определить экземпляр модели и затем вызвать у него метод [`save()`](https://mongoosejs.com/docs/api/model.html#Model.prototype.save).
В примерах ниже предполагается, что `SomeModel` — это модель (с единственным полем `name`), которую мы создали из нашей схемы.

```js
// Создаём экземпляр модели SomeModel
const awesome_instance = new SomeModel({ name: "awesome" });

// Сохраняем новый экземпляр модели асинхронно
await awesome_instance.save();
```

Вы также можете использовать [`create()`](https://mongoosejs.com/docs/api/model.html#Model.create), чтобы определить экземпляр модели одновременно с его сохранением.
Ниже мы создаём только один экземпляр, но можно создать несколько, передав массив объектов.

```js
await SomeModel.create({ name: "also_awesome" });
```

У каждой модели есть связанное подключение (по умолчанию это подключение, используемое при вызове `mongoose.model()`). Вы можете создать новое подключение и вызвать у него `.model()`, чтобы создавать документы в другой базе данных.

К полям новой записи можно обращаться через точечный синтаксис и изменять их значения.
Чтобы сохранить изменённые значения обратно в базу данных, необходимо вызвать `save()` или `update()`.

```js
// Доступ к значениям полей модели через точечный синтаксис
console.log(awesome_instance.name); // выведет 'also_awesome'

// Изменяем запись, модифицируя поля и затем вызывая save().
awesome_instance.name = "New cool name";
await awesome_instance.save();
```

#### Поиск записей

При поиске записей методами запросов, условия поиска следует задавать как документ JSON. Приведённый фрагмент кода (ниже) показывает, как в БД найти имена (_name_) и возраст (_age_) всех спортсменов-теннисистов. Соответствие будет определяться по одному полю (sport), но можно добавить критерии поиска, задав, например, регулярное выражение, или удалить все критерии, чтобы получить список всех спортсменов.

```js
const Athlete = mongoose.model("Athlete", yourSchema);

// найти всех спортсменов, которые играют в теннис, возвращая поля 'name' и 'age'
const tennisPlayers = await Athlete.find(
  { sport: "Tennis" },
  "name age",
).exec();
```

> [!NOTE]
> Важно помнить, что отсутствие результатов при поиске — это **не ошибка**, хотя в контексте вашего приложения это может считаться неудачным случаем.
> Если приложение ожидает, что поиск найдёт значение, вы можете проверить количество записей, возвращённых в результате.

API запросов, такие как [`find()`](<https://mongoosejs.com/docs/api/model.html#Model.find()>), возвращают переменную типа [Query](https://mongoosejs.com/docs/api/query.html).
Вы можете использовать объект запроса для построения запроса по частям, а затем выполнить его методом [`exec()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.exec).
`exec()` выполняет запрос и возвращает promise, результат которого можно дождаться через `await`.

```js
// найти всех спортсменов, которые играют в теннис
const query = Athlete.find({ sport: "Tennis" });

// выбрать поля 'name' и 'age'
query.select("name age");

// ограничить результат пятью элементами
query.limit(5);

// сортировка по возрасту
query.sort({ age: -1 });

// выполнить запрос позже
query.exec();
```

Выше мы определили условия запроса в методе [`find()`](<https://mongoosejs.com/docs/api/model.html#Model.find()>).
То же самое можно сделать с помощью функции [`where()`](<https://mongoosejs.com/docs/api/model.html#Model.where()>), а все части запроса можно объединять цепочкой через оператор точки (.), вместо добавления их отдельно.
Фрагмент ниже эквивалентен предыдущему, но содержит дополнительное условие по возрасту.

```js
Athlete.find()
  .where("sport")
  .equals("Tennis")
  .where("age")
  .gt(17)
  .lt(50) // Дополнительное условие where
  .limit(5)
  .sort({ age: -1 })
  .select("name age")
  .exec();
```

Метод [`find()`](<https://mongoosejs.com/docs/api/model.html#Model.find()>) возвращает все совпадающие записи, но часто нужно получить только одну. Для этого существуют следующие методы:

- [`findById()`](<https://mongoosejs.com/docs/api/model.html#Model.findById()>): находит документ с указанным `id` (каждый документ имеет уникальный `id`).
- [`findOne()`](<https://mongoosejs.com/docs/api/model.html#Model.findOne()>): находит один документ, соответствующий заданным критериям.
- [`findByIdAndDelete()`](<https://mongoosejs.com/docs/api/model.html#Model.findByIdAndDelete()>), [`findByIdAndUpdate()`](<https://mongoosejs.com/docs/api/model.html#Model.findByIdAndUpdate()>), [`findOneAndRemove()`](<https://mongoosejs.com/docs/api/model.html#Model.findOneAndRemove()>), [`findOneAndUpdate()`](<https://mongoosejs.com/docs/api/model.html#Model.findOneAndUpdate()>): находят один документ по `id` или критериям и либо обновляют, либо удаляют его. Эти функции удобны для обновления и удаления записей.

> [!NOTE]
> Существует также метод [`countDocuments()`](<https://mongoosejs.com/docs/api/model.html#Model.countDocuments()>), который можно использовать, чтобы получить количество элементов, соответствующих условиям. Это полезно, если нужно посчитать записи, не извлекая их полностью.

С запросами можно делать гораздо больше. Подробнее см. [Queries](https://mongoosejs.com/docs/queries.html) (документация Mongoose).

#### Работа со связанными документами — загрузка

Один документ (экземпляр модели) может ссылаться на другой документ при помощи поля `ObjectId` схемы, или на много других документов, используя массив идентификаторов `ObjectIds`. Идентификатор соответствующей модели хранится в поле. При необходимости получить действительное содержимое связанного документа, следует использовать в запросе метод [`populate()`](http://mongoosejs.com/docs/api.html#query_Query-populate), который _в итоговом документе_ заменит идентификатор на соответствующие данные.

Например, в следующей схеме определены авторы и рассказы. У каждого автора может быть несколько рассказов, которые представим массивом ссылок of `ObjectId`. У каждого рассказа может быть только один автор. Ссылка ref указывает в схеме, какая модель должна быть связана с этим полем.

```js
const mongoose = require("mongoose");

const Schema = mongoose.Schema;

const authorSchema = new Schema({
  name: String,
  stories: [{ type: Schema.Types.ObjectId, ref: "Story" }],
});

const storySchema = new Schema({
  author: { type: Schema.Types.ObjectId, ref: "Author" },
  title: String,
});

const Story = mongoose.model("Story", storySchema);
const Author = mongoose.model("Author", authorSchema);
```

Можно сохранить ссылки в связанном документе, используя значение идентификатора `_id`. Ниже создаётся автор, затем рассказ, и значение идентификатора id автора сохраняется в поле "author" рассказа.

```js
const bob = new Author({ name: "Bob Smith" });

await bob.save();

//автор Bob создан, создаём рассказ
const story = new Story({
  title: "Bob goes sledding",
  author: bob._id, // присваиваем полю значение идентификатора Боба. Идентификатор создаётся по умолчанию!
});

await story.save();
```

> [!NOTE]
> Одним из больших преимуществ такого стиля программирования является то, что нам не нужно усложнять основной путь выполнения кода проверкой ошибок.
> Если любая операция `save()` завершится неудачно, promise будет отклонён и будет выброшена ошибка.
> Код обработки ошибок разбирается с этим отдельно (обычно в блоке `catch()`), поэтому намерение нашего кода остаётся очень ясным.

Теперь документ "story" ссылается на автора по идентификатору документа "author". Для получения информации об авторе применяется метод [`populate()`](https://mongoosejs.com/docs/api/model.html#Model.populate), как показано ниже.

```js
Story.findOne({ title: "Bob goes sledding" })
  .populate("author") //подменяет идентификатор автора информацией об авторе!
  .exec();
```

> [!NOTE]
> Внимательные читатели заметили, что автор добавлен к рассказу, но ничего не сделано, чтобы добавить рассказ к массиву рассказов `stories` автора. Как же тогда получить список всех рассказов конкретного автора? Один из возможных вариантов - добавить автора в массив рассказов, но при этом пришлось бы хранить данные об авторах и рассказах в двух местах и поддерживать их актуальность.
>
> Лучше получить `_id` нашего автора _author_, и применить `find()` для поиска этого идентификатора в поле "author" всех рассказов.
>
> ```js
> Story.find({ author: bob._id }).exec();
> ```

Это почти все, что следует знать для работы со связанными данными _в нашем руководстве_. Более полную информацию можно найти в [Population](https://mongoosejs.com/docs/populate.html) (документация Mongoose).

### Одна схема (модель) - один файл

Можно использовать любую структуру файлов при создании схем и моделей, однако мы настоятельно рекомендуем определять каждую схему модели в отдельном модуле (файле), экспортируя метод для создания модели. Пример приведён ниже:

```js
// Файл: ./models/somemodel.js

//Требуется Mongoose
var mongoose = require("mongoose");

//Определяем схему
var Schema = mongoose.Schema;

var SomeModelSchema = new Schema({
  a_string: String,
  a_date: Date,
});

//экспортируется функция для содания класса модели "SomeModel"
module.exports = mongoose.model("SomeModel", SomeModelSchema);
```

Вы можете затем подключить модель с помощью require и сразу использовать её в других файлах. Ниже показано, как можно применить её для получения всех экземпляров модели.

```js
//Создаём модель SomeModel просто вызовом модуля из файла
const SomeModel = require("../models/some-model");

// Используем объект SomeModel (модель) для поиска всех записей в SomeModel
const modelInstances = await SomeModel.find().exec();
```

## Установка базы данных MongoDB

Мы уже немного понимаем, что может делать Mongoose и как следует проектировать модели. Теперь самое время начать работу над сайтом LocalLibrary. Самое первое, что мы должны сделать - установить базу данных MongoDb, в которой будут храниться данные нашей библиотеки.

В этом руководстве мы будем использовать облачную sandbox-базу данных [MongoDB Atlas](https://www.mongodb.com/products/platform/atlas-database). Этот тариф базы данных не считается подходящим для сайтов в продакшене, потому что в нём нет избыточности, но он отлично подходит для разработки и прототипирования. Мы используем его здесь, потому что он бесплатный и легко настраивается, а также потому, что MongoDB Atlas является популярным поставщиком _database as a service_, которого вы вполне можете выбрать и для своей продакшен версии базы данных (другие популярные варианты на момент написания включают [ScaleGrid](https://scalegrid.io/) и [ObjectRocket](https://www.objectrocket.com/)).

> [!NOTE]
> Если вы предпочитаете, вы можете настроить базу данных MongoDB локально, скачав и установив [подходящие бинарные файлы для вашей системы](https://www.mongodb.com/try/download/community-edition/releases). Остальные инструкции в этой статье будут похожи, за исключением URL базы данных, который вы укажете при подключении.
> В учебнике [Express Tutorial Part 7: Deploying to Production](/ru/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/deployment) мы размещаем и приложение, и базу данных на [Railway](https://railway.com/), но мы в равной степени могли бы использовать базу данных на [MongoDB Atlas](https://www.mongodb.com/products/platform/atlas-database).

Сначала вам нужно [создать аккаунт](https://www.mongodb.com/cloud/atlas/register) в MongoDB Atlas (это бесплатно, и требуется только ввести базовую контактную информацию и принять условия использования).

После входа вы попадёте на экран [home](https://cloud.mongodb.com/v2):

1. Нажмите кнопку **+ Create** в разделе _Overview_.

   ![Create a database on MongoDB Atlas.](mongodb_atlas_-_createdatabase.jpg)

2. Откроется экран _Deploy your cluster_.
   Нажмите на шаблон **M0 FREE**.

   ![Choose a deployment option when using MongoDB Atlas.](mongodb_atlas_-_deploy.jpg)

3. Пролистайте страницу вниз, чтобы увидеть доступные варианты.
   ![Choose a cloud provider when using MongoDB Atlas.](mongodb_atlas_-_createsharedcluster.jpg)
   - Вы можете изменить имя вашего кластера в поле _Cluster Name_.
     Мы оставляем `Cluster0` для этого учебника.
   - Снимите флажок _Preload sample dataset_, так как мы позже импортируем собственные данные.
   - Выберите любого провайдера и регион в разделах _Provider_ и _Region_. Разные регионы предлагают разных провайдеров.
   - Теги являются необязательными. Мы не будем их использовать здесь.
   - Нажмите кнопку **Create deployment** (создание кластера займёт несколько минут).

4. Откроется раздел _Security Quickstart_.
   ![Set up the Access Rules on the Security Quickstart screen on MongoDB Atlas.](mongodb_atlas_-_securityquickstart.jpg)
   - Введите имя пользователя и пароль, которые ваше приложение будет использовать для доступа к базе данных (выше мы создали новый логин "cooluser").
     Не забудьте скопировать и сохранить учётные данные, так как они понадобятся позже.
     Нажмите кнопку **Create User**.

     > [!NOTE]
     > Избегайте использования специальных символов в пароле пользователя MongoDB, так как mongoose может некорректно обработать строку подключения.

   - Выберите **Add by current IP address**, чтобы разрешить доступ с вашего текущего компьютера.

   - Введите `0.0.0.0/0` в поле IP Address и нажмите кнопку **Add Entry**.
     Это говорит MongoDB, что мы хотим разрешить доступ откуда угодно.

     > [!NOTE]
     > Наилучшей практикой является ограничение IP-адресов, которые могут подключаться к вашей базе данных и другим ресурсам. Здесь мы разрешаем подключение откуда угодно, потому что мы не знаем, откуда будет идти запрос после деплоя.

   - Нажмите кнопку **Finish and Close**.

5. Откроется следующий экран. Нажмите кнопку **Go to Overview**.
   ![Go to Databases after setting up Access Rules on MongoDB Atlas](mongodb_atlas_-_accessrules.jpg)

6. Вы вернётесь на экран _Overview_. Нажмите на раздел _Database_ в меню _Deployment_ слева. Нажмите кнопку **Browse Collections**.
   ![Setup a collection on MongoDB Atlas.](mongodb_atlas_-_createcollection.jpg)

7. Откроется раздел _Collections_. Нажмите кнопку **Add My Own Data**.
   ![Create a database on MongoDB Atlas.](mongodb_atlas_-_adddata.jpg)

8. Откроется экран _Create Database_.

   ![Details during database creation on MongoDB Atlas.](mongodb_atlas_-_databasedetails.jpg)
   - Введите имя для новой базы данных как `local_library`.
   - Введите имя коллекции как `Collection0`.
   - Нажмите кнопку **Create**, чтобы создать базу данных.

9. Вы вернётесь в раздел _Collections_ с созданной базой данных.
   ![Database creation confirmation on MongoDB Atlas.](mongodb_atlas_-_databasecreated.jpg)
   - Нажмите вкладку _Overview_, чтобы вернуться к обзору кластера.

10. На экране _Cluster0 Overview_ нажмите кнопку **Connect**.

    ![Configure connection after setting up a cluster in MongoDB Atlas.](mongodb_atlas_-_connectbutton.jpg)

11. Откроется экран _Connect to Cluster0_.

    ![Choose the Short SRV connection when setting up a connection on MongoDB Atlas.](mongodb_atlas_-_connectforshortsrv.jpg)
    - Выберите своего пользователя базы данных.
    - Выберите категорию _Drivers_, затем _Driver_ **Node.js** и _Version_, как показано.
    - **НЕ** устанавливайте драйвер, как предлагается.
    - Нажмите иконку **Copy**, чтобы скопировать строку подключения.
    - Вставьте её в ваш локальный текстовый редактор.
    - Замените плейсхолдер `<password>` в строке подключения на пароль вашего пользователя.
    - Вставьте имя базы данных "local_library" в путь перед параметрами (`...mongodb.net/local_library?retryWrites...`).
    - Сохраните файл с этой строкой где-нибудь в безопасном месте.

Теперь вы создали базу данных и получили URL (с именем пользователя и паролем), который можно использовать для доступа к ней.
Он будет выглядеть примерно так:
`mongodb+srv://your_user_name:your_password@cluster0.cojoign.mongodb.net/local_library?retryWrites=true&w=majority&appName=Cluster0`

## Установка Mongoose

Откройте окно команд и перейдите в каталог, в котором создан [каркас веб-сайта Local Library](/ru/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/skeleton_website). Введите команду install, чтобы установить Mongoose (и её зависимости), а также добавьте её в файл **package.json**, если вы ещё не сделали этого ранее, при чтении [Учебника по Mongoose](#учебник-по-mongoose).

```bash
npm install mongoose
```

## Подключение к MongoDB

Откройте файл **bin/www** (из корня проекта) и вставьте следующий код ниже строки, где задаётся порт (после `app.set("port", port);`).
Если у вас более старая версия кода приложения, в которой используется app.js, вставьте этот же код сразу после строки var app = express();.

Замените строку URL базы данных ('_insert_your_database_url_here_') на URL вашей собственной базы данных (например, используя данные, полученные из _MongoDB Atlas_).

```js
//Устанавливаем соединение с mongoose
const mongoose = require("mongoose");

mongoose.set("strictQuery", false);
const mongoDB = "insert_your_database_url_here"; // Замените URL!

async function connectMongoose() {
  await mongoose.connect(mongoDB);
}

try {
  connectMongoose();
} catch (err) {
  console.error("Failed to connect to MongoDB:", err);
  process.exit(1);
}
```

Как указано ранее в [Учебнике по Mongoose](#учебник-по-mongoose), этот код создаёт подключение к базе данных по умолчанию и выводит ошибки в консоль.

> [!NOTE]
> В актуальной версии учебника код подключения к базе данных размещается в файле **bin/www**, сразу после строки `app.set("port", port);`.
> Это отделяет приложение от базы данных и упрощает использование другой базы данных, например, при запуске тестов.
> Если у вас более старая версия кода приложения, где используется **app.js**, вставьте этот же код сразу после строки `var app = express();`.
> В этом случае приложение и база данных связаны напрямую, что тоже работает, но менее гибко.

Обратите внимание, что жёстко прописывать учётные данные базы данных в исходном коде, как показано выше, не рекомендуется.
Здесь мы делаем это для наглядности подключения и потому, что в процессе разработки нет существенного риска утечки этих данных или повреждения конфиденциальной информации.
Мы покажем, как сделать это более безопасно при [развёртывании в продакшене](/ru/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/deployment#database_configuration)!

## Определение схемы LocalLibrary

Мы определим отдельный модуль для каждой модели как уже обсуждалось [выше](#одна-схема-модель---один-файл). Начнём с создания каталога для моделей в корне проекта (**/models**), после чего создадим отдельные файлы для каждой модели:

```
/express-locallibrary-tutorial  //the project root
  /models
    author.js
    book.js
    bookinstance.js
    genre.js
```

### Модель автора Author

Скопируйте код схемы автора `Author` (приведён ниже) в файл **./models/author.js** . В схеме определено, что у автора есть обязательные поля имени и фамилии типа `String` длиной не более 100 символов, и поля типа `Date` дата рождения и дата смерти.

```js
const mongoose = require("mongoose");

const Schema = mongoose.Schema;

const AuthorSchema = new Schema({
  first_name: { type: String, required: true, maxLength: 100 },
  family_name: { type: String, required: true, maxLength: 100 },
  date_of_birth: { type: Date },
  date_of_death: { type: Date },
});

// Виртуальное свойство полного имени автора
AuthorSchema.virtual("name").get(function () {
  // Чтобы избежать ошибок в случаях, когда у автора нет фамилии или имени
  // В таком случае возвращаем пустую строку
  let fullname = "";
  if (this.first_name && this.family_name) {
    fullname = `${this.family_name}, ${this.first_name}`;
  }

  return fullname;
});

// Виртуальное свойство URL автора
AuthorSchema.virtual("url").get(function () {
  // Не используем стрелочную функцию, так как нам нужен объект this
  return `/catalog/author/${this._id}`;
});

// Экспорт модели
module.exports = mongoose.model("Author", AuthorSchema);
```

Мы объявим также в схеме AuthorSchema [виртуальное](#виртуальные-свойства) свойство "url" , которое позволит получить абсолютный URL конкретного экземпляра модели — используем это свойство в шаблонах, если потребуется получить связь с конкретным автором.

> [!NOTE]
> Объявить в схеме URL как виртуальные свойства - хорошая идея, т.к. URL отдельного элемента при необходимости изменения требует коррекции только в одном месте.
> Сейчас связь при помощи этого URL ещё не работает, так как у нас ещё нет кода, поддерживающего маршруты для экземпляров модели. Мы добавим его позже!

В конце модуля экспортируется модель.

### Модель книги Book

Скопируйте код схемы `Book` (приведён ниже) в файл **./models/book.js**. Большая часть кода подобна коду для модели автора — объявляется схема с рядом строковых полей, с виртуальным свойством URL для получения URL конкретных книг, затем модель экспортируется.

```js
const mongoose = require("mongoose");

const Schema = mongoose.Schema;

const BookSchema = new Schema({
  title: { type: String, required: true },
  author: { type: Schema.Types.ObjectId, ref: "Author", required: true },
  summary: { type: String, required: true },
  isbn: { type: String, required: true },
  genre: [{ type: Schema.Types.ObjectId, ref: "Genre" }],
});

// Виртуальное свойство URL книги
BookSchema.virtual("url").get(function () {
  // Не используем стрелочную функцию, так как нам нужен объект
  return `/catalog/book/${this._id}`;
});

// Экспорт модели
module.exports = mongoose.model("Book", BookSchema);
```

Основное отличие в том, что созданы две ссылки на другие модели:

- author - это ссылка на единственный объект модели `Author` , обязательный элемент.
- genre (жанр) - ссылка на массив объектов модели `Genre`. Эта модель ещё не объявлена!

### Модель экземпляра книги BookInstance

Наконец, скопируйте код схемы `BookInstance` (приведён ниже) в файл **./models/bookinstance.js**. Схема `BookInstance` представляет конкретный экземпляр книги, которую можно одолжить на время, и содержит информацию о доступности экземпляров книги, о дате возврата одолженной книги, о деталях версии или печатного экземпляра.

```js
const mongoose = require("mongoose");

const Schema = mongoose.Schema;

const BookInstanceSchema = new Schema({
  book: { type: Schema.Types.ObjectId, ref: "Book", required: true }, // ссылка на связанную книгу
  imprint: { type: String, required: true },
  status: {
    type: String,
    required: true,
    enum: ["Available", "Maintenance", "Loaned", "Reserved"],
    default: "Maintenance",
  },
  due_back: { type: Date, default: Date.now },
});

// Виртуальное свойство URL экземпляра книги
BookInstanceSchema.virtual("url").get(function () {
  // Не используем стрелочную функцию, так как нам нужен объект this
  return `/catalog/bookinstance/${this._id}`;
});

// Экспорт модели
module.exports = mongoose.model("BookInstance", BookInstanceSchema);
```

В этой схеме новыми являются опции поля:

- `enum`: Позволяет указать допустимые значения строки. В нашем случае используются, чтобы задать статус доступности книги (применение enum (перечисления) означает, что мы ходим предотвратить ошибочное написание и произвольные значения статуса)
- `default`: определяет значение статуса по умолчанию (maintenance) при создании экземпляра книги, и дату `due_back` возврата книги (`now,` сейчас). Отметьте, как используется функция Date при установке даты!

Все остальное знакомо по предыдущим схемам.

### Модель жанра Genre - проверьте себя!

Откройте файл **./models/genre.js** и создайте схему для хранения жанра (категории книги, т.е. художественная или научная, романтика или военная история и т.д.).

Определение будет подобно другим моделям:

- В модели должно быть поле `name` типа `String` для указания жанра.
- Это поле должно быть обязательным, допустимый размер - от 3 до 100 символов.
- Объявите виртуальное ([virtual](#виртуальные-свойства)) свойство с именем `url` для URL жанра.
- Экспортируйте модель.

## Тестирование — создаём элементы БД

Отлично, теперь у нас есть все модели для сайта!

Чтобы протестировать модели (и создать примеры книг и других элементов, которые мы будем использовать в следующих статьях), запустим _независимый_ скрипт, который создаёт элементы каждого типа:

1. Скачайте (или создайте вручную) файл [populatedb.js](https://raw.githubusercontent.com/mdn/express-locallibrary-tutorial/main/populatedb.js) в каталоге _express-locallibrary-tutorial_ (на том же уровне, что и `package.json`).

   > [!NOTE]
   > Код в `populatedb.js` может быть полезен для изучения JavaScript, но разбираться в нём для этого руководства не обязательно. Его задача — просто заполнить базу тестовыми данными.

2. Запустите скрипт из командной строки с помощью node, передав в качестве аргумента URL вашей базы данных _MongoDB_ (тот самый, который вы ранее подставили вместо `_insert_your_database_url_here_` — в файле `bin/www` или, если у вас более старая версия кода приложения, в `app.js`):

   ```bash
   node populatedb <your MongoDB url>
   ```

   > [!NOTE]
   > В Windows нужно обернуть URL базы данных в двойные кавычки ("...").
   > В других ОС (Linux/macOS) чаще используются одинарные кавычки ('...').

3. Скрипт должен выполниться до конца, выводя в терминал создаваемые элементы.

> [!NOTE]
> Перейдите в интерфейс вашей базы данных MongoDB Atlas (вкладка _Collections_).
> Вы сможете просмотреть коллекции Books, Authors, Genres и BookInstances и убедиться, что они содержат созданные документы.

## Итог

В этой статье мы познакомились с БД и ОРМ (объектно-реляционными моделями) в системе Node/Express, узнали, как определяются схемы и модели Mongoose. Мы применили эти знания при проектировании и реализации моделей `Book`, `BookInstance`, `Author` и `Genre` для веб-сайта _LocalLibrary_.

В конце мы испытали свои модели путём создания ряда элементов (при помощи автономного скрипта). В следующей статье мы рассмотрим создание страниц, на которых будут показаны эти элементы.

## Смотрите также

- [Database integration](https://expressjs.com/en/guide/database-integration.html) Интеграция БД (документация Express)
- [Mongoose website](http://mongoosejs.com/) Веб-сайт Mongoose (документация Mongoose)
- [Mongoose Guide](http://mongoosejs.com/docs/guide.html) Справочник Mongoose (документация Mongoose)
- [Validation](http://mongoosejs.com/docs/validation.html) Валидация (документация Mongoose)
- [Schema Types](http://mongoosejs.com/docs/schematypes.html) Типы в схемах (документация Mongoose)
- [Models](http://mongoosejs.com/docs/models.html) Модели (документация Mongoose)
- [Queries](http://mongoosejs.com/docs/queries.html) Запросы (документация Mongoose)
- [Population](http://mongoosejs.com/docs/populate.html) Пополнение БД (документация Mongoose)

{{PreviousMenuNext("Learn/Server-side/Express_Nodejs/skeleton_website", "Learn/Server-side/Express_Nodejs/routes", "Learn/Server-side/Express_Nodejs")}}
